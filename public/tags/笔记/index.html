<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
	<title>笔记 - 子舒的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/tags/%E7%AC%94%E8%AE%B0/index.xml" title="子舒的博客">

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="topbar">
		<a class="topbar__link" href="/" title="子舒的博客" rel="sidebar">
			<div class="topbar__item topbar__text">
					<div class="topbar__title">子舒的博客</div>
					<div class="topbar__tagline">我的独立博客，记录了很多东西，随笔、周刊、笔记等，欢迎访问！</div>
				</div>
		</a>
	</div>
		
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">笔记</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/151.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">笔记:vue 中使用 axios 调用数据并渲染</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-07-12T00:00:00Z">2022-07-12</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例如下。
&lt;template&gt; &lt;div class=&#34;posts&#34;&gt; &lt;div v-for=&#34;item in list&#34; :key=&#34;item.cid&#34; &gt; {{ item.title }} &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Axios from &#39;axios&#39;; export default { name: &#39;index&#39;, data () { return { list: [] } }, methods: { getData () { var api = &#39;https://zburu.com/api/posts.php&#39;; Axios.get(api).then((response) =&gt; { this.list = response.data; console.log(response.data) }).catch((error) =&gt; { console.log(error); }) } }, mounted () { this.getData(); }, } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/146.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">obsidian:如何使用坚果云进行多端同步？</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-06-27T00:00:00Z">2022-06-27</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上篇文章 《关于我选择笔记系统这件小事》 ，obsidian 的个人体验很棒，我也打算长久使用作为个人知识库。
但是它有一个弊端，就是本地离线化导致同步是个问题，官方的同步服务很贵，给我劝退了，因此我寻求了其他的同步备份方案，就是今天我要分享的坚果云 + obsidian。
注册账号 在坚果云官网注册一个账号，选择个人用户，创建账号之后登陆。
点击创建 &gt; 个人同步文件夹，以后就同步这个文件夹内的内容了。这个我在里面新建了一个 test 文件夹。
pc 端同步 接下来需要将电脑本地的文件和坚果云的文件夹相连接，只要你在本地修改了文件，自动同步到坚果云。
点击页面左侧的下载客户端。
下载完成之后登陆，你就可以看到里面有一个 test 文件夹，是刚才在网页官网创建的。然后在右边三个点里面选择同步到本地。
浏览你的文件夹，找到一个地方存放 test 文件夹，点击确定，坚果云就会自动同步你在本地文件。但是这个时候 test 文件夹是空的，需要将 obsidian 文件全部移动进去就行了。然后在 obsidian 客户端重新打开 test 库。
在另一台电脑，进行上面同样的操作，将坚果云的同步文件夹映射到本地，就会自动下载云端的文件。之后，不管你在哪台电脑修改 obsidian 笔记，都会同步到拥有坚果云客户端的其他电脑。
这是 pc 端同步的方案，之后我会继续分享如果将 pc 同步到手机端。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/121.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">关于我选择笔记系统这件小事</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-04-28T00:00:00Z">2022-04-28</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		受年龄增长以及生活影响，人接触到的新事物和知识将会越来越多，大脑就显得有些混乱了，我也不敢保证自己的思维会始终保持一个高强度的在线状态。
因此决定整理个人知识库，将大脑中的片段和思想整理出来。以笔记和文字的形式将他记录下来，但是最近一直在寻求这样的工具，多方对比，也没有一款能真正满足我的需求的工具。
最好是自建的笔记，因为我今天在语雀写了一篇私密笔记，或许因为内容略带敏感吧，然后就被审查了，说我违规。
语雀这是我目前最满意的工具，但是现在对他的热情瞬间降低了很多。我怕哪天一下子账号里面的笔记全部被删了，那样我会很绝望的。
接下来我还会多方对比，最终选择一款平台亦或者是自建的笔记系统。
博客是写给别人看的，笔记是给自己看的，包括一些计划，列表清单等等，都是隐私的内容。还有就是一些文章的草稿，碎片化的记录，所以不宜放在博客上。
而且对于功能方面，我也有较高的要求，比如拖拽，表单，下拉框，卡片等等，都是我比较需要的，隐私和安全性更是我比较看重的。
暂时就这样吧，我会慢慢寻觅。
2022/05/03 更新
经过为期一周的尝试和部署过后，我最终决定了使用思源笔记，可以使用 docker 进行私有部署，本地备份，而且还可以选择付费订阅，备份到官方，这是两种可以同时进行的选择，我觉得很好的满足了我的需要。
主要还是思源的功能以及外表打动了我，页面简洁而美，功能不臃肿，刚好我需要的他都有，一点也没有多余的按键。符合我对笔记和个人知识库的个人，支持双链，不过我暂时用不到。支持 markdown 格式导入导出。
而我也逐步将我其他的笔记都迁移过来了，不过目前唯一的缺陷好像不支持分享，这也算我某种需求吧，我在寻求其解决方案，不过也不算什么大问题。
思源很多细节都打动了我，在单个文章复制的时候，提供了直接复制到其他平台的格式，不用再手动调了。
至于安全性方面，可以设置全局鉴权密码，不支持单篇文章加密。
2022/05/18 更新
半个月过去了，慢慢从思源迁移出来，原因很多，一方面是针对文件的安全性和稳定性抱有一丝怀疑，另外就是同步的问题，成本和精力都有些费事。
因此我选择了一个更不错的软件&mdash;obsidian，强大的社区，海量的插件以及可扩展性都是我选择它的原因。
对比之下，它更像是笔记界的 vscode，优势很多，轻量，可扩展，插件多。同时使用坚果云进行多端同步，这样不论是在公司电脑还是在自己的电脑上，我都可以做到无缝切换。
2022/06/18 更新
使用了一个月的 obsidain，反馈一下感受。整体来说很适合我这种记录文字的人，对 markdown 语法支持特别友好，格式都可以根据自己的想法展示出来，还带有一些插件，扩展我的使用方法。
在安全性方面，本地化、离线化也是非常棒的，可以根据自己的需要利用同步盘进行同步，或者自建 webdav 服务，稳定性也是很高的。
在数据迁移方面，完全不用担心，数据本质上还是 markdown 文件，如果哪有你对 obsidian 失望不再使用，或者有了更好的选择，可以直接把文件夹复制过去，都是很方便的。
但是这也只针对纯文件来说，如果是元数据，带有一些属性类的东西时，obsidain 就不是很好的选择了。正因为它是一个纯文件，所以注定没法保存元数据信息，这方面我和群里的阿均作了深刻的探讨。他比较注重“属性，标签，双链的指向，关系链，数值大小，层级隶属”等概念。
obsidian 是一堆小文件集合在一起形成的笔记架构，这和一般的数据库不太一样。
小文件很难做数据管理，反正长期看性能方面会有问题。一致性，也有问题，不重新索引确保不了一致性，重新索引，对于海量小文件，又难以提高性能。
阿均的担忧我也是能理解的，不过我们对笔记的定位有所不同。他更希望打造一个碎片化，利用双链结构形成自己的知识架构；而我是需要一个类 wiki 的东西，将我所获取到的知识按照分类进行归档，然后根据关键词，标签，标题，正文等内容进行搜索查询。
这是不同的方向，所以选择了不同的软件也是很正常的。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/103.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">【笔记】使用 php 写接口文件调用数据</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-02-22T00:00:00Z">2022-02-22</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用 php 写一个接口，然后将数据以 json 文件格式调用。
&lt;?php header(&#39;Content-Type:application/json; charset=utf-8&#39;); header(&#34;Access-Control-Allow-Origin:*&#34;); $servername = &#34;localhost&#34;; $username = &#34;数据库账号&#34;; $password = &#34;数据库密码&#34;; $dbname = &#34;数据库名称&#34;; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检测连接 if ($conn-&gt;connect_error) { die(&#34;连接失败：&#34; . $conn-&gt;connect_error); } $sql = &#34;select slug,title,created,text from typecho_contents&#34;; $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) { // 输出数据 while($row = $result-&gt;fetch_assoc()) { $data[]=$row; } $json = json_encode($data,JSON_UNESCAPED_UNICODE|JSON_PRETTY_PRINT);//把数据转换为 JSON 数据。 exit($json) ; } else { echo &#34;未查询到结果！&#34;; } $conn-&gt;close(); ?&gt; 根据某个条件排序，将 32 行的 sql 语句改为下面的，意为根据 created 进行排序。
$sql = &#34;select slug,title,created,text from typecho_contents order by created desc&#34;; 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/61.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">我的 python 学习笔记</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2021-04-01T00:00:00Z">2021-04-01</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		之所以学习 Python，本意是想写一些脚本之类的程序，用来在浏览器爬一些自己想要的文字，图片等资料，这些程序其实 GitHub 蛮多的，但奈何我对后端的语言一窍不通，直接拿过来给我用我都不会。
因此就萌生了先学习 Python 基础知识的想法，一直听说廖雪峰的 Python 教程写的不错，这次趁着这个机会要好好研读一番。也没想说用的多牛逼，至少希望能为自己浅薄的技术栈再增加一点光彩，毕竟我也曾梦想成为一个全栈开发。
下载安装完 Python 环境，就开始学习吧！
运行我的第一个 python 程序 print(&#39;hello,world&#39;) 数据类型 在 Python 中，能直接处理的数据类型有几种，整数、浮点数、字符串、布尔值、空值、变量。
这与其他语言其实差别并不大，数据类型基本都是相似的，大概只有变量有自己的特性，所以我单独拿出来记录一下。
变量 python 是一门动态语言，在赋值时可以不断改变，比如：
a = 123 print(a) # 终端输出数值 123 a = &#39;abc&#39; print(a) # 终端输出字符串 abc 这是允许的，而在 Java 中则不行，它是一门静态语言，如果多次赋值会报错。相对来说，动态语言更灵活，当然，各有利弊罢了。
并且在赋值上面有一个逻辑顺序，比如定义一个 a = 'a' 的变量。在 Python 中其实走了两步，先创造了一个字符串 a ，然后将这个字符串赋值给变量 a。
其实这在数学上是有些反逻辑的，x = x + 2 这个计算是行不通的在数学上，但是在计算机中，先计算 x + 2 ，然后将其赋值给左侧的 x ，这是计算机的逻辑。
x = 1 x = x + 2 print(x) # 3 其实很多计算机语言都是如此，比如我们所熟知的 js 等等。
如果有多个变量相互赋值的话，都是一行一行执行
a = 1 b = a a = 2 print(a) print(b) 最后输出的结果分别是 2, 1
Python 支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。 对变量赋值 x = y 是把变量 x 指向真正的对象，该对象是变量 y 所指向的。随后对变量 y 的赋值不影响变量 x 的指向。 注意：Python 的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如 Java 对 32 位整数的范围限制在 -2147483648-2147483647。 Python 的浮点数也没有大小限制，但是超出一定范围就直接表示为 inf（无限大）。&mdash;《廖雪峰的官方网站》
字符串和编码 Python 提供了两个处理编码的属性，ord 和 chr
ord(&#39;舒&#39;) # 33298 # 将字符串转换为整数表示 chr(33298) # &#39;舒&#39; # 将整数表示的内容转换为字符串 list list 类似于 js 中的 Array，是多个数据的列表，写法如下
&gt;&gt;&gt; classmates = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &gt;&gt;&gt; classmates [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 这时候我们就可以说变量 classmates 是一个 list。
有一个 len() 可以输出 list 元素的个数
&gt;&gt;&gt; len(classmates) &gt;&gt;&gt; 3 同时 list 也有索引，从 0 开始，最后一个索引是 len(classmates)-1，同时如果想直接输出最后一个元素，可以使用 classmates[-1].
&gt;&gt;&gt; classmates[-1] &gt;&gt;&gt; &#39;c&#39; 既然都可以用 -1 表示最后一个元素，能不能用 -2 表示倒数第二个呢？答案是可以的。
&gt;&gt;&gt; classmates[-2] &gt;&gt;&gt; &#39;b&#39; 另外需要注意的是，在使用索引时不可超出范围，否则会报出下面的错误。
&gt;&gt;&gt; classmates[4] Traceback (most recent call last): File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt; IndexError: list index out of range list 是一个可变的有序列表，可以往里面添加或者删除元素。
append 在末尾添加元素 &gt;&gt;&gt; classmates.append(&#39;d&#39;) &gt;&gt;&gt; classmates [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] insert 在指定位置添加元素 其中 1 是索引，表示在索引为 1 的地方插入元素，后面的元素自然往后顺延。
&gt;&gt;&gt; classmates.insert(1, &#39;d&#39;) &gt;&gt;&gt; classmates [&#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;] pop 删除末尾的元素 &gt;&gt;&gt; classmates.pop() &#39;c&#39; # 输出的时候被删除的元素 &gt;&gt;&gt; classmates [&#39;a&#39;, &#39;b&#39;] pop(i) 删除指定位置的元素 &gt;&gt;&gt; classmates.pop(1) &#39;b&#39; # 输出被删除的元素 &gt;&gt;&gt; classmates [&#39;a&#39;, &#39;c&#39;] &gt;&gt;&gt; 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/39.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">React 学习笔记（三）</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-29T00:00:00Z">2020-12-29</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源于：https://react.docschina.org/docs/forms.html
一、表单 在 React 中，html 表单元素的工作方式和其他的 DOM 元素不太一样，因为表单内部通常会保持一些内部的 state，比如下面这个纯 html 表单只接受一个名称：
&lt;form&gt; &lt;label&gt; 名字： &lt;input type=&#34;text&#34; name=&#34;name&#34; /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; 这个表单具有默认的 html 表单行为，即在用户提交表单之后自动刷新页面。如果你在 React 中执行相同的代码，它仍然有效。
但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交，同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。
受控组件 在 html 中，表单元素比如&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;，这些表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。
我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。
例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：
class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;提交的名字：&#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 名字: &lt;input type=&#34;text&#34; value={this.state.value} onChange={this.handleChange} /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。
对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。
textarea 标签 在 html 中，&lt;textarea&gt; 元素通过其子元素定义其文本：
&lt;textarea&gt; 测试！ &lt;/textarea&gt; 而在 React 中，&lt;textarea&gt; 使用 value 属性代替。这样，可以使得使用 &lt;textarea&gt; 的表单和使用单行 input 的表单非常类似：
class EssayForm extends React.Component { constructor(props) { super(props); this.state = { value: &#39;请撰写一篇关于你喜欢的 DOM 元素的文章。&#39; }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;提交的文章：&#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 文章: &lt;textarea value={this.state.value} onChange={this.handleChange} /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。
select 标签 在 HTML 中，&lt;select&gt; 创建下拉列表标签。例如，如下 html 创建了水果相关的下拉列表：
&lt;select&gt; &lt;option value=&#34;grapefruit&#34;&gt;葡萄柚&lt;/option&gt; &lt;option value=&#34;lime&#34;&gt;酸橙&lt;/option&gt; &lt;option selected value=&#34;coconut&#34;&gt;椰子&lt;/option&gt; &lt;option value=&#34;mango&#34;&gt;芒果&lt;/option&gt; &lt;/select&gt; 请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：
class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;coconut&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;你喜欢的风味是：&#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 选择你喜欢的风味： &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;option value=&#34;grapefruit&#34;&gt;葡萄柚&lt;/option&gt; &lt;option value=&#34;lime&#34;&gt;酸橙&lt;/option&gt; &lt;option value=&#34;coconut&#34;&gt;椰子&lt;/option&gt; &lt;option value=&#34;mango&#34;&gt;芒果&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 总的来说，这使得 &lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; 和 &lt;select&gt; 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。
注意：你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：
&lt;select multiple={true} value={[&#39;B&#39;, &#39;C&#39;]}&gt; 文件 input 标签 在 HTML 中，&lt;input type=&quot;file&quot;&gt; 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。
&lt;input type=&#34;file&#34; /&gt; 因为它的 value 只读，所以它是 React 中的一个非受控组件。
处理多个输入 当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。
class Reservation extends React.Component { constructor(props) { super(props); this.state = { isGoing: true, numberOfGuests: 2 }; this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(event) { const target = event.target; const value = target.name === &#39;isGoing&#39; ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } render() { return ( &lt;form&gt; &lt;label&gt; 参与: &lt;input name=&#34;isGoing&#34; type=&#34;checkbox&#34; checked={this.state.isGoing} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; 来宾人数： &lt;input name=&#34;numberOfGuests&#34; type=&#34;number&#34; value={this.state.numberOfGuests} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;/form&gt; ); } } 这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值：
例如：
this.setState({ [name]: value }); 等同于 es5：
var partialState = {}; partialState[name] = value; this.setState(partialState); 另外，由于 setState() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。
受控输入空值 在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。
下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）
ReactDOM.render(&lt;input value=&#34;hi&#34; /&gt;, mountNode); setTimeout(function() { ReactDOM.render(&lt;input value={null} /&gt;, mountNode); }, 1000); 受控组件的替代品 有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件，这是实现输入表单的另一种方式。
成熟的解决方案 如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 Formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/29.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">vue 学习笔记 (3)－－computed, watch，calss, style</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-25T00:00:00Z">2020-11-25</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、计算属性 computed 1.例子 &lt;div id=&#34;app&#34;&gt; &lt;div&gt;{{message}}&lt;/div&gt; &lt;div&gt;{{revermessage}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39; }, computed: { revermessage: function() { return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) } } }) &lt;/script&gt; 声明一个计算属性severmessage，在computed中被指向对message进行一些方法操作后的返回值
此时vm.severmessage依赖于vm.message的变化，对message改变数据，会引起severmessage的更新
2.计算属性缓存和方法 还可以通过在表达式中调用方法来达到想要的效果
&lt;div id=&#34;app&#34;&gt; &lt;div&gt;{{message}}&lt;/div&gt; &lt;div&gt;{{revermessage()}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39; }, methods: { revermessage: function() { return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) } } }) &lt;/script&gt; 经过测试，两者的结果是一样的
我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的
区别是：计算属性是基于他们的响应式依赖进行缓存的，只有当响应式依赖，也就是message发生改变时才会重新求值，就意味着，只要message还没改变，多次访问revermessage计算属性只会返回之前计算结果的缓存，而不是直接执行计算属性的函数
而方法，在每次触发重新渲染时，调用方法都会执行一次函数，这就多了一份开销
我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代
3.计算属性和侦听属性 vue 还有一种方式来观测 vue 实例上的数据变动：侦听属性－－watch
&lt;div id=&#34;app&#34;&gt; {{fullname}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { firstname: &#39;a&#39;, lastname: &#39;b&#39;, fullname: &#39;ab&#39; }, watch: { firstname: function(val) { this.fullName = val + &#39; &#39; + this.lastName }, lastname: function(val) { this.fullName = this.firstName + &#39; &#39; + val } } }) &lt;/script&gt; 使用过程是极其繁琐且重复的，再来用计算属性试一下
&lt;div id=&#34;app&#34;&gt; {{fullname}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { firstname: &#39;a&#39;, lastname: &#39;b&#39; }, computed: { fullname: function() { return this.firstname + this.lastname } } }) &lt;/script&gt; 很简单快速的就得到了我们想要的函数表达式
4.计算属性的 setter computed: { fullName: { // getter get: function () { return this.firstName + &#39; &#39; + this.lastName }, // setter set: function (newValue) { var names = newValue.split(&#39; &#39;) this.firstName = names[0] this.lastName = names[names.length - 1] } } } 现在在控制台输入vm.fullName = 'John Doe'，页面会响应，并且setter会被调用，vm.firstname和vm.lastname也会相应地被更新
二、绑定 class 和 style 1.对象语法 可以给v-bind:class传入一个对象，动态的切换class
&lt;div v-bind:class=&#34;{active: ok}&#34;&gt;&lt;/div&gt; 可以通过控制ok的布尔值来动态的控制 class
还可以创建多个字段，并且不影响普通的className的存在
html:
&lt;div class=&#34;static&#34; v-bind:class=&#34;{ active: isActive, &#39;text-danger&#39;: hasError }&#34; &gt;&lt;/div&gt; data:
data{ isActive: true, hasError: false } 结果为：
&lt;div class=&#34;static active&#34;&gt;&lt;/div&gt; 当isActive或者hasError变化时，class 列表将相应地更新。例如，如果hasError的值为true，class 列表将变为&quot;static active text-danger&quot;。
绑定的数据对象也不必直接写在内联模板里
&lt;div id=&#34;app&#34;&gt; &lt;div v-bind:class=&#34;classobject&#34;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { classobject: { active: true, &#39;text-danger&#39;: true } }, }) &lt;/script&gt; &lt;!-- &lt;div class=&#34;active text-danger&#34;&gt;&lt;/div&gt; --&gt; 如果className有特殊符号，必须加上引号''，或者&quot;&quot;
2.数组语法 我们可以把一个数组传给v-bind:class，以应用一个 class 列表
&lt;div v-bind:class=&#34;[activeClass, errorClass]&#34;&gt;&lt;/div&gt; data: { activeClass: &#39;active&#39;, errorClass: &#39;text-danger&#39; } 渲染为：
&lt;div class=&#34;active text-danger&#34;&gt;&lt;/div&gt; 3.用在组件上 当在一个自定义组件上使用classproperty 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。
Vue.component(&#39;my-component&#39;, { template: &#39;&lt;p class=&#34;foo bar&#34;&gt;Hi&lt;/p&gt;&#39; }) 然后在使用的使用的时候添加了一些class：
&lt;my-component class=&#34;baz boo&#34;&gt;&lt;/my-component&gt; html 将会被渲染成：
&lt;p class=&#34;foo bar baz boo&#34;&gt;Hi&lt;/p&gt; 对于带数据绑定的class也同样适用
&lt;my-component v-bind:class=&#34;{ active: isActive }&#34;&gt;&lt;/my-component&gt; 当isActive为 truthy 时，HTML 将被渲染成为：
&lt;p class=&#34;foo bar active&#34;&gt;Hi&lt;/p&gt; 4.绑定内联样式 style v-bind:style的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式或带引号的短横线来命名
&lt;div v-bind:style=&#34;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&#34;&gt;&lt;/div&gt; js:
data: { activeColor: &#39;red&#39;, fontSize: 30 } 或者直接绑定到一个对象，会让模板更加清晰
&lt;div v-bind:style=&#34;styleObject&#34;&gt;&lt;/div&gt; js:
data: { styleObject: { color: &#39;red&#39;, fontSize: &#39;13px&#39; } } 也可以将多个对象应用到一个元素上
&lt;div v-bind:style=&#34;[baseStyles, overridingStyles]&#34;&gt;&lt;/div&gt; 自动添加前缀
当v-bind:style需要使用浏览器前缀的时候，如：-webkit-等，vue 会自动侦测并帮生成相应的前缀
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/28.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">vue 学习笔记 (2)－－vue 实例和模板语法</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-24T00:00:00Z">2020-11-24</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue 实例 1.创建 vue 实例 一个 vue 实例应该通过new Vue来创建根实例，所有的 vue 组件其实都是 vue 实例
var vm = new Vue({ ... }) 当一个实例被创建时，data对象中的 property 都被加入到 vue 的响应式系统中，当值发生改变时，试图也会改变
var data = {a: 1} var vm = new Vue({ data: data }) 此时在控制台输入vm.a == data.a会返回 true，变量data已经被赋给vue实例中的data对象了
同时，对两个对象的数据进行操作改变也会影响到另一个
vm.a = 2 // data.a = 2 data.a = 3 // vm.a = 3 当数据改变时，视图也会重新渲染，如果在 vue 实例被创建后，又添加了一个新的 property，则不会被加入到响应式系统中
如果一开始就知道后面会添加一个 property，但是一开始不存在或为空，需要设置一些初始值
data: { newTodoText: &#39;&#39;, visitCount: 0, hideCompletedTods: fasle, todos: [], error: null } 使用 Object.freeze() 方法的时候，无法修改数据引起视图变化
Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。
&lt;div id=&#34;app&#34;&gt;{{message}}&lt;/div&gt; &lt;script&gt; var data = {message: &#39;hello,wolrd&#39;} Object.freeze(data) var vm = new Vue({ el: &#39;#app&#39;, data: data }) &lt;/script&gt; 在控制台改变vm.message的值会直接报错，因为 data 对象已经被冻结了，不可改变
vm.$data
代表 vue 实例观察的数据对象
console.log(vm.$data) // 返回数据对象的数组形式 var data = { a: 1 } var vm = new Vue({ el: &#39;#app&#39;, data: data }) vm.$data === data // true vm.$el === document.getElementById(&#39;app&#39;) // true 2.生命周期函数 每个实例在被创建的时候，都要经历一些初始化过程，比如：设置数据监听，编译模板，将实例挂载到 dom，更新 dom 等
在这个过程中会运行一些叫做生命周期的钩子函数，可以在不同阶段添加自己需要的代码
比如created钩子可以用来表示一个实例被创建之后执行的代码
new Vue({ data: { a: 1 }, created: function () { console.log(&#39;a is: &#39; + this.a) } }) // &#34;a is: 1&#34; this用来指向 vm 实例
但是不要在 property 或者回调上使用箭头函数，created: () =&gt; console.log(this.a)，因为箭头函数没有this的概念，他会把this当作变量一直向上级作用域查找，经常产生Uncaught TypeError: Cannot read property of undefined或Uncaught TypeError: this.myMethod is not a function之类的报错
二、模板语法 1.插值 最简单的就是
&lt;div id=&#34;app&#34;&gt;{{message}}&lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,world&#39; } }) &lt;/script&gt; &lt;/script&gt; 。。。
下面这段代码给input绑定了一个disabled属性，但是通过ok的真伪来控制属性是否渲染
当ok为fasle,null,undefined值时，属性都不会被渲染，有点类似于v-if，但是这种写法只是针对属性
&lt;div id=&#34;app&#34;&gt; &lt;input type=&#34;text&#34; v-bind:disabled=&#34;ok&#34;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39;, ok: false } }) &lt;/script&gt; 在模板语法中还可以使用 javascript 表达式
&lt;div id=&#34;app&#34;&gt; &lt;div&gt;{{number + 1}}&lt;/div&gt; &lt;div v-bind:id=&#34;&#39;list-&#39; + id&#34;&gt;&lt;/div&gt; &lt;div&gt;{{message.split(&#39;&#39;).reverse().join(&#39;&#39;)}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { number: 2, id: &#39;li&#39;, message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; 每个模板只能包含一个 javascript 表达式，如果有多个，则不会生效
&lt;!-- 这是语句，不是表达式 --&gt; {{ var a = 1 }} &lt;!-- 流控制也不会生效，请使用三元表达式 --&gt; {{ if (ok) { return message } }} 2.指令 参数
一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind指令可以用于响应式地更新 HTML attribute：
&lt;div id=&#34;app&#34;&gt; &lt;a v-bind:href=&#34;url&#34;&gt;百度&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { url: &#39;https://www.baidu.com&#39; } }) &lt;/script&gt; 在这里href是参数，告知v-bind指令将该元素的hrefattribute 与表达式url的值绑定
另一个例子是v-on指令，它用于监听 dom 事件
&lt;a v-on:click=&#34;doSomething&#34;&gt;...&lt;/a&gt; 动态参数
从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数
&lt;!--注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。--&gt; &lt;a v-bind:[attributeName]=&#34;url&#34;&gt;...&lt;/a&gt; 这里的attributeName会被作为一个 javascript 表达式进行动态求值，最终结果被作为参数来使用
比如：vue 实例中有一个attributeName属性其值为href，则这个绑定将等价于v-bind:href
&lt;a v-bind:href=&#34;url&gt;...&lt;/a&gt; 也可以使用动态的事件名绑定监听函数
&lt;a v-on:[eventName]=&#34;doSomething&#34;&gt; ... &lt;/a&gt; 如果eventName值为click，则该绑定等价于v-on:click=&quot;doSomething&quot;，一个鼠标点击事件
对动态参数的值的约束
动态参数预期会求出一个字符串，异常情况下值为null，这个特殊的null值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。
对动态参数表达式的约束
动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的，例如：
&lt;!-- 这会触发一个编译警告 --&gt; &lt;a v-bind:[&#39;foo&#39; + bar]=&#34;value&#34;&gt; ... &lt;/a&gt; 因此，尽量不要使用空格和引号的表达式，或者采用计算属性来替代这种复杂表达式
在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写
修饰符
修饰符是以.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，例如，.prevent修饰符告诉v-on指令对于触发的事件调用event.preentDefault()
&lt;form v-on:submit.prevent=&#34;onSubmit&#34;&gt;...&lt;/form&gt; 3.缩写 v-前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v-前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v-前缀也变得没那么重要了。因此，Vue 为v-bind和v-on这两个最常用的指令，提供了特定简写
v-bind
&lt;!-- 完整语法 --&gt; &lt;a v-bind:href=&#34;url&#34;&gt;...&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a :href=&#34;url&#34;&gt;...&lt;/a&gt; &lt;!-- 动态参数的缩写 (2.6.0+) --&gt; &lt;a :[key]=&#34;url&#34;&gt; ... &lt;/a&gt; v-on
&lt;!-- 完整语法 --&gt; &lt;a v-on:click=&#34;doSomething&#34;&gt;...&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a @click=&#34;doSomething&#34;&gt;...&lt;/a&gt; &lt;!-- 动态参数的缩写 (2.6.0+) --&gt; &lt;a @[event]=&#34;doSomething&#34;&gt; ... &lt;/a&gt; 它们看起来可能与普通的 HTML 略有不同，但:与@对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/27.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">vue 学习笔记 (1)－－什么是 vue?</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-23T00:00:00Z">2020-11-23</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 vue? 练习时使用，最新版本
&lt;script src=&#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&#34;&gt;&lt;/script&gt; 生产时使用，明确版本号的版本，避免造成不可预见的问题
&lt;script src=&#34;https://cdn.jsdelivr.net/npm/vue@2.6.12&#34;&gt;&lt;/script&gt; hello world
&lt;div id=&#34;app&#34;&gt; {{message}} &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,world&#39; } }) &lt;/script&gt; 1.v-指令 v-bind－－绑定属性 &lt;div id=&#34;app-2&#34;&gt; &lt;span v-bind:title=&#34;message&#34;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#39;#app&#39;, data: { message: &#39;页面加载于 &#39; + new Date().toLocaleString() } }) &lt;/script&gt; v-bind是 vue 特有的提供的属性，他会在 dom 上应用一个响应式的操作
打开 console，输入app.message = &quot;hello&quot;，页面会改变内容只显示hello
又或者输入app.message = false，内容会直接不显示
vue 官网例子：
&lt;!-- 绑定一个 attribute --&gt; &lt;img v-bind:src=&#34;imageSrc&#34;&gt; &lt;!-- 动态 attribute 名 (2.6.0+) --&gt; &lt;button v-bind:[key]=&#34;value&#34;&gt;&lt;/button&gt; &lt;!-- 缩写 --&gt; &lt;img :src=&#34;imageSrc&#34;&gt; &lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt; &lt;button :[key]=&#34;value&#34;&gt;&lt;/button&gt; &lt;!-- 内联字符串拼接 --&gt; &lt;img :src=&#34;&#39;/path/to/images/&#39; + fileName&#34;&gt; &lt;!-- class 绑定 --&gt; &lt;div :class=&#34;{ red: isRed }&#34;&gt;&lt;/div&gt; &lt;div :class=&#34;[classA, classB]&#34;&gt;&lt;/div&gt; &lt;div :class=&#34;[classA, { classB: isB, classC: isC }]&#34;&gt; &lt;!-- style 绑定 --&gt; &lt;div :style=&#34;{ fontSize: size + &#39;px&#39; }&#34;&gt;&lt;/div&gt; &lt;div :style=&#34;[styleObjectA, styleObjectB]&#34;&gt;&lt;/div&gt; &lt;!-- 绑定一个全是 attribute 的对象 --&gt; &lt;div v-bind=&#34;{ id: someProp, &#39;other-attr&#39;: otherProp }&#34;&gt;&lt;/div&gt; &lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt; &lt;div v-bind:text-content.prop=&#34;text&#34;&gt;&lt;/div&gt; &lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt; &lt;my-component :prop=&#34;someThing&#34;&gt;&lt;/my-component&gt; &lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt; &lt;child-component v-bind=&#34;$props&#34;&gt;&lt;/child-component&gt; &lt;!-- XLink --&gt; &lt;svg&gt;&lt;a :xlink:special=&#34;foo&#34;&gt;&lt;/a&gt;&lt;/svg&gt; v-if－－控制元素的显示隐藏 刚才写了，通过app.message = false，可以让message代表的内容处于隐藏状态，但是控制的只能是通过v-for引入的内容，无法直接让元素隐藏
其实，vue 中还有一个专门控制元素显示隐藏的指令－－v-if
&lt;div id=&#34;app&#34;&gt; &lt;span v-if=&#34;show&#34;&gt; {{message}} &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,world&#39;, show: true } }) &lt;/script&gt; 给元素绑定一个指令v-if = &quot;show&quot;，然后在 data 中控制show的布尔值，true 显示，false 隐藏
同时还有这个功能的指令v-show，根据表达式之真假值，切换元素的display CSS property，也是通过绑定的布尔值来显示隐藏
但是v-if和v-show有些区别
(1) v-if 是控制元素是否渲染最终控制元素的显示隐藏，适用于切换频率低的情况 (2) v-show 不管显示隐藏都渲染，然后通过布尔值绑定display: none属性，适用于切换频率高的情况
注意：v-show不支持&lt;tempalte&gt;元素，也不支持v-else
搭配用法
v-else和v-else-if
可以通过使用v-else达到v-if的效果，必须和v-if搭配使用，比如：
&lt;div v-if=&#34;1&gt;2&#34;&gt; hello &lt;/div&gt; &lt;div v-else&gt; hi &lt;/div&gt; 如果v-if不成立，执行v-else，也就是显示 v-else 里面的内容
是不是有点 javascript 里面if函数的感觉了
v-else-if用法大致一样，必须和v-if和v-else搭配使用
v-for－－遍历数组并显示到页面上 v-for算是 vue 的核心指令之一了把，主要是渲染一个项目列表的
&lt;div id=&#34;app&#34;&gt; &lt;div v-for=&#34;item in list&#34;&gt;{{item.message}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { list: [ {message: &#39;html&#39;}, {message: &#39;css&#39;} ] } }) &lt;/script&gt; 可以直接把列表数据循环输出
并且在控制台中通过push()还能添加新的列表项
app.list.push({message: &#34;js&#34;}) vue 对数据操作，就是这么神奇
不推荐v-for和v-if同时使用，因为v-for拥有更高的优先级
v-on－－绑定事件监听器 即绑定事件，通过v-on给 div 绑定了一个点击事件，注意，在reverseMessage方法中，我们更新了应用的状态，但是吗诶呀触碰到 dom，直接通过 vue 来进行处理，编写代码时只需要关注逻辑层即可
v-on:click=&quot;messagenone&quot;，然后在methods里面写上事件方法
&lt;div id=&#34;app&#34;&gt; &lt;div v-on:click=&#34;messagenone&#34; id=&#34;demo&#34;&gt;{{message}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,wolrd&#39; }, methods: { messagenone: function() { var demo = document.getElementById(&#39;demo&#39;); demo.innerHTML = &#39;&#39; } } }) &lt;/script&gt; v-model－－数据的双向绑定 vue 还提供了v-model指令，它能轻松实现表单输入和应用状态之间的双向绑定
可使用场景：标签 input, select, textarea 和 components
&lt;div id=&#34;app&#34;&gt; &lt;div&gt;{{message}}&lt;/div&gt; &lt;input type=&#34;text&#34; v-model=&#34;message&#34;&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; v-text 更新元素的内容 &lt;div id=&#34;app&#34;&gt; &lt;div v-text=&#34;message&#34;&gt;&lt;/div&gt; &lt;div&gt;{{message}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; 上面的 div 和下面的 div 内容跟随一致变化
v-html－－更新元素的 innerHTML 不建议使用，在网站上动态渲染 html 是非常危险的，容易导致XXS 攻击，不能用在用户提交的内容上，如果必须使用 v-html，可以考虑通过使用组件来代替
v-pre 跳过绑定的元素和他的子元素的编译，直接显示原始内容
跳过没有指令的节点不进行编译，直接显示内容，会加快页面的响应
v-cloak 在编译没有编译完成之前，模板处于的状态
&lt;style&gt;v-cloak] { display: none; }&lt;/style&gt; &lt;div v-cloak&gt; {{message}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; 上述代码表示的含义是，如果网络不好，{{message}}模板代表的hello,world还没有编译成功，此时{{message}}处于隐藏状态，当编译完成，页面直接显示hello,world
v-once－－一次性渲染 绑定该指令的元素及其子元素只会进行一次渲染，之后页面的第二次渲染会将其视为静态资源并跳过，可以用来优化性能
&lt;div id=&#34;app&#34;&gt; &lt;span v-once&gt;{{message}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39;, } }) &lt;/script&gt; 使用场景：表单提交。可防止用户在请求未及时响应时，多次提交~
2.组件化构建应用 组件化也是 vue 的核心机制之一，它允许我们使用小型，可复用的组件来构建大型应用
在 vue 里，一个组件本质上是一个拥有预定义选项的一个 vue 实例。在 vue 中注册组件很简单
// 定义名为 todo-item 的新组件 Vue.component(&#39;todo-item&#39;, { template: &#39;&lt;li&gt;这是个待办项&lt;/li&gt;&#39; }) var app = new Vue(...) 现在可以用它构建另一个组件模板
&lt;ol&gt; &lt;!-- 创建一个 todo-item 组件的实例 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt; &lt;/ol&gt; 但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个props
Vue.component(&#39;todo-item&#39;, { // todo-item 组件现在接受一个 // &#34;props&#34;，类似于一个自定义 attribute。 // 这个 props 名为 todo。 props: [&#39;todo&#39;], template: &#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39; }) 现在，我们可以使用v-bind指令将待办项传到循环输出的每个组件中
现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的，我们也需要为每个组件提供一个key
&lt;div id=&#34;app-7&#34;&gt; &lt;ol&gt; &lt;todo-item v-for=&#34;item in groceryList&#34; v-bind:todo=&#34;item&#34; v-bind:key=&#34;item.id&#34; &gt;&lt;/todo-item&gt; &lt;/ol&gt; &lt;/div&gt; Vue.component(&#39;todo-item&#39;, { props: [&#39;todo&#39;], template: &#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39; }) var app7 = new Vue({ el: &#39;#app-7&#39;, data: { groceryList: [ { id: 0, text: &#39;蔬菜&#39; }, { id: 1, text: &#39;奶酪&#39; }, { id: 2, text: &#39;随便其它什么人吃的东西&#39; } ] } }) 尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过prop接口与父单元进行了良好的解耦。我们现在可以进一步改进 组件，提供更为复杂的模板和逻辑，而不会影响到父单元
在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理
&lt;div id=&#34;app&#34;&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt; &lt;/div&gt; 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/21.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">事件监听函数，以及事件的捕获和冒泡机制</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-17T00:00:00Z">2020-11-17</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件，事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流
函数事件 事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件
事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流
true 是捕获，false 是冒泡，默认为冒泡事件
1.addEventListener()－－添加事件监听函数 给元素添加一个事件，假如有多个事件，不会覆盖，会依次执行
&lt;div id=&#34;demo&#34;&gt;dom&lt;/div&gt; &lt;script&gt; document.getElementById(&#39;demo&#39;).addEventListener(&#34;click&#34;, myfun) document.getElementById(&#39;demo&#39;).addEventListener(&#34;click&#34;, myfun1) function myfun() { console.log(&#39;事件监听函数&#39;) } function myfun1() { console.log(&#39;addEventListener&#39;) } &lt;/script&gt; 注意： 1.这里有一个细节，addEventListener() 里面有两个参数，第一个表示触发的条件，第二个表示触发的事件 正常情况下，第二个参数直接写函数名并且不加参数()，如果加了参数()则表示立即执行，不需要触发第一个参数要求的条件
2.在这里绑定事件的时候，事件名不能和定义的变量名一样，否则无效
2.removeEventListener()－－移除事件监听函数 下面这个 demo，当鼠标在 div 中移动的时候，出现随机数，点击按钮后，移除事件监听函数
&lt;!-- css --&gt; &lt;style&gt; #demo { width: 100px; height: 100px; border: 1px solid #000; } &lt;/style&gt; &lt;!-- html --&gt; &lt;div id=&#34;demo&#34;&gt;&lt;/div&gt; &lt;input type=&#34;button&#34; value=&#34;点击移除&#34; onclick=&#34;remove()&#34;&gt; &lt;div id=&#34;show&#34;&gt;&lt;/div&gt; &lt;!-- js --&gt; &lt;script&gt; document.getElementById(&#39;demo&#39;).addEventListener(&#34;mousemove&#34;, myfun) function myfun() { document.getElementById(&#39;show&#39;).innerHTML = Math.random() } function remove() { document.getElementById(&#39;demo&#39;).removeEventListener(&#34;mousemove&#34;, myfun) } &lt;/script&gt; 3.利用事件的捕获和冒泡做点事情 addEventListener() 和 removeEventListener() 其实拥有三个参数，刚才说过了，第一个表示触发条件，第二个表示触发事件，第三个参数正常情况下可以省略，但是要知道它代表的意思
用布尔值来表示，true 或者 false，默认是 false
true 表示在捕获阶段调用事件处理程序 false 表示在冒泡阶段调用事件处理程序 根据图片可以看出，捕获阶段要先于冒泡阶段，因此，true 事件要先于 flase 事件触发，多个 true 事件按顺序触发，多个 false 事件，写在后面的先触发
结论：写在前面的 true 事件 &gt; 写在后面的 true 事件 &gt; 写在后面的 false 事件 &gt; 写在前面的 false 事件
因此，利用这个参数，可以控制同一个元素的不同事件触发的顺序
&lt;div id=&#34;out&#34;&gt; &lt;p&gt;最外面&lt;/p&gt; &lt;div id=&#34;middle&#34;&gt; &lt;div id=&#34;inner&#34;&gt;最里面&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 第一种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：inner-------middle------out out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},false); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第二种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out------middle-------inner out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},true); &lt;/script&gt; &lt;!-- 第三种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out------inner-------middle out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第四种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out-------middle------inner out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第五种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：middle-------inner------out out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},false); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第六种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out-------inner------middle out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},true); &lt;/script&gt; 4.事件处理程序 HTML 事件处理程序 &lt;button onclick=&#34;test()&#34;&gt;测试&lt;/button&gt; &lt;script&gt; function test() { alert(&#34;HTML 事件处理程序&#34;); } &lt;/script&gt; 1.优点：事件处理程序中的代码，能够访问全局作用域中的任何变量 2.缺点：时差问题、扩展的作用域链在不同浏览器中会导致不同结果、html 代码与 js 代码高度耦合
DOM0 级事件处理程序 &lt;button id=&#34;btn&#34;&gt;测试&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#34;btn&#34;); btn.onclick = function test() { alert(&#34;DOM0 级事件处理程序&#34;); } &lt;/script&gt; 1.优点：代码简单，浏览器兼容性好，解决了 html 代码和 js 代码的高度耦合问题 2.缺点：一个元素只能绑定一个事件处理函数，只会在事件冒泡中运行
DOM2 级事件处理程序 该级别的事件处理程序，运用的就是事件捕获和冒泡机制
&lt;button id=&#34;btn&#34;&gt;测试&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#34;btn&#34;); // 事件监听 btn.addEventListener(&#34;click&#34;, function() { alert(&#34;DOM2 级事件处理程序，我在捕获阶段执行&#34;); }, true); btn.addEventListener(&#34;click&#34;, function() { alert(&#34;DOM2 级事件处理程序，我在冒泡阶段执行&#34;); }, false); // 移除事件监听 var fun = function() { alert(&#34;我要被移除了&#34;); } btn.addEventListener(&#34;click&#34;, fun, false); btn.removeEventListener(&#34;click&#34;, fun, false); &lt;/script&gt; 1.优点：同时支持事件处理的捕获和冒泡阶段，并且一个元素可以绑定多个处理函数 2.缺点：IE 不支持
	</div>
</article>

</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/2</span>
	<a class="pagination__item pagination__item--next btn" href="/tags/%E7%AC%94%E8%AE%B0/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 子舒的博客, 
			使用 hugo 构建
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    id="MathJax-script"
    async
    src="https://gcore.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>
</body>
</html>