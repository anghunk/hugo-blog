<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记 on 子舒的博客</title>
    <link>https://zishu.me/tags/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Jul 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://zishu.me/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>笔记:vue 中使用 axios 调用数据并渲染</title>
      <link>https://zishu.me/blog/151.html/</link>
      <pubDate>Tue, 12 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/151.html/</guid>
      <description>示例如下。&#xA;&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;posts&amp;#34;&amp;gt; &amp;lt;div v-for=&amp;#34;item in list&amp;#34; :key=&amp;#34;item.cid&amp;#34; &amp;gt; {{ item.title }} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import Axios from &amp;#39;axios&amp;#39;; export default { name: &amp;#39;index&amp;#39;, data () { return { list: [] } }, methods: { getData () { var api = &amp;#39;https://zburu.com/api/posts.php&amp;#39;; Axios.get(api).then((response) =&amp;gt; { this.list = response.data; console.log(response.data) }).catch((error) =&amp;gt; { console.log(error); }) } }, mounted () { this.getData(); }, } &amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; &amp;lt;/style&amp;gt; </description>
    </item>
    <item>
      <title>obsidian:如何使用坚果云进行多端同步？</title>
      <link>https://zishu.me/blog/146.html/</link>
      <pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/146.html/</guid>
      <description>接上篇文章 《关于我选择笔记系统这件小事》 ，obsidian 的个人体验很棒，我也打算长久使用作为个人知识库。&#xA;但是它有一个弊端，就是本地离线化导致同步是个问题，官方的同步服务很贵，给我劝退了，因此我寻求了其他的同步备份方案，就是今天我要分享的坚果云 + obsidian。&#xA;注册账号 在坚果云官网注册一个账号，选择个人用户，创建账号之后登陆。&#xA;点击创建 &amp;gt; 个人同步文件夹，以后就同步这个文件夹内的内容了。这个我在里面新建了一个 test 文件夹。&#xA;pc 端同步 接下来需要将电脑本地的文件和坚果云的文件夹相连接，只要你在本地修改了文件，自动同步到坚果云。&#xA;点击页面左侧的下载客户端。&#xA;下载完成之后登陆，你就可以看到里面有一个 test 文件夹，是刚才在网页官网创建的。然后在右边三个点里面选择同步到本地。&#xA;浏览你的文件夹，找到一个地方存放 test 文件夹，点击确定，坚果云就会自动同步你在本地文件。但是这个时候 test 文件夹是空的，需要将 obsidian 文件全部移动进去就行了。然后在 obsidian 客户端重新打开 test 库。&#xA;在另一台电脑，进行上面同样的操作，将坚果云的同步文件夹映射到本地，就会自动下载云端的文件。之后，不管你在哪台电脑修改 obsidian 笔记，都会同步到拥有坚果云客户端的其他电脑。&#xA;这是 pc 端同步的方案，之后我会继续分享如果将 pc 同步到手机端。</description>
    </item>
    <item>
      <title>关于我选择笔记系统这件小事</title>
      <link>https://zishu.me/blog/121.html/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/121.html/</guid>
      <description>受年龄增长以及生活影响，人接触到的新事物和知识将会越来越多，大脑就显得有些混乱了，我也不敢保证自己的思维会始终保持一个高强度的在线状态。&#xA;因此决定整理个人知识库，将大脑中的片段和思想整理出来。以笔记和文字的形式将他记录下来，但是最近一直在寻求这样的工具，多方对比，也没有一款能真正满足我的需求的工具。&#xA;最好是自建的笔记，因为我今天在语雀写了一篇私密笔记，或许因为内容略带敏感吧，然后就被审查了，说我违规。&#xA;语雀这是我目前最满意的工具，但是现在对他的热情瞬间降低了很多。我怕哪天一下子账号里面的笔记全部被删了，那样我会很绝望的。&#xA;接下来我还会多方对比，最终选择一款平台亦或者是自建的笔记系统。&#xA;博客是写给别人看的，笔记是给自己看的，包括一些计划，列表清单等等，都是隐私的内容。还有就是一些文章的草稿，碎片化的记录，所以不宜放在博客上。&#xA;而且对于功能方面，我也有较高的要求，比如拖拽，表单，下拉框，卡片等等，都是我比较需要的，隐私和安全性更是我比较看重的。&#xA;暂时就这样吧，我会慢慢寻觅。&#xA;2022/05/03 更新&#xA;经过为期一周的尝试和部署过后，我最终决定了使用思源笔记，可以使用 docker 进行私有部署，本地备份，而且还可以选择付费订阅，备份到官方，这是两种可以同时进行的选择，我觉得很好的满足了我的需要。&#xA;主要还是思源的功能以及外表打动了我，页面简洁而美，功能不臃肿，刚好我需要的他都有，一点也没有多余的按键。符合我对笔记和个人知识库的个人，支持双链，不过我暂时用不到。支持 markdown 格式导入导出。&#xA;而我也逐步将我其他的笔记都迁移过来了，不过目前唯一的缺陷好像不支持分享，这也算我某种需求吧，我在寻求其解决方案，不过也不算什么大问题。&#xA;思源很多细节都打动了我，在单个文章复制的时候，提供了直接复制到其他平台的格式，不用再手动调了。&#xA;至于安全性方面，可以设置全局鉴权密码，不支持单篇文章加密。&#xA;2022/05/18 更新&#xA;半个月过去了，慢慢从思源迁移出来，原因很多，一方面是针对文件的安全性和稳定性抱有一丝怀疑，另外就是同步的问题，成本和精力都有些费事。&#xA;因此我选择了一个更不错的软件&amp;mdash;obsidian，强大的社区，海量的插件以及可扩展性都是我选择它的原因。&#xA;对比之下，它更像是笔记界的 vscode，优势很多，轻量，可扩展，插件多。同时使用坚果云进行多端同步，这样不论是在公司电脑还是在自己的电脑上，我都可以做到无缝切换。&#xA;2022/06/18 更新&#xA;使用了一个月的 obsidain，反馈一下感受。整体来说很适合我这种记录文字的人，对 markdown 语法支持特别友好，格式都可以根据自己的想法展示出来，还带有一些插件，扩展我的使用方法。&#xA;在安全性方面，本地化、离线化也是非常棒的，可以根据自己的需要利用同步盘进行同步，或者自建 webdav 服务，稳定性也是很高的。&#xA;在数据迁移方面，完全不用担心，数据本质上还是 markdown 文件，如果哪有你对 obsidian 失望不再使用，或者有了更好的选择，可以直接把文件夹复制过去，都是很方便的。&#xA;但是这也只针对纯文件来说，如果是元数据，带有一些属性类的东西时，obsidain 就不是很好的选择了。正因为它是一个纯文件，所以注定没法保存元数据信息，这方面我和群里的阿均作了深刻的探讨。他比较注重“属性，标签，双链的指向，关系链，数值大小，层级隶属”等概念。&#xA;obsidian 是一堆小文件集合在一起形成的笔记架构，这和一般的数据库不太一样。&#xA;小文件很难做数据管理，反正长期看性能方面会有问题。一致性，也有问题，不重新索引确保不了一致性，重新索引，对于海量小文件，又难以提高性能。&#xA;阿均的担忧我也是能理解的，不过我们对笔记的定位有所不同。他更希望打造一个碎片化，利用双链结构形成自己的知识架构；而我是需要一个类 wiki 的东西，将我所获取到的知识按照分类进行归档，然后根据关键词，标签，标题，正文等内容进行搜索查询。&#xA;这是不同的方向，所以选择了不同的软件也是很正常的。</description>
    </item>
    <item>
      <title>【笔记】使用 php 写接口文件调用数据</title>
      <link>https://zishu.me/blog/103.html/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/103.html/</guid>
      <description>如何使用 php 写一个接口，然后将数据以 json 文件格式调用。&#xA;&amp;lt;?php header(&amp;#39;Content-Type:application/json; charset=utf-8&amp;#39;); header(&amp;#34;Access-Control-Allow-Origin:*&amp;#34;); $servername = &amp;#34;localhost&amp;#34;; $username = &amp;#34;数据库账号&amp;#34;; $password = &amp;#34;数据库密码&amp;#34;; $dbname = &amp;#34;数据库名称&amp;#34;; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检测连接 if ($conn-&amp;gt;connect_error) { die(&amp;#34;连接失败：&amp;#34; . $conn-&amp;gt;connect_error); } $sql = &amp;#34;select slug,title,created,text from typecho_contents&amp;#34;; $result = $conn-&amp;gt;query($sql); if ($result-&amp;gt;num_rows &amp;gt; 0) { // 输出数据 while($row = $result-&amp;gt;fetch_assoc()) { $data[]=$row; } $json = json_encode($data,JSON_UNESCAPED_UNICODE|JSON_PRETTY_PRINT);//把数据转换为 JSON 数据。 exit($json) ; } else { echo &amp;#34;未查询到结果！&amp;#34;; } $conn-&amp;gt;close(); ?&amp;gt; 根据某个条件排序，将 32 行的 sql 语句改为下面的，意为根据 created 进行排序。&#xA;$sql = &amp;#34;select slug,title,created,text from typecho_contents order by created desc&amp;#34;; </description>
    </item>
    <item>
      <title>我的 python 学习笔记</title>
      <link>https://zishu.me/blog/61.html/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/61.html/</guid>
      <description>之所以学习 Python，本意是想写一些脚本之类的程序，用来在浏览器爬一些自己想要的文字，图片等资料，这些程序其实 GitHub 蛮多的，但奈何我对后端的语言一窍不通，直接拿过来给我用我都不会。&#xA;因此就萌生了先学习 Python 基础知识的想法，一直听说廖雪峰的 Python 教程写的不错，这次趁着这个机会要好好研读一番。也没想说用的多牛逼，至少希望能为自己浅薄的技术栈再增加一点光彩，毕竟我也曾梦想成为一个全栈开发。&#xA;下载安装完 Python 环境，就开始学习吧！&#xA;运行我的第一个 python 程序 print(&amp;#39;hello,world&amp;#39;) 数据类型 在 Python 中，能直接处理的数据类型有几种，整数、浮点数、字符串、布尔值、空值、变量。&#xA;这与其他语言其实差别并不大，数据类型基本都是相似的，大概只有变量有自己的特性，所以我单独拿出来记录一下。&#xA;变量 python 是一门动态语言，在赋值时可以不断改变，比如：&#xA;a = 123 print(a) # 终端输出数值 123 a = &amp;#39;abc&amp;#39; print(a) # 终端输出字符串 abc 这是允许的，而在 Java 中则不行，它是一门静态语言，如果多次赋值会报错。相对来说，动态语言更灵活，当然，各有利弊罢了。&#xA;并且在赋值上面有一个逻辑顺序，比如定义一个 a = &#39;a&#39; 的变量。在 Python 中其实走了两步，先创造了一个字符串 a ，然后将这个字符串赋值给变量 a。&#xA;其实这在数学上是有些反逻辑的，x = x + 2 这个计算是行不通的在数学上，但是在计算机中，先计算 x + 2 ，然后将其赋值给左侧的 x ，这是计算机的逻辑。&#xA;x = 1 x = x + 2 print(x) # 3 其实很多计算机语言都是如此，比如我们所熟知的 js 等等。&#xA;如果有多个变量相互赋值的话，都是一行一行执行&#xA;a = 1 b = a a = 2 print(a) print(b) 最后输出的结果分别是 2, 1&#xA;Python 支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。 对变量赋值 x = y 是把变量 x 指向真正的对象，该对象是变量 y 所指向的。随后对变量 y 的赋值不影响变量 x 的指向。 注意：Python 的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如 Java 对 32 位整数的范围限制在 -2147483648-2147483647。 Python 的浮点数也没有大小限制，但是超出一定范围就直接表示为 inf（无限大）。&amp;mdash;《廖雪峰的官方网站》&#xA;字符串和编码 Python 提供了两个处理编码的属性，ord 和 chr&#xA;ord(&amp;#39;舒&amp;#39;) # 33298 # 将字符串转换为整数表示 chr(33298) # &amp;#39;舒&amp;#39; # 将整数表示的内容转换为字符串 list list 类似于 js 中的 Array，是多个数据的列表，写法如下&#xA;&amp;gt;&amp;gt;&amp;gt; classmates = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] &amp;gt;&amp;gt;&amp;gt; classmates [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] 这时候我们就可以说变量 classmates 是一个 list。&#xA;有一个 len() 可以输出 list 元素的个数&#xA;&amp;gt;&amp;gt;&amp;gt; len(classmates) &amp;gt;&amp;gt;&amp;gt; 3 同时 list 也有索引，从 0 开始，最后一个索引是 len(classmates)-1，同时如果想直接输出最后一个元素，可以使用 classmates[-1].&#xA;&amp;gt;&amp;gt;&amp;gt; classmates[-1] &amp;gt;&amp;gt;&amp;gt; &amp;#39;c&amp;#39; 既然都可以用 -1 表示最后一个元素，能不能用 -2 表示倒数第二个呢？答案是可以的。&#xA;&amp;gt;&amp;gt;&amp;gt; classmates[-2] &amp;gt;&amp;gt;&amp;gt; &amp;#39;b&amp;#39; 另外需要注意的是，在使用索引时不可超出范围，否则会报出下面的错误。&#xA;&amp;gt;&amp;gt;&amp;gt; classmates[4] Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; IndexError: list index out of range list 是一个可变的有序列表，可以往里面添加或者删除元素。&#xA;append 在末尾添加元素 &amp;gt;&amp;gt;&amp;gt; classmates.append(&amp;#39;d&amp;#39;) &amp;gt;&amp;gt;&amp;gt; classmates [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;] insert 在指定位置添加元素 其中 1 是索引，表示在索引为 1 的地方插入元素，后面的元素自然往后顺延。&#xA;&amp;gt;&amp;gt;&amp;gt; classmates.insert(1, &amp;#39;d&amp;#39;) &amp;gt;&amp;gt;&amp;gt; classmates [&amp;#39;a&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] pop 删除末尾的元素 &amp;gt;&amp;gt;&amp;gt; classmates.pop() &amp;#39;c&amp;#39; # 输出的时候被删除的元素 &amp;gt;&amp;gt;&amp;gt; classmates [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;] pop(i) 删除指定位置的元素 &amp;gt;&amp;gt;&amp;gt; classmates.pop(1) &amp;#39;b&amp;#39; # 输出被删除的元素 &amp;gt;&amp;gt;&amp;gt; classmates [&amp;#39;a&amp;#39;, &amp;#39;c&amp;#39;] &amp;gt;&amp;gt;&amp;gt; </description>
    </item>
    <item>
      <title>React 学习笔记（三）</title>
      <link>https://zishu.me/blog/39.html/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/39.html/</guid>
      <description>来源于：https://react.docschina.org/docs/forms.html&#xA;一、表单 在 React 中，html 表单元素的工作方式和其他的 DOM 元素不太一样，因为表单内部通常会保持一些内部的 state，比如下面这个纯 html 表单只接受一个名称：&#xA;&amp;lt;form&amp;gt; &amp;lt;label&amp;gt; 名字： &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;name&amp;#34; /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;提交&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; 这个表单具有默认的 html 表单行为，即在用户提交表单之后自动刷新页面。如果你在 React 中执行相同的代码，它仍然有效。&#xA;但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交，同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。&#xA;受控组件 在 html 中，表单元素比如&amp;lt;input&amp;gt;，&amp;lt;textarea&amp;gt;，&amp;lt;select&amp;gt;，这些表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。&#xA;我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。&#xA;例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：&#xA;class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: &amp;#39;&amp;#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&amp;#39;提交的名字：&amp;#39; + this.state.value); event.preventDefault(); } render() { return ( &amp;lt;form onSubmit={this.handleSubmit}&amp;gt; &amp;lt;label&amp;gt; 名字: &amp;lt;input type=&amp;#34;text&amp;#34; value={this.state.value} onChange={this.handleChange} /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;提交&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; ); } } 由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。&#xA;对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。&#xA;textarea 标签 在 html 中，&amp;lt;textarea&amp;gt; 元素通过其子元素定义其文本：&#xA;&amp;lt;textarea&amp;gt; 测试！ &amp;lt;/textarea&amp;gt; 而在 React 中，&amp;lt;textarea&amp;gt; 使用 value 属性代替。这样，可以使得使用 &amp;lt;textarea&amp;gt; 的表单和使用单行 input 的表单非常类似：&#xA;class EssayForm extends React.Component { constructor(props) { super(props); this.state = { value: &amp;#39;请撰写一篇关于你喜欢的 DOM 元素的文章。&amp;#39; }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&amp;#39;提交的文章：&amp;#39; + this.state.value); event.preventDefault(); } render() { return ( &amp;lt;form onSubmit={this.handleSubmit}&amp;gt; &amp;lt;label&amp;gt; 文章: &amp;lt;textarea value={this.state.value} onChange={this.handleChange} /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;提交&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; ); } } 请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。&#xA;select 标签 在 HTML 中，&amp;lt;select&amp;gt; 创建下拉列表标签。例如，如下 html 创建了水果相关的下拉列表：&#xA;&amp;lt;select&amp;gt; &amp;lt;option value=&amp;#34;grapefruit&amp;#34;&amp;gt;葡萄柚&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;lime&amp;#34;&amp;gt;酸橙&amp;lt;/option&amp;gt; &amp;lt;option selected value=&amp;#34;coconut&amp;#34;&amp;gt;椰子&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;mango&amp;#34;&amp;gt;芒果&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：&#xA;class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: &amp;#39;coconut&amp;#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&amp;#39;你喜欢的风味是：&amp;#39; + this.state.value); event.preventDefault(); } render() { return ( &amp;lt;form onSubmit={this.handleSubmit}&amp;gt; &amp;lt;label&amp;gt; 选择你喜欢的风味： &amp;lt;select value={this.state.value} onChange={this.handleChange}&amp;gt; &amp;lt;option value=&amp;#34;grapefruit&amp;#34;&amp;gt;葡萄柚&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;lime&amp;#34;&amp;gt;酸橙&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;coconut&amp;#34;&amp;gt;椰子&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;mango&amp;#34;&amp;gt;芒果&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;提交&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; ); } } 总的来说，这使得 &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;, &amp;lt;textarea&amp;gt; 和 &amp;lt;select&amp;gt; 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。&#xA;注意：你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：&#xA;&amp;lt;select multiple={true} value={[&amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;]}&amp;gt; 文件 input 标签 在 HTML 中，&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt; 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。&#xA;&amp;lt;input type=&amp;#34;file&amp;#34; /&amp;gt; 因为它的 value 只读，所以它是 React 中的一个非受控组件。&#xA;处理多个输入 当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。&#xA;class Reservation extends React.Component { constructor(props) { super(props); this.state = { isGoing: true, numberOfGuests: 2 }; this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(event) { const target = event.target; const value = target.name === &amp;#39;isGoing&amp;#39; ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } render() { return ( &amp;lt;form&amp;gt; &amp;lt;label&amp;gt; 参与: &amp;lt;input name=&amp;#34;isGoing&amp;#34; type=&amp;#34;checkbox&amp;#34; checked={this.state.isGoing} onChange={this.handleInputChange} /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;br /&amp;gt; &amp;lt;label&amp;gt; 来宾人数： &amp;lt;input name=&amp;#34;numberOfGuests&amp;#34; type=&amp;#34;number&amp;#34; value={this.state.numberOfGuests} onChange={this.handleInputChange} /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;/form&amp;gt; ); } } 这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值：&#xA;例如：&#xA;this.setState({ [name]: value }); 等同于 es5：&#xA;var partialState = {}; partialState[name] = value; this.setState(partialState); 另外，由于 setState() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。&#xA;受控输入空值 在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。&#xA;下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）&#xA;ReactDOM.render(&amp;lt;input value=&amp;#34;hi&amp;#34; /&amp;gt;, mountNode); setTimeout(function() { ReactDOM.render(&amp;lt;input value={null} /&amp;gt;, mountNode); }, 1000); 受控组件的替代品 有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件，这是实现输入表单的另一种方式。&#xA;成熟的解决方案 如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 Formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。</description>
    </item>
    <item>
      <title>vue 学习笔记 (3)－－computed, watch，calss, style</title>
      <link>https://zishu.me/blog/29.html/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/29.html/</guid>
      <description>一、计算属性 computed 1.例子 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{revermessage}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, computed: { revermessage: function() { return this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) } } }) &amp;lt;/script&amp;gt; 声明一个计算属性severmessage，在computed中被指向对message进行一些方法操作后的返回值&#xA;此时vm.severmessage依赖于vm.message的变化，对message改变数据，会引起severmessage的更新&#xA;2.计算属性缓存和方法 还可以通过在表达式中调用方法来达到想要的效果&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{revermessage()}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, methods: { revermessage: function() { return this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) } } }) &amp;lt;/script&amp;gt; 经过测试，两者的结果是一样的&#xA;我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的&#xA;区别是：计算属性是基于他们的响应式依赖进行缓存的，只有当响应式依赖，也就是message发生改变时才会重新求值，就意味着，只要message还没改变，多次访问revermessage计算属性只会返回之前计算结果的缓存，而不是直接执行计算属性的函数&#xA;而方法，在每次触发重新渲染时，调用方法都会执行一次函数，这就多了一份开销&#xA;我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代&#xA;3.计算属性和侦听属性 vue 还有一种方式来观测 vue 实例上的数据变动：侦听属性－－watch&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{fullname}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { firstname: &amp;#39;a&amp;#39;, lastname: &amp;#39;b&amp;#39;, fullname: &amp;#39;ab&amp;#39; }, watch: { firstname: function(val) { this.fullName = val + &amp;#39; &amp;#39; + this.lastName }, lastname: function(val) { this.fullName = this.firstName + &amp;#39; &amp;#39; + val } } }) &amp;lt;/script&amp;gt; 使用过程是极其繁琐且重复的，再来用计算属性试一下&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{fullname}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { firstname: &amp;#39;a&amp;#39;, lastname: &amp;#39;b&amp;#39; }, computed: { fullname: function() { return this.firstname + this.lastname } } }) &amp;lt;/script&amp;gt; 很简单快速的就得到了我们想要的函数表达式&#xA;4.计算属性的 setter computed: { fullName: { // getter get: function () { return this.firstName + &amp;#39; &amp;#39; + this.lastName }, // setter set: function (newValue) { var names = newValue.split(&amp;#39; &amp;#39;) this.firstName = names[0] this.lastName = names[names.length - 1] } } } 现在在控制台输入vm.fullName = &#39;John Doe&#39;，页面会响应，并且setter会被调用，vm.firstname和vm.lastname也会相应地被更新&#xA;二、绑定 class 和 style 1.对象语法 可以给v-bind:class传入一个对象，动态的切换class&#xA;&amp;lt;div v-bind:class=&amp;#34;{active: ok}&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 可以通过控制ok的布尔值来动态的控制 class&#xA;还可以创建多个字段，并且不影响普通的className的存在&#xA;html:&#xA;&amp;lt;div class=&amp;#34;static&amp;#34; v-bind:class=&amp;#34;{ active: isActive, &amp;#39;text-danger&amp;#39;: hasError }&amp;#34; &amp;gt;&amp;lt;/div&amp;gt; data:&#xA;data{ isActive: true, hasError: false } 结果为：&#xA;&amp;lt;div class=&amp;#34;static active&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 当isActive或者hasError变化时，class 列表将相应地更新。例如，如果hasError的值为true，class 列表将变为&amp;quot;static active text-danger&amp;quot;。&#xA;绑定的数据对象也不必直接写在内联模板里&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-bind:class=&amp;#34;classobject&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { classobject: { active: true, &amp;#39;text-danger&amp;#39;: true } }, }) &amp;lt;/script&amp;gt; &amp;lt;!-- &amp;lt;div class=&amp;#34;active text-danger&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; --&amp;gt; 如果className有特殊符号，必须加上引号&#39;&#39;，或者&amp;quot;&amp;quot;&#xA;2.数组语法 我们可以把一个数组传给v-bind:class，以应用一个 class 列表&#xA;&amp;lt;div v-bind:class=&amp;#34;[activeClass, errorClass]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; data: { activeClass: &amp;#39;active&amp;#39;, errorClass: &amp;#39;text-danger&amp;#39; } 渲染为：&#xA;&amp;lt;div class=&amp;#34;active text-danger&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 3.用在组件上 当在一个自定义组件上使用classproperty 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。&#xA;Vue.component(&amp;#39;my-component&amp;#39;, { template: &amp;#39;&amp;lt;p class=&amp;#34;foo bar&amp;#34;&amp;gt;Hi&amp;lt;/p&amp;gt;&amp;#39; }) 然后在使用的使用的时候添加了一些class：&#xA;&amp;lt;my-component class=&amp;#34;baz boo&amp;#34;&amp;gt;&amp;lt;/my-component&amp;gt; html 将会被渲染成：&#xA;&amp;lt;p class=&amp;#34;foo bar baz boo&amp;#34;&amp;gt;Hi&amp;lt;/p&amp;gt; 对于带数据绑定的class也同样适用&#xA;&amp;lt;my-component v-bind:class=&amp;#34;{ active: isActive }&amp;#34;&amp;gt;&amp;lt;/my-component&amp;gt; 当isActive为 truthy 时，HTML 将被渲染成为：&#xA;&amp;lt;p class=&amp;#34;foo bar active&amp;#34;&amp;gt;Hi&amp;lt;/p&amp;gt; 4.绑定内联样式 style v-bind:style的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式或带引号的短横线来命名&#xA;&amp;lt;div v-bind:style=&amp;#34;{ color: activeColor, fontSize: fontSize + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; js:&#xA;data: { activeColor: &amp;#39;red&amp;#39;, fontSize: 30 } 或者直接绑定到一个对象，会让模板更加清晰&#xA;&amp;lt;div v-bind:style=&amp;#34;styleObject&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; js:&#xA;data: { styleObject: { color: &amp;#39;red&amp;#39;, fontSize: &amp;#39;13px&amp;#39; } } 也可以将多个对象应用到一个元素上&#xA;&amp;lt;div v-bind:style=&amp;#34;[baseStyles, overridingStyles]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 自动添加前缀&#xA;当v-bind:style需要使用浏览器前缀的时候，如：-webkit-等，vue 会自动侦测并帮生成相应的前缀</description>
    </item>
    <item>
      <title>vue 学习笔记 (2)－－vue 实例和模板语法</title>
      <link>https://zishu.me/blog/28.html/</link>
      <pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/28.html/</guid>
      <description>一、vue 实例 1.创建 vue 实例 一个 vue 实例应该通过new Vue来创建根实例，所有的 vue 组件其实都是 vue 实例&#xA;var vm = new Vue({ ... }) 当一个实例被创建时，data对象中的 property 都被加入到 vue 的响应式系统中，当值发生改变时，试图也会改变&#xA;var data = {a: 1} var vm = new Vue({ data: data }) 此时在控制台输入vm.a == data.a会返回 true，变量data已经被赋给vue实例中的data对象了&#xA;同时，对两个对象的数据进行操作改变也会影响到另一个&#xA;vm.a = 2 // data.a = 2 data.a = 3 // vm.a = 3 当数据改变时，视图也会重新渲染，如果在 vue 实例被创建后，又添加了一个新的 property，则不会被加入到响应式系统中&#xA;如果一开始就知道后面会添加一个 property，但是一开始不存在或为空，需要设置一些初始值&#xA;data: { newTodoText: &amp;#39;&amp;#39;, visitCount: 0, hideCompletedTods: fasle, todos: [], error: null } 使用 Object.freeze() 方法的时候，无法修改数据引起视图变化&#xA;Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var data = {message: &amp;#39;hello,wolrd&amp;#39;} Object.freeze(data) var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: data }) &amp;lt;/script&amp;gt; 在控制台改变vm.message的值会直接报错，因为 data 对象已经被冻结了，不可改变&#xA;vm.$data&#xA;代表 vue 实例观察的数据对象&#xA;console.log(vm.$data) // 返回数据对象的数组形式 var data = { a: 1 } var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: data }) vm.$data === data // true vm.$el === document.getElementById(&amp;#39;app&amp;#39;) // true 2.生命周期函数 每个实例在被创建的时候，都要经历一些初始化过程，比如：设置数据监听，编译模板，将实例挂载到 dom，更新 dom 等&#xA;在这个过程中会运行一些叫做生命周期的钩子函数，可以在不同阶段添加自己需要的代码&#xA;比如created钩子可以用来表示一个实例被创建之后执行的代码&#xA;new Vue({ data: { a: 1 }, created: function () { console.log(&amp;#39;a is: &amp;#39; + this.a) } }) // &amp;#34;a is: 1&amp;#34; this用来指向 vm 实例&#xA;但是不要在 property 或者回调上使用箭头函数，created: () =&amp;gt; console.log(this.a)，因为箭头函数没有this的概念，他会把this当作变量一直向上级作用域查找，经常产生Uncaught TypeError: Cannot read property of undefined或Uncaught TypeError: this.myMethod is not a function之类的报错&#xA;二、模板语法 1.插值 最简单的就是&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,world&amp;#39; } }) &amp;lt;/script&amp;gt; &amp;lt;/script&amp;gt; 。。。&#xA;下面这段代码给input绑定了一个disabled属性，但是通过ok的真伪来控制属性是否渲染&#xA;当ok为fasle,null,undefined值时，属性都不会被渲染，有点类似于v-if，但是这种写法只是针对属性&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; v-bind:disabled=&amp;#34;ok&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39;, ok: false } }) &amp;lt;/script&amp;gt; 在模板语法中还可以使用 javascript 表达式&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{number + 1}}&amp;lt;/div&amp;gt; &amp;lt;div v-bind:id=&amp;#34;&amp;#39;list-&amp;#39; + id&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;)}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { number: 2, id: &amp;#39;li&amp;#39;, message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; 每个模板只能包含一个 javascript 表达式，如果有多个，则不会生效&#xA;&amp;lt;!-- 这是语句，不是表达式 --&amp;gt; {{ var a = 1 }} &amp;lt;!-- 流控制也不会生效，请使用三元表达式 --&amp;gt; {{ if (ok) { return message } }} 2.指令 参数&#xA;一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind指令可以用于响应式地更新 HTML attribute：&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;a v-bind:href=&amp;#34;url&amp;#34;&amp;gt;百度&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { url: &amp;#39;https://www.baidu.com&amp;#39; } }) &amp;lt;/script&amp;gt; 在这里href是参数，告知v-bind指令将该元素的hrefattribute 与表达式url的值绑定&#xA;另一个例子是v-on指令，它用于监听 dom 事件&#xA;&amp;lt;a v-on:click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; 动态参数&#xA;从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数&#xA;&amp;lt;!--注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。--&amp;gt; &amp;lt;a v-bind:[attributeName]=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; 这里的attributeName会被作为一个 javascript 表达式进行动态求值，最终结果被作为参数来使用&#xA;比如：vue 实例中有一个attributeName属性其值为href，则这个绑定将等价于v-bind:href&#xA;&amp;lt;a v-bind:href=&amp;#34;url&amp;gt;...&amp;lt;/a&amp;gt; 也可以使用动态的事件名绑定监听函数&#xA;&amp;lt;a v-on:[eventName]=&amp;#34;doSomething&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; 如果eventName值为click，则该绑定等价于v-on:click=&amp;quot;doSomething&amp;quot;，一个鼠标点击事件&#xA;对动态参数的值的约束&#xA;动态参数预期会求出一个字符串，异常情况下值为null，这个特殊的null值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。&#xA;对动态参数表达式的约束&#xA;动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的，例如：&#xA;&amp;lt;!-- 这会触发一个编译警告 --&amp;gt; &amp;lt;a v-bind:[&amp;#39;foo&amp;#39; + bar]=&amp;#34;value&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; 因此，尽量不要使用空格和引号的表达式，或者采用计算属性来替代这种复杂表达式&#xA;在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写&#xA;修饰符&#xA;修饰符是以.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，例如，.prevent修饰符告诉v-on指令对于触发的事件调用event.preentDefault()&#xA;&amp;lt;form v-on:submit.prevent=&amp;#34;onSubmit&amp;#34;&amp;gt;...&amp;lt;/form&amp;gt; 3.缩写 v-前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v-前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v-前缀也变得没那么重要了。因此，Vue 为v-bind和v-on这两个最常用的指令，提供了特定简写&#xA;v-bind&#xA;&amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-bind:href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;a :href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt; &amp;lt;a :[key]=&amp;#34;url&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; v-on&#xA;&amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-on:click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;a @click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt; &amp;lt;a @[event]=&amp;#34;doSomething&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; 它们看起来可能与普通的 HTML 略有不同，但:与@对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</description>
    </item>
    <item>
      <title>vue 学习笔记 (1)－－什么是 vue?</title>
      <link>https://zishu.me/blog/27.html/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/27.html/</guid>
      <description>一、什么是 vue? 练习时使用，最新版本&#xA;&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 生产时使用，明确版本号的版本，避免造成不可预见的问题&#xA;&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue@2.6.12&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; hello world&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{message}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,world&amp;#39; } }) &amp;lt;/script&amp;gt; 1.v-指令 v-bind－－绑定属性 &amp;lt;div id=&amp;#34;app-2&amp;#34;&amp;gt; &amp;lt;span v-bind:title=&amp;#34;message&amp;#34;&amp;gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;页面加载于 &amp;#39; + new Date().toLocaleString() } }) &amp;lt;/script&amp;gt; v-bind是 vue 特有的提供的属性，他会在 dom 上应用一个响应式的操作&#xA;打开 console，输入app.message = &amp;quot;hello&amp;quot;，页面会改变内容只显示hello&#xA;又或者输入app.message = false，内容会直接不显示&#xA;vue 官网例子：&#xA;&amp;lt;!-- 绑定一个 attribute --&amp;gt; &amp;lt;img v-bind:src=&amp;#34;imageSrc&amp;#34;&amp;gt; &amp;lt;!-- 动态 attribute 名 (2.6.0+) --&amp;gt; &amp;lt;button v-bind:[key]=&amp;#34;value&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;img :src=&amp;#34;imageSrc&amp;#34;&amp;gt; &amp;lt;!-- 动态 attribute 名缩写 (2.6.0+) --&amp;gt; &amp;lt;button :[key]=&amp;#34;value&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;!-- 内联字符串拼接 --&amp;gt; &amp;lt;img :src=&amp;#34;&amp;#39;/path/to/images/&amp;#39; + fileName&amp;#34;&amp;gt; &amp;lt;!-- class 绑定 --&amp;gt; &amp;lt;div :class=&amp;#34;{ red: isRed }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :class=&amp;#34;[classA, classB]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :class=&amp;#34;[classA, { classB: isB, classC: isC }]&amp;#34;&amp;gt; &amp;lt;!-- style 绑定 --&amp;gt; &amp;lt;div :style=&amp;#34;{ fontSize: size + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :style=&amp;#34;[styleObjectA, styleObjectB]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- 绑定一个全是 attribute 的对象 --&amp;gt; &amp;lt;div v-bind=&amp;#34;{ id: someProp, &amp;#39;other-attr&amp;#39;: otherProp }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- 通过 prop 修饰符绑定 DOM attribute --&amp;gt; &amp;lt;div v-bind:text-content.prop=&amp;#34;text&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&amp;gt; &amp;lt;my-component :prop=&amp;#34;someThing&amp;#34;&amp;gt;&amp;lt;/my-component&amp;gt; &amp;lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&amp;gt; &amp;lt;child-component v-bind=&amp;#34;$props&amp;#34;&amp;gt;&amp;lt;/child-component&amp;gt; &amp;lt;!-- XLink --&amp;gt; &amp;lt;svg&amp;gt;&amp;lt;a :xlink:special=&amp;#34;foo&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/svg&amp;gt; v-if－－控制元素的显示隐藏 刚才写了，通过app.message = false，可以让message代表的内容处于隐藏状态，但是控制的只能是通过v-for引入的内容，无法直接让元素隐藏&#xA;其实，vue 中还有一个专门控制元素显示隐藏的指令－－v-if&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;span v-if=&amp;#34;show&amp;#34;&amp;gt; {{message}} &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,world&amp;#39;, show: true } }) &amp;lt;/script&amp;gt; 给元素绑定一个指令v-if = &amp;quot;show&amp;quot;，然后在 data 中控制show的布尔值，true 显示，false 隐藏&#xA;同时还有这个功能的指令v-show，根据表达式之真假值，切换元素的display CSS property，也是通过绑定的布尔值来显示隐藏&#xA;但是v-if和v-show有些区别&#xA;(1) v-if 是控制元素是否渲染最终控制元素的显示隐藏，适用于切换频率低的情况 (2) v-show 不管显示隐藏都渲染，然后通过布尔值绑定display: none属性，适用于切换频率高的情况&#xA;注意：v-show不支持&amp;lt;tempalte&amp;gt;元素，也不支持v-else&#xA;搭配用法&#xA;v-else和v-else-if&#xA;可以通过使用v-else达到v-if的效果，必须和v-if搭配使用，比如：&#xA;&amp;lt;div v-if=&amp;#34;1&amp;gt;2&amp;#34;&amp;gt; hello &amp;lt;/div&amp;gt; &amp;lt;div v-else&amp;gt; hi &amp;lt;/div&amp;gt; 如果v-if不成立，执行v-else，也就是显示 v-else 里面的内容&#xA;是不是有点 javascript 里面if函数的感觉了&#xA;v-else-if用法大致一样，必须和v-if和v-else搭配使用&#xA;v-for－－遍历数组并显示到页面上 v-for算是 vue 的核心指令之一了把，主要是渲染一个项目列表的&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-for=&amp;#34;item in list&amp;#34;&amp;gt;{{item.message}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { list: [ {message: &amp;#39;html&amp;#39;}, {message: &amp;#39;css&amp;#39;} ] } }) &amp;lt;/script&amp;gt; 可以直接把列表数据循环输出&#xA;并且在控制台中通过push()还能添加新的列表项&#xA;app.list.push({message: &amp;#34;js&amp;#34;}) vue 对数据操作，就是这么神奇&#xA;不推荐v-for和v-if同时使用，因为v-for拥有更高的优先级&#xA;v-on－－绑定事件监听器 即绑定事件，通过v-on给 div 绑定了一个点击事件，注意，在reverseMessage方法中，我们更新了应用的状态，但是吗诶呀触碰到 dom，直接通过 vue 来进行处理，编写代码时只需要关注逻辑层即可&#xA;v-on:click=&amp;quot;messagenone&amp;quot;，然后在methods里面写上事件方法&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-on:click=&amp;#34;messagenone&amp;#34; id=&amp;#34;demo&amp;#34;&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, methods: { messagenone: function() { var demo = document.getElementById(&amp;#39;demo&amp;#39;); demo.innerHTML = &amp;#39;&amp;#39; } } }) &amp;lt;/script&amp;gt; v-model－－数据的双向绑定 vue 还提供了v-model指令，它能轻松实现表单输入和应用状态之间的双向绑定&#xA;可使用场景：标签 input, select, textarea 和 components&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;message&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; v-text 更新元素的内容 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-text=&amp;#34;message&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; 上面的 div 和下面的 div 内容跟随一致变化&#xA;v-html－－更新元素的 innerHTML 不建议使用，在网站上动态渲染 html 是非常危险的，容易导致XXS 攻击，不能用在用户提交的内容上，如果必须使用 v-html，可以考虑通过使用组件来代替&#xA;v-pre 跳过绑定的元素和他的子元素的编译，直接显示原始内容&#xA;跳过没有指令的节点不进行编译，直接显示内容，会加快页面的响应&#xA;v-cloak 在编译没有编译完成之前，模板处于的状态&#xA;&amp;lt;style&amp;gt;v-cloak] { display: none; }&amp;lt;/style&amp;gt; &amp;lt;div v-cloak&amp;gt; {{message}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; 上述代码表示的含义是，如果网络不好，{{message}}模板代表的hello,world还没有编译成功，此时{{message}}处于隐藏状态，当编译完成，页面直接显示hello,world&#xA;v-once－－一次性渲染 绑定该指令的元素及其子元素只会进行一次渲染，之后页面的第二次渲染会将其视为静态资源并跳过，可以用来优化性能&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;span v-once&amp;gt;{{message}}&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39;, } }) &amp;lt;/script&amp;gt; 使用场景：表单提交。可防止用户在请求未及时响应时，多次提交~&#xA;2.组件化构建应用 组件化也是 vue 的核心机制之一，它允许我们使用小型，可复用的组件来构建大型应用&#xA;在 vue 里，一个组件本质上是一个拥有预定义选项的一个 vue 实例。在 vue 中注册组件很简单&#xA;// 定义名为 todo-item 的新组件 Vue.component(&amp;#39;todo-item&amp;#39;, { template: &amp;#39;&amp;lt;li&amp;gt;这是个待办项&amp;lt;/li&amp;gt;&amp;#39; }) var app = new Vue(...) 现在可以用它构建另一个组件模板&#xA;&amp;lt;ol&amp;gt; &amp;lt;!-- 创建一个 todo-item 组件的实例 --&amp;gt; &amp;lt;todo-item&amp;gt;&amp;lt;/todo-item&amp;gt; &amp;lt;/ol&amp;gt; 但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个props&#xA;Vue.component(&amp;#39;todo-item&amp;#39;, { // todo-item 组件现在接受一个 // &amp;#34;props&amp;#34;，类似于一个自定义 attribute。 // 这个 props 名为 todo。 props: [&amp;#39;todo&amp;#39;], template: &amp;#39;&amp;lt;li&amp;gt;{{ todo.text }}&amp;lt;/li&amp;gt;&amp;#39; }) 现在，我们可以使用v-bind指令将待办项传到循环输出的每个组件中&#xA;现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的，我们也需要为每个组件提供一个key&#xA;&amp;lt;div id=&amp;#34;app-7&amp;#34;&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;todo-item v-for=&amp;#34;item in groceryList&amp;#34; v-bind:todo=&amp;#34;item&amp;#34; v-bind:key=&amp;#34;item.id&amp;#34; &amp;gt;&amp;lt;/todo-item&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; Vue.component(&amp;#39;todo-item&amp;#39;, { props: [&amp;#39;todo&amp;#39;], template: &amp;#39;&amp;lt;li&amp;gt;{{ todo.text }}&amp;lt;/li&amp;gt;&amp;#39; }) var app7 = new Vue({ el: &amp;#39;#app-7&amp;#39;, data: { groceryList: [ { id: 0, text: &amp;#39;蔬菜&amp;#39; }, { id: 1, text: &amp;#39;奶酪&amp;#39; }, { id: 2, text: &amp;#39;随便其它什么人吃的东西&amp;#39; } ] } }) 尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过prop接口与父单元进行了良好的解耦。我们现在可以进一步改进 组件，提供更为复杂的模板和逻辑，而不会影响到父单元&#xA;在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理&#xA;&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;app-nav&amp;gt;&amp;lt;/app-nav&amp;gt; &amp;lt;app-view&amp;gt; &amp;lt;app-sidebar&amp;gt;&amp;lt;/app-sidebar&amp;gt; &amp;lt;app-content&amp;gt;&amp;lt;/app-content&amp;gt; &amp;lt;/app-view&amp;gt; &amp;lt;/div&amp;gt; </description>
    </item>
    <item>
      <title>事件监听函数，以及事件的捕获和冒泡机制</title>
      <link>https://zishu.me/blog/21.html/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/21.html/</guid>
      <description>事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件，事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流&#xA;函数事件 事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件&#xA;事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流&#xA;true 是捕获，false 是冒泡，默认为冒泡事件&#xA;1.addEventListener()－－添加事件监听函数 给元素添加一个事件，假如有多个事件，不会覆盖，会依次执行&#xA;&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;dom&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; document.getElementById(&amp;#39;demo&amp;#39;).addEventListener(&amp;#34;click&amp;#34;, myfun) document.getElementById(&amp;#39;demo&amp;#39;).addEventListener(&amp;#34;click&amp;#34;, myfun1) function myfun() { console.log(&amp;#39;事件监听函数&amp;#39;) } function myfun1() { console.log(&amp;#39;addEventListener&amp;#39;) } &amp;lt;/script&amp;gt; 注意： 1.这里有一个细节，addEventListener() 里面有两个参数，第一个表示触发的条件，第二个表示触发的事件 正常情况下，第二个参数直接写函数名并且不加参数()，如果加了参数()则表示立即执行，不需要触发第一个参数要求的条件&#xA;2.在这里绑定事件的时候，事件名不能和定义的变量名一样，否则无效&#xA;2.removeEventListener()－－移除事件监听函数 下面这个 demo，当鼠标在 div 中移动的时候，出现随机数，点击按钮后，移除事件监听函数&#xA;&amp;lt;!-- css --&amp;gt; &amp;lt;style&amp;gt; #demo { width: 100px; height: 100px; border: 1px solid #000; } &amp;lt;/style&amp;gt; &amp;lt;!-- html --&amp;gt; &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;点击移除&amp;#34; onclick=&amp;#34;remove()&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;show&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- js --&amp;gt; &amp;lt;script&amp;gt; document.getElementById(&amp;#39;demo&amp;#39;).addEventListener(&amp;#34;mousemove&amp;#34;, myfun) function myfun() { document.getElementById(&amp;#39;show&amp;#39;).innerHTML = Math.random() } function remove() { document.getElementById(&amp;#39;demo&amp;#39;).removeEventListener(&amp;#34;mousemove&amp;#34;, myfun) } &amp;lt;/script&amp;gt; 3.利用事件的捕获和冒泡做点事情 addEventListener() 和 removeEventListener() 其实拥有三个参数，刚才说过了，第一个表示触发条件，第二个表示触发事件，第三个参数正常情况下可以省略，但是要知道它代表的意思&#xA;用布尔值来表示，true 或者 false，默认是 false&#xA;true 表示在捕获阶段调用事件处理程序 false 表示在冒泡阶段调用事件处理程序 根据图片可以看出，捕获阶段要先于冒泡阶段，因此，true 事件要先于 flase 事件触发，多个 true 事件按顺序触发，多个 false 事件，写在后面的先触发&#xA;结论：写在前面的 true 事件 &amp;gt; 写在后面的 true 事件 &amp;gt; 写在后面的 false 事件 &amp;gt; 写在前面的 false 事件&#xA;因此，利用这个参数，可以控制同一个元素的不同事件触发的顺序&#xA;&amp;lt;div id=&amp;#34;out&amp;#34;&amp;gt; &amp;lt;p&amp;gt;最外面&amp;lt;/p&amp;gt; &amp;lt;div id=&amp;#34;middle&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;inner&amp;#34;&amp;gt;最里面&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 第一种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：inner-------middle------out out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},false); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},false); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第二种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out------middle-------inner out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},true); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},true); &amp;lt;/script&amp;gt; &amp;lt;!-- 第三种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out------inner-------middle out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},false); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第四种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out-------middle------inner out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},true); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第五种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：middle-------inner------out out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},false); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},true); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第六种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out-------inner------middle out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},false); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},true); &amp;lt;/script&amp;gt; 4.事件处理程序 HTML 事件处理程序 &amp;lt;button onclick=&amp;#34;test()&amp;#34;&amp;gt;测试&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function test() { alert(&amp;#34;HTML 事件处理程序&amp;#34;); } &amp;lt;/script&amp;gt; 1.优点：事件处理程序中的代码，能够访问全局作用域中的任何变量 2.缺点：时差问题、扩展的作用域链在不同浏览器中会导致不同结果、html 代码与 js 代码高度耦合&#xA;DOM0 级事件处理程序 &amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;测试&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; var btn = document.getElementById(&amp;#34;btn&amp;#34;); btn.onclick = function test() { alert(&amp;#34;DOM0 级事件处理程序&amp;#34;); } &amp;lt;/script&amp;gt; 1.优点：代码简单，浏览器兼容性好，解决了 html 代码和 js 代码的高度耦合问题 2.缺点：一个元素只能绑定一个事件处理函数，只会在事件冒泡中运行&#xA;DOM2 级事件处理程序 该级别的事件处理程序，运用的就是事件捕获和冒泡机制&#xA;&amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;测试&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; var btn = document.getElementById(&amp;#34;btn&amp;#34;); // 事件监听 btn.addEventListener(&amp;#34;click&amp;#34;, function() { alert(&amp;#34;DOM2 级事件处理程序，我在捕获阶段执行&amp;#34;); }, true); btn.addEventListener(&amp;#34;click&amp;#34;, function() { alert(&amp;#34;DOM2 级事件处理程序，我在冒泡阶段执行&amp;#34;); }, false); // 移除事件监听 var fun = function() { alert(&amp;#34;我要被移除了&amp;#34;); } btn.addEventListener(&amp;#34;click&amp;#34;, fun, false); btn.removeEventListener(&amp;#34;click&amp;#34;, fun, false); &amp;lt;/script&amp;gt; 1.优点：同时支持事件处理的捕获和冒泡阶段，并且一个元素可以绑定多个处理函数 2.缺点：IE 不支持</description>
    </item>
    <item>
      <title>getElementBy 系列和 querySelector 系列的区别</title>
      <link>https://zishu.me/blog/19.html/</link>
      <pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/19.html/</guid>
      <description>querySelector和querySelectorAll的用法和getElementBy大致一样，获取的时候带上符号，getElementBy 获取的是元素的动态集合，querySelector 获取的是元素的静态集合。&#xA;但是需要注意：getElementBy 系列和 querySelector 系列的区别&#xA;比如，我们写一个 for 循环，每次获取 li 标签的时候，ul 生成一个 li 子元素&#xA;&amp;lt;ul id=&amp;#34;ul&amp;#34;&amp;gt; &amp;lt;li&amp;gt;a&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;b&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;c&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; var ul = document.getElementById(&amp;#39;ul&amp;#39;); var li = document.getElementsByTagName(&amp;#39;li&amp;#39;); for(var i = 0;i &amp;lt; li.length; i++) { ul.appendChild(document.createElement(&amp;#39;li&amp;#39;)) }; console.log(li.length); // 陷入死循环 &amp;lt;/script&amp;gt; 用i &amp;lt; li.length来进行判断时，会导致浏览器死循环，因为循环一次的时候，浏览器又重新获取 li 标签数组，每调用一次就会重新对文档进行查询，就会进入死循环&#xA;进行修改：把i &amp;lt; li.length改成i &amp;lt; 3，把 li 标签数组静态化，然后打印&#xA;conosle.log(li.length) // 6 重新用 querySelector 获取一遍元素&#xA;&amp;lt;ul id=&amp;#34;ul&amp;#34;&amp;gt; &amp;lt;li&amp;gt;a&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;b&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;c&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; var ul = document.querySelector(&amp;#39;ul&amp;#39;); var li = document.querySelectorAll(&amp;#39;li&amp;#39;); for(var i = 0;i&amp;lt;li.length;i++) { ul.appendChild(document.createElement(&amp;#39;li&amp;#39;)) }; console.log(li.length); // 输出对结果是原来的 li.length = 3，而不是增加后的 6 &amp;lt;/script&amp;gt; 静态集合体现在querySelectorAll(&#39;li&#39;)获取到 ul 里所有 li 后，不管后续再动态添加了多少 li，都是不会对其参数影响</description>
    </item>
    <item>
      <title>DOM－－文档对象模型</title>
      <link>https://zishu.me/blog/18.html/</link>
      <pubDate>Sun, 15 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/18.html/</guid>
      <description>DOM 中文名文档对象模型，英文名 Document Object Model，我们简称为 DOM，是针对 html 和 xml 文档的一种 API，将 html 以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM 树，或者节点树，一样的概念&#xA;一、什么是 DOM？ DOM 中文名文档对象模型，英文名 Document Object Model，我们简称为 DOM，是针对 html 和 xml 文档的一种 API，将 html 以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM 树，或者节点树，一样的概念&#xA;js 通过 dom 节点，可以对文档的 html 标签，属性，css 样式，以及具体的内容做出修改，并对页面中的所有事件进行响应&#xA;二、节点树 1.节点类型 文档节点－－Document 标签节点－－Element 文本节点－－Text 注释节点－－Comment 属性节点－－Attr 2. 属性 节点类型－－nodeType 节点名称－－nodeName 节点值－－nodeValue 子节点－－childNodes 父节点－－parentNodes 上一个节点－－previousSibling 下一个节点－－nextSibling 第一个子节点－－firstChild 最后一个子节点－－lastChild 3.文档节点－－document (1) 获取 getElementById()－－通过 id 获取元素 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;通过 id 获取元素&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;); demo.onclick = function() { console.log(&amp;#39;通过 id 获取元素&amp;#39;) } &amp;lt;/script&amp;gt; &amp;lt;!-- 点击 id 为 demo 的元素，控制台输出&amp;#39;通过 id 获取元素&amp;#39; --&amp;gt; getElementsByName()－－通过 name 获取元素 &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;int&amp;#34; value=&amp;#34;通过name获取元素1&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;int&amp;#34; value=&amp;#34;通过name获取元素2&amp;#34;&amp;gt; &amp;lt;script&amp;gt; var int = document.getElementsByName(&amp;#39;int&amp;#39;); for(var i = 0;i &amp;lt; int.length; i++) { console.log(int[i].value); } &amp;lt;/script&amp;gt; &amp;lt;!-- 控制台输出 name 为 int 的元素的 value 值 --&amp;gt; getElementsByTagName()－－通过标签名获取元素 &amp;lt;div&amp;gt;通过标签名获取元素 1&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;通过标签名获取元素 2&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var div = document.getElementsByTagName(&amp;#39;div&amp;#39;); for(var i = 0;i &amp;lt; div.length; i++) { console.log(div[i].innerHTML) } &amp;lt;/script&amp;gt; &amp;lt;!-- 控制台输出标签名为 div 的元素的文本内容 --&amp;gt; getElementsByClassName()－－通过 class 获取元素 &amp;lt;div class=&amp;#34;demo&amp;#34;&amp;gt;通过 class 获取元素 1&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;demo&amp;#34;&amp;gt;通过 class 获取元素 2&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementsByClassName(&amp;#39;demo&amp;#39;); for(var i = 0;i &amp;lt; demo.length; i++) { console.log(demo[i].innerHTML) } &amp;lt;/script&amp;gt; &amp;lt;!-- 控制台输出 class 为 demo 的元素的文本内容 --&amp;gt; querySelector()－－通过选择器获取元素 querySelector() 括号里面要跟上符号，class就写.，id就写#，标签直接写标签名TagName&#xA;&amp;lt;div&amp;gt;通过选择器获取标签名&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;div&amp;#34;&amp;gt;通过选择器获取 class&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div&amp;#34;&amp;gt;通过选择器获取 id&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var divtag = document.querySelector(&amp;#39;div&amp;#39;); var divclass = document.querySelector(&amp;#39;.div&amp;#39;); var divid = document.querySelector(&amp;#39;#div&amp;#39;); divtag.onclick = function() { console.log(&amp;#39;通过选择器获取标签名&amp;#39;) }; // 点击标签 div，控制台输出&amp;#34;通过选择器获取标签名&amp;#34; divclass.onclick = function() { console.log(&amp;#39;通过选择器获取 class&amp;#39;) }; // 点击 class 为 div，控制台输出&amp;#34;通过选择器获取 class&amp;#34; divid.onclick = function() { console.log(&amp;#39;通过选择器获取 id&amp;#39;) }; // 点击 id 为 div，控制台输出&amp;#34;通过选择器获取 id&amp;#34; &amp;lt;/script&amp;gt; querySelectorAll()－－通过选择器获取元素集合 获取的是一个数组集合&#xA;&amp;lt;input type=&amp;#34;text&amp;#34; value=&amp;#34;int1&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; value=&amp;#34;int2&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; value=&amp;#34;int3&amp;#34;&amp;gt; &amp;lt;script&amp;gt; var int = document.querySelectorAll(&amp;#39;input&amp;#39;) for(i = 0; i &amp;lt; int.length; i++) { console.log(int[i].value) } &amp;lt;/script&amp;gt; &amp;lt;!-- 浏览器依次打印出`int1`,`int2`,`int3` --&amp;gt; (2) 创建 createElement()－－创建元素（标签）节点 &amp;lt;ul id=&amp;#34;ul&amp;#34;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; var ul = document.getElementById(&amp;#39;ul&amp;#39;); ul.appendChild(document.createElement(&amp;#39;li&amp;#39;)) &amp;lt;/script&amp;gt; 可以看到，ul 下面已经生成了一个 li 标签&#xA;createTextNode()－－创建文本节点 &amp;lt;ul id=&amp;#34;ul&amp;#34;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; var ul = document.getElementById(&amp;#39;ul&amp;#39;); var li = ul.appendChild(document.createElement(&amp;#39;li&amp;#39;)); var node = document.createTextNode(&amp;#39;我是 li&amp;#39;); li.appendChild(node); &amp;lt;/script&amp;gt; li 标签中生成了一段文本&#xA;createAttribute()－－创建属性节点 &amp;lt;input type=&amp;#34;text&amp;#34;&amp;gt; &amp;lt;script&amp;gt; var int = document.getElementsByTagName(&amp;#39;input&amp;#39;)[0]; var value = document.createAttribute(&amp;#39;value&amp;#39;); value.nodeValue = &amp;#39;通过创建属性节点生成&amp;#39;; int.setAttributeNode(value); &amp;lt;/script&amp;gt; 可以看到 value 属性值被成功创建&#xA;createComment()－－创建注释节点 &amp;lt;div id=&amp;#34;div&amp;#34;&amp;gt;创建一个注释节点&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var div = document.getElementById(&amp;#39;div&amp;#39;); var comment = document.createComment(&amp;#39;添加一个注释节点&amp;#39;); div.appendChild(comment); &amp;lt;/script&amp;gt; f12 查看源码，可以看到 div 生成一行注释&#xA;createDocumentFragment()－－创建文档片段 文档片段的作用，就相当于是添加的所有的节点的父元素&#xA;1.假如没有 createDocumentFragment，添加了很多节点，也可以在 dom 上呈现，但是每次添加的时候都会调用一次 appendChild() 方法，产生很多次页面渲染，显得比较臃肿 2.把多次添加的节点放在一个 createDocumentFragment 节点里面，页面只会调用一次就可以把所有的节点都渲染了&#xA;createEvent()－－创建事件对象&#xA;addEventListener()－－添加事件监听函数&#xA;removeEventListener()－－移除事件监听函数&#xA;事件监听函数详解&#xA;dispatchEvent()－－触发事件 操作 css &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;dom&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; // 直接通过&amp;#39;.&amp;#39;来操作 style var demo= document.getElementById(&amp;#39;demo&amp;#39;); demo.style.color = &amp;#39;red&amp;#39;; // 通过 setAttribute() 来创建属性节点 demo.setAttribute(&amp;#39;style&amp;#39;,&amp;#39;background-color: green&amp;#39;); // 通过 style 的 cssText 属性 demo.style.cssText = &amp;#34;border: 10px solid black&amp;#34;; &amp;lt;/script&amp;gt; 4.元素节点 (element 对象) 有关 innerHTML, innerText, outerHTML, outerText 的区别&#xA;一个是元素内容，一个是文本内容&#xA;&amp;lt;div id=&amp;#34;div1&amp;#34;&amp;gt;第一个 div&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div2&amp;#34;&amp;gt;第二个 div&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div3&amp;#34;&amp;gt;第三个 div&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div4&amp;#34;&amp;gt;第四个 div&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div5&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div6&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div7&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;div8&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var div1 = document.getElementById(&amp;#39;div1&amp;#39;).innerHTML console.log(div1) // 第一个 div var div1 = document.getElementById(&amp;#39;div1&amp;#39;).outerHTML console.log(div1) // &amp;lt;div id=&amp;#34;div1&amp;#34;&amp;gt;第一个 div&amp;lt;/div&amp;gt; var div2 = document.getElementById(&amp;#39;div2&amp;#39;).innerText console.log(div2) // 第二个 div var div2 = document.getElementById(&amp;#39;div2&amp;#39;).outerText console.log(div2) // 第二个 div document.getElementById(&amp;#39;div5&amp;#39;).innerHTML = &amp;#39;&amp;lt;a&amp;gt;《第 5 个 div》&amp;lt;/a&amp;gt;&amp;#39; // 在原有的标签内增加内容，如果有标签会被识别 document.getElementById(&amp;#39;div6&amp;#39;).outerHTML = &amp;#39;&amp;lt;a&amp;gt;《第 6 个 div》&amp;lt;/a&amp;gt;&amp;#39; // 原来的标签会被覆盖，新的文本中如果含有标签会自动生成，如果没有标签则直接以文本形式展示 document.getElementById(&amp;#39;div7&amp;#39;).innerText = &amp;#39;&amp;lt;a&amp;gt;《第 7 个 div》&amp;lt;/a&amp;gt;&amp;#39; // 在原有的标签内增加内容，新标签不会被识别为标签元素，而是被当作文本内容直接写入原标签内 document.getElementById(&amp;#39;div8&amp;#39;).outerText = &amp;#39;&amp;lt;a&amp;gt;《第 8 个 div》&amp;lt;/a&amp;gt;&amp;#39; // 原来的标签会被覆盖，新标签不会被识别为标签元素，而是直接被当作文本形式展示 &amp;lt;/script&amp;gt; (1) 节点属性 childElementCount－－返回当前元素的子节点的个数 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) console.log(demo.childElementCount) // 4 &amp;lt;/script&amp;gt; firstElementChild－－返回当前元素的第一个子元素节点 lastElementChild－－返回当前元素的最后一个子元素节点 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) console.log(demo.firstElementChild) // &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt; console.log(demo.lastElementChild) // &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/script&amp;gt; nextElementSibling－－返回当前元素的下一个兄弟元素节点 previousElementSibling－－返回当前元素的上一个兄弟元素节点 &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) console.log(demo.nextElementSibling) // &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; console.log(demo.previousElementSibling) // &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/script&amp;gt; 返回当前元素所有的子节点 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;).children for(var i in demo) { console.log(demo[i]) } &amp;lt;/script&amp;gt; 控制台查看返回结果&#xA;返回所有子节点集合 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;a id=&amp;#34;demo1&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;).children for(var i in demo1.childNodes) { console.log(demo[i]) } &amp;lt;/script&amp;gt; (2) 节点方法 appendChild－－插入子节点 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) var node = document.createTextNode(&amp;#39;插入一个子节点&amp;#39;) demo.appendChild(node) &amp;lt;/script&amp;gt; f12 可以看到，div 被插入了一个节点&#xA;insertBefore(a, b)－－在指定位置插入节点 参数 a 表示要插入的内容，b 表示定位，在 b 节点之前插入 a 节点&#xA;&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) var node = document.createTextNode(&amp;#39;插入一个子节点&amp;#39;) demo.appendChild(node) var hr = document.createElement(&amp;#39;hr&amp;#39;) demo.insertBefore(hr, node) &amp;lt;/script&amp;gt; 可以看到，原来的文本节点之前，被添加了一个新的元素节点&#xA;replaceChild(a, b)－－替换节点 用参数 a 替换参数 b，a 表示新节点，b 表示旧节点&#xA;&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) var node = document.createTextNode(&amp;#39;插入一个子节点&amp;#39;) demo.appendChild(node) var h3 = document.createElement(&amp;#39;h3&amp;#39;) var h3node = document.createTextNode(&amp;#39;title 标题&amp;#39;) h3.appendChild(h3node) demo.replaceChild(h3, node) &amp;lt;/script&amp;gt; h3是新节点，node是旧节点，根据图片可以看到，b 替换掉了 a，成功上位&#xA;removeChild－－父节点删除子节点 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;son&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) var son = document.getElementById(&amp;#39;son&amp;#39;) demo.removeChild(son) &amp;lt;/script&amp;gt; f12 可以看到，id 为 son 的元素节点，通过demo.removeChild()已经被删除了&#xA;removeAttribute－－删除属性节点 &amp;lt;div id=&amp;#34;demo&amp;#34; class=&amp;#34;div&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) demo.removeAttribute(&amp;#39;class&amp;#39;) &amp;lt;/script&amp;gt; class 属性已经被删除了&#xA;删除文本节点 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;文本&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) demo.removeChild(demo.childNodes[0]) &amp;lt;/script&amp;gt; 通过demo.childNodesp[0]获取 demo 的第一个节点，即文本节点，然后removeChild它，就删除了&#xA;isEqualNode－－判断两个元素是否相等 isSameNode－－判断两个元素是否相同 两者分别代表相等和相同&#xA;(1) isEqualNode相等，指的是两个节点是否是同一类型，具有相等的属性（包括：nodeName, nodeValue&amp;hellip;等等），还有相等的 attributes,childNodes（相等的位置包含相同的值） (2) isSameNode相同，指的是两个节点引用的是同一个对象&#xA;&amp;lt;form action=&amp;#34;#&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;form action=&amp;#34;#&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;form action=&amp;#34;#&amp;#34; id=&amp;#34;o&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;form action=&amp;#34;#&amp;#34; id=&amp;#34;o&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script&amp;gt; var forms = document.forms; var form1 = forms[0]; var form2 = forms[1]; var form3 = forms[2]; var form4 = forms[3]; var _form1 = document.querySelectorAll(&amp;#39;form&amp;#39;)[0]; console.log(form1.isSameNode(form1)) //true 两个节点引用的对象都是第一个 form console.log(form1.isSameNode(_form1)) //true 两个节点引用的对象都是第一个 form console.log(form1.isSameNode(form2)) //false 两个节点引用的不是一个对象 console.log(form1.isEqualNode(form2)) //true 两个节点具有完全等同属性 console.log(form1.isEqualNode(form3)) //false form1 中无等同的 id 属性 console.log(form3.isEqualNode(form4)) //fasle form4 的 childNodes 中的 input 为 text 类别，与 form3 不同 &amp;lt;/script&amp;gt; 根据例子代码可以看出区别：&#xA;(1) isSameNode只有引用同一个对象时才相同，比如用两中方法调用同一个对象，再比较这两种方法，比来比去还是那个对象，所以相同 (2) 而isEqualNode比较两个对象的元素节点是否相等，只要两者一致就可以相等 true&#xA;hasChildNodes()－－判断一个元素是否拥有子节点 判断demo是否拥有子节点，然后输出他的子节点&#xA;&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;!-- &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt; --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) console.log(demo.hasChildNodes()) console.log(demo.childNodes) &amp;lt;/script&amp;gt; contains(a)－－判断一个节点是否包含指定子节点（参数 a 表示要判断的子节点） 存在id=&amp;quot;a&amp;quot;的元素，因此 contains 判断成功输出true，&#xA;不存在id=&amp;quot;b&amp;quot;的元素，因此输出false&#xA;&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;a&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var demo = document.getElementById(&amp;#39;demo&amp;#39;) var a = document.getElementById(&amp;#39;a&amp;#39;) console.log(demo.contains(a)) // true var b = document.getElementById(&amp;#39;b&amp;#39;) console.log(demo.contains(b)) // false &amp;lt;/script&amp;gt; 5.属性节点 (Attr 对象) &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;int&amp;#34;&amp;gt; &amp;lt;script&amp;gt; var int = document.getElementById(&amp;#39;int&amp;#39;) // 1.获取属性值 console.log(int.getAttribute(&amp;#34;type&amp;#34;)) // text // 2.获取属性节点 console.log(int.getAttributeNode(&amp;#34;type&amp;#34;)) // type=&amp;#34;text&amp;#34; // 3.设置属性值 int.setAttribute(&amp;#34;value&amp;#34;, &amp;#34;input 框&amp;#34;) // &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;int&amp;#34; value=&amp;#34;input 框&amp;#34;&amp;gt; // 4.设置属性节点 let name = document.createAttribute(&amp;#34;name&amp;#34;); name.nodeValue = &amp;#34;uname&amp;#34;; int.setAttributeNode(name); console.log(int.getAttributeNode(&amp;#39;name&amp;#39;).value) // &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;int&amp;#34; value=&amp;#34;input 框&amp;#34; name=&amp;#34;uname&amp;#34;&amp;gt; // 5.删除属性节点 console.log(int.removeAttribute(&amp;#39;name&amp;#39;)) // &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;int&amp;#34; value=&amp;#34;input 框&amp;#34;&amp;gt; // 6.判断是否存在属性 console.log(int.hasAttributes()) // true // 7.判断是否存在指定属性 console.log(int.hasAttribute(&amp;#39;value&amp;#39;)) // true &amp;lt;/script&amp;gt; 注意：hasAttribute和hasAttributes的区别 hasAttributes判断是否存在属性， hasAttribute判断是否存在指定属性</description>
    </item>
    <item>
      <title>有关 js 函数，方法的一些补充总结</title>
      <link>https://zishu.me/blog/17.html/</link>
      <pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/17.html/</guid>
      <description>数据类型，构造函数，原型和原型链的一些讲解补充&#xA;一、数据类型 1.5 个基本类型 string number boolean undefined 未定义 null 值为空 symbol 表示一个符号，符号类型是唯一的并且是不可修改的&#xA;最常见的还是前三种，字符串，数字，布尔值&#xA;2.常见的引用类型 引用类型是一种数据结构，用于将数据和功能组织在一起&#xA;对象－Object, 数组－Array, 函数－Function, 正则－RegExp, 日期－Date 等&#xA;二、函数 1.什么是函数？ 具有独立功能的代码块，在 js 中使用 function 关键字定义函数 让代码结构更加清晰，提高代码可用性 js 函数的分类：自定义函数和系统函数 2.自定义函数 有一种匿名函数，没有名字的函数，创建闭包，避免造成全局变量的污染&#xA;匿名自执行函数&#xA;概念：匿名函数的定义完成后立即执行，执行函数表达式 作用：实现闭包和创建独立的命名空间 使用：分组操作符 ()，void 操作符，~操作符，! 操作符等等 使用场景：函数表达式，对象属性，事件，事件参数，返回值 定义完匿名函数后，一定要调用 // 函数表达式 window.onload = function() { let funcobj = function() { alert(&amp;#34;函数表达式中的匿名函数&amp;#34;) } funcobj(); } // 对象属性 window.onload = function() { let obj = { name: function() { alert(&amp;#39;对象属性中的匿名函数&amp;#39;) } } obj.name(); } 3.内置函数 放在全局下面叫做函数，放在对象里面被叫做方法，对象的方法&#xA;常规函数 alert() // 弹出框 confirm() // 弹出一个确认框 prompt() // 弹出一个输入框 isNaN() // 判断是否为数字 parseInt() // 将字符串或浮点数转换为整数 parseFloat() // 将字符串转换为整数或浮点数 eval() // 计算表达式的结果 数组函数 用for循环遍历数组&#xA;var arr = [1,2,3,4]; for(var i = 0; i&amp;lt;arr.length; i++) { console.log(arr[i]) } // 输出 1,2,3,4 通过for in遍历数组&#xA;var arr = [1,2,3,4]; for (var i in arr) { console.log(arr[i]); } // 输出 1,2,3,4 // 增加 unshift() // 添加元素在数组首部，返回值是数组长度 push() // 添加元素在数组尾部，返回值是数组长度 conat() // 连接两个数组，返回值是连接后的数组 var arr1 = [1]; var arr2 = [2]; let arr = arr1.concat(arr2); console.log(arr); // [1,2] /*****************************************/ // 删除 pop() // 删除数组最后一个元素，返回值是删除的元素 shift() // 删除数组第一个元素，返回值是删除的元素 splice(a,b) // 删除指定位置a后的b个元素，返回值是删除的元素 slice(a,b) // 删除从a位置到b位置之间的元素 /*****************************************/ // 查找 indexOf() // 判断数组是否包含指定元素，存在返回元素，不存在返回-1 includes() // 判断数组是否包含指定元素，存在返回true，不存在返回false /*****************************************/ // 其他 sort() // 将数组按照规则排序 var arr1 = [4,5,6]; var arr2 = [1,2,3]; var arrAscSort = arr5.sort((a, b) =&amp;gt; a-b); // 升序排序 console.log(arrAscSort); // [ 1, 1, 2, 3, 5, 6 ] var arrDescSort = arr5.sort((a, b) =&amp;gt; b-a); // 降序排序 console.log(arrDescSort); // [ 6, 5, 3, 2, 1, 1 ] reerse() // 数组反转 var arr = [1,2,3,4,5,6]; // 直接通过reverse()方法调用 console.log(arr.reverse()) // [6,5,4,3,2,1] Array.from() // 将一串数据转换为数组形式 var str = &amp;#39;将一串数据转换为数组形式&amp;#39; console.log(Array.from(str)) // [&amp;#34;将&amp;#34;, &amp;#34;一&amp;#34;, &amp;#34;串&amp;#34;, &amp;#34;数&amp;#34;, &amp;#34;据&amp;#34;, &amp;#34;转&amp;#34;, &amp;#34;换&amp;#34;, &amp;#34;为&amp;#34;, &amp;#34;数&amp;#34;, &amp;#34;组&amp;#34;, &amp;#34;形&amp;#34;, &amp;#34;式&amp;#34;] Array.isArray() // 判断一个变量是否为数组 var str = &amp;#39;将一串数据转换为数组形式&amp;#39; console.log(Array.isArray(str)) // false 日期函数 Date() 获取时间&#xA;var time = new Date() // 获取当前时间 // Fri Nov 13 2020 20:21:35 GMT+0800 (中国标准时间) getFullYear() // 获取当前年份 getMonth() // 获取当月月份 -1 getDate() // 获取当天日期 getHours() // 获取当前小时 getMinutes() // 获取当前分钟 getSeconds() // 获取当前秒 getMilliseconds() // 获取当前毫秒 getTime() // 时间戳-获取1970年至今的毫秒数 设置时间&#xA;setYear() // 设置年份 setMonth() // 设置月份 setDate() // 设置日期 setHours() // 设置小时 setMinutes() // 设置分钟 setSeconds() // 设置秒 数学函数 Math 主要常用的数学函数方法&#xA;Math.abs() // 绝对值 Math.ceil() // 向上取整 Math.floor()// 向下取整 Math.round()// 四舍五入 Math.random() // 生成0-1之间的随机数 random() 的延伸用法－－－生成指定位的随机数&#xA;function getRandomNumber(min, max){ return Math.floor(Math.random()*(max - min)) + min; } console.log(getRandomNumber(1000, 9999)); 字符串函数 indexOf() // 查找字符串，返回索引值 var arr = [&amp;#34;字&amp;#34;, &amp;#34;符&amp;#34;, &amp;#34;串&amp;#34;, &amp;#34;函&amp;#34;, &amp;#34;数&amp;#34;] console.log(arr.indexOf(&amp;#34;串&amp;#34;)) // 2 split() // 将字符串按照指定的分隔符分割开来 var str = &amp;#34;字符串函数&amp;#34; console.log(str.split(&amp;#39;&amp;#39;)) // [&amp;#34;字&amp;#34;, &amp;#34;符&amp;#34;, &amp;#34;串&amp;#34;, &amp;#34;函&amp;#34;, &amp;#34;数&amp;#34;] trim() // 清除字符串两端的空格 var str = &amp;#34; 字符串函数 &amp;#34; console.log(str) // [ 字符串函数 ] console.log(str.trim()) // [字符串函数] match() // 按照制定规则查找值 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.match(/字符串/)) // 字符串 document.write(str.match(/字符串/)) // 字符串 search() // 返回字符串 首次出现的位置 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.search(&amp;#39;串&amp;#39;)) // 2 replace() // 替换指定的字符串 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.replace(&amp;#39;字&amp;#39;,&amp;#39;函&amp;#39;)) // 函符串函数字符串函数 substring(a,b) // 从指定位置切割字符串，左闭右开 // 从索引a，截取到b var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.substring(0,3)) // 字符串 substr(a,b) // 从指定位置切指定个字符 // 从索引a开始，截取b个字符 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.substr(0,3)) // 字符串 </description>
    </item>
    <item>
      <title>javascript——函数、变量和方法</title>
      <link>https://zishu.me/blog/13.html/</link>
      <pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/13.html/</guid>
      <description>当代码出现有规律的重复之后，可以利用函数，定义变量，调用方法，不用去重复的改动代码，只需要进行函数的修改。基本上所有的高级语言都支持函数，javascript 也不例外，它可以像变量一样被使用，方便且强大，因此本文对 js 函数进行系统的学习，并在学习过程中做了详细的笔记以及样例。&#xA;一、函数的定义和调用 1.定义函数 function abs(x) { if(x = 0) { return x; } else { return -x; } } function()指出这是一个函数定义 abs是函数的代码 (x)里面的内容是函数的参数 {...}的内容是函数体，可以包括若干语句，甚至可以没有任何语句 函数体中，必须以return结尾，才可以把结果返回，如果不用 return 结尾的话，就会返回 undefined&#xA;也可以直接定义一个对象，这个对象也可以写成函数的方式&#xA;var abs = function (x) { if (x&amp;gt;=0) { return x }else { return -x } }； function(x)就是一个匿名函数，这个函数被赋值给了变量abs，所以可以直接通过abs调用该函数&#xA;这两种定义函数的方式完全一致，，但是用变量定义的时候需要注意，要用;结尾，代表函数语句结束&#xA;2.调用函数 调用函数时，直接传参即可 abs(10)，根据函数定义，将 10 代入进去即可，返回的结果是 x , 即 10&#xA;3.检查参数 可以对参数进行检查，看看是否是自己想要的参数对类型&#xA;如果传入对参数abs(x)中非数字，控制台返回结果this is not number，如果传参为数字，则进行条件判断&#xA;function abs(x) { // 检查参数x是否为数字 if (typeof x !== &amp;#39;number&amp;#39;) { console.log(&amp;#39;this is not number&amp;#39;) }else{ if (x &amp;gt;= 0) { return x }else { return -x } } } 4.arguments 利用arguments，可以获得调用者传入的所有参数&#xA;arguments代表传入的参数，arguments.length代表传入参数的长度&#xA;console.log(arguments.length) // 这行代码写在函数中，控制台就可以输出出来 先写一个循环，把参数输出的函数方法，函数写完之后，传入参数，控制台随之打印出传入的参数&#xA;function str() { var s for(var i = 0; i&amp;lt;arguments.length; i++) { // 返回传入的参数 console.log(arguments[i]); s += arguments[i] + &amp;#34;,&amp;#34;; } return s; }; // 传入参数 str(&amp;#34;name&amp;#34;, &amp;#34;age&amp;#34;); //控制台输出：name, age 5.return 返回 true 时，点击链接直接跳转，返回 false 时，会忽略 a 链接的地址，跳转到 window.location.href 后的地址&#xA;&amp;lt;a href=&amp;#34;https:www.baidu.com&amp;#34; onclick=&amp;#34;return myfun()&amp;#34;&amp;gt;baidu&amp;lt;/a&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;test&amp;#34; value=&amp;#34;click&amp;#34;&amp;gt; &amp;lt;script&amp;gt; function myfun() { window.location.href = &amp;#39;https://www.bilibili.com&amp;#39;; var test = document.getElementById(&amp;#39;test&amp;#39;).value; console.log(test); return false; } &amp;lt;/script&amp;gt; return 需要注意的地方：函数会自动在行尾添加;，所以在写 return 的时候一定要注意，不要单纯的拆分为两行，很容易报错&#xA;return { name: &amp;#39;foo&amp;#39; } // 上面这种写法就是有问题的，js的机制会自动将其渲染为 return; //return undefined { naem: &amp;#39;foo&amp;#39; }; // 正确的写法应该是： return { name: &amp;#39;foo&amp;#39; }; 6.rest 把传入的参数，多余的部分，以数组的形式保存起来，为了获得额外的参数，需要 i = 2 开始，把已有的 a,b 排除掉&#xA;function arr(a, b) { var i, rest = []; if (arguments.length &amp;gt; 2) { for (i = 2; i&amp;lt;arguments.length; i++) { rest.push(arguments[i]); } } console.log(&amp;#39;a = &amp;#39; + a); console.log(&amp;#39;b = &amp;#39; + b); console.log(rest); }; arr(1,2,3,4); 控制台打印：&#xA;可以看到多余的部分被打印到Array中了&#xA;这种写法略显麻烦，下面是更简单的写法&#xA;直接在在函数里定义参数rest，并且在前面加上...标识，多余的参数直接以数组的形式交给变量rest，不需要arguments就可以获取全部参数&#xA;如果传参数量还没有超过定义参数的数量，函数就会返回一个空数组&#xA;function foo(a, b, ...rest) { console.log(&amp;#39;a = &amp;#39; + a); console.log(&amp;#39;b = &amp;#39; + b); console.log(rest) } foo(1,2,3,4) // a = 1 // b = 2 // Array [3,4] foo(1) // a = 1 // b = undefined // Array [ ] 7.计算 对传入的参数求和&#xA;// forEach可以返回数组中所有的元素 function sum(...rest) { var sum = 0; rest.forEach(function(x) { sum += x; }); return sum; }; //sum(1,2) //控制台输出 3。求和成功 计算圆的面积&#xA;// r 表示圆的半径 // pi 如果没有参数，默认为3.14 function area_of_circle(r, pi){ var area; if(arguments.length == 1) { // 当传入的参数只有一位时，计算3.14*r的平方 area = 3.14*r*r; }else{ area = pi*r*r; } return area; } 二、变量和作用域 1.声明变量 在 js 中，通常使用var来生声明变量，而声明的变量实际上是有作用域的&#xA;在函数体内声明的变量，只能在函数体内生效，在函数体外是无法识别的 function fun() { var a = 1; }; a = a + 1; // err 这行代码直接报错，因为全局中没有a这个变量 如果两个函数体中各自声明了变量a，互不干扰，在自己的函数体内可以正常作用，出了函数体都没有作用了&#xA;js 函数可以嵌套，内部函数可以访问外部函数，外部函数不能访问内部函数&#xA;function par() { var x = 1; function son() { var y = x + 1; }; var z = x + y; // Error: } 所以var z = x + y会报错，因为变量y在son()中，根据函数外部无法访问函数内部，y无法被访问，因此var z = x + y报错&#xA;两个嵌套的函数体，各有一个重名变量，js 函数在查找变量的时候，优先从自身开始，如果自身有这个变量就获取，如果没有，有内向外，由下层到上层的查找 function par() { var num = 1; function son() { var num = 2; console.log(&amp;#34;son() = &amp;#34; + num); }; console.log(&amp;#34;par() = &amp;#34; + num); son(); }; par(); 函数必须经过调用之后才能生效 son()和par()&#xA;2.变量提升 JavaScript 的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，但是并不会将赋值一起提升，很容易产生代码的报错&#xA;因此，针对这一问题，我们在声明变量的时候，要将其统一放置在函数的起始位置，严格遵守在函数内部首先声明所有变量的原则&#xA;3.全局作用域 不再任何函数内部定义的变量就叫做全局变量，也就是window下，他也被称作全局作用域，全局作用域下的变量实际上被绑定到window&#xA;var course = &amp;#39;learn js&amp;#39;; console.log(course); // learn js console.log(window.course) // learn js 直接访问全局变量或者在前面加上window，结果都是一样的&#xA;整个 js 文件只有一个全局作用域，就是window，如果在某一个函数作用域内查找变量，没有查找到，就会由内到外一层层查找，如果最后在全局作用域中也没有查找到，就会ReferenceError 报错&#xA;4.局部作用域 在函数内部就是局部作用域，这个代码的名字只在函数的内部起作用&#xA;在for循环等语句中，无法定义具有局部作用域的变量&#xA;5.全局变量和局部变量的区别 全局变量：在任何一个地方都可以使用，全局变量只有在浏览器关闭的时候才会销毁，比较占用内存资源&#xA;局部变量：只能在函数内部使用，当其所在代码块被执行时，会被初始化；当代码块执行完毕就会销毁，因此更节省节约内存空间&#xA;当在函数作用域中操作一个变量的时候，会先在自身作用域中查找，如果有就直接使用，如果没有就向上级作用域中寻找。如果全局作用域中也没有，那么就报错&#xA;6.常量 var和let声明的是一个变量，在 ES6 之间，用大写的变量名，表示定义一个常量&#xA;// ES5 var NAME = &amp;#39;xiaoming&amp;#39; ES6 新增一个关键字const来定义常量&#xA;// ES6 const name = &amp;#39;xiaoming&amp;#39; 三、解构赋值 1.可以把一个数组的元素分别赋值给不同的变量&#xA;var array = [&amp;#39;hello&amp;#39;, &amp;#39;javascript&amp;#39;, &amp;#39;ES6&amp;#39;]; var x = array[0]; var y = array[1]; var z = array[2]; // x = &amp;#39;hello&amp;#39; // y = &amp;#39;javascript&amp;#39; // z = &amp;#39;ES6&amp;#39; 2.如果数组本身还有嵌套，也可以进行解构赋值，但是要注意嵌套的层次和数组保持一致&#xA;let [x, [y, z]] = [&amp;#39;hello&amp;#39;, [&amp;#39;JavaScript&amp;#39;, &amp;#39;ES6&amp;#39;]]; x; // &amp;#39;hello&amp;#39; y; // &amp;#39;JavaScript&amp;#39; z; // &amp;#39;ES6&amp;#39; 3.解构赋值时可以忽略元素&#xA;let [, , z] = [&amp;#39;hello&amp;#39;, &amp;#39;JavaScript&amp;#39;, &amp;#39;ES6&amp;#39;]; z; // ES6 4.还可以对对象进行解构赋值&#xA;var person = { name: &amp;#39;xiaoming&amp;#39;, age: 22, gender: &amp;#39;male&amp;#39;, email: &amp;#39;zsh981109@163.com&amp;#39;, school: &amp;#39;zyg&amp;#39; } // 定义了三个变量，分别对应三个属性 var {name, age, email} = person; console.log(name, age, email); 控制台就可以打印出我们想要的内容了&#xA;对对象进行解构赋值时，也可以进行嵌套&#xA;5.可以通过属性名赋值的时候，重新定义一个变量名&#xA;var person = { name: &amp;#39;小明&amp;#39;, age: 20, gender: &amp;#39;male&amp;#39;, passport: &amp;#39;G-12345678&amp;#39;, school: &amp;#39;No.4 middle school&amp;#39; }; // 把passport属性赋值给变量id: let {name, passport:id} = person; console.log(name); console.log(age); console.log(id); console.log(email); 控制台输出结果：&#xA;可以看到，name,age,id 都打印出来了，而 email 报错，因为 email 的内容赋值给了新变量id，而email没有任何内容，所以报错&#xA;6.可以使用默认值 true，避免不存在的属性返回 undefined&#xA;var person = { name: &amp;#39;小明&amp;#39;, age: 20, gender: &amp;#39;male&amp;#39;, passport: &amp;#39;G-12345678&amp;#39; }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; name; // &amp;#39;小明&amp;#39; single; // true 要注意，赋值的时候不能以{开头，避免 js 将其渲染失败&#xA;var person = { name: &amp;#39;小明&amp;#39;, age: 20, gender: &amp;#39;male&amp;#39;, passport: &amp;#39;G-12345678&amp;#39; }; // 声明变量 var x; var y; // 解构赋值 {x, y} = { name: &amp;#39;小明&amp;#39;, x: 100, y: 200} // Error: 在这里 {x, y} = person会报一个错误，=不合法，所以正确的写法是，在赋值语句外部包裹一层()小括号&#xA;({x, y} = { name: &amp;#39;小明&amp;#39;, x: 100, y: 200}); 7.解构赋值的使用场景&#xA;交换两个变量的值&#xA;var a = 1; var b = 2; [a, b] = [b, a] 四、对象的方法 绑定到对象上的函数被称为方法&#xA;在一个对象中绑定函数，称为这个对象的方法&#xA;1.this 下面段代码返回的是（今年的年份－出生年份）&#xA;var xm = { name: &amp;#39;xiaoming&amp;#39;, birth: 1998, age: function() { var year = new Date().getFullYear(); return year - this.birth } }; // 在对象xm中，调用方法age() xm.age(); // 22 这里引入了一个新的关键词this&#xA;在方法内部，this是一个特殊的变量，它始终指向当前对象，也就是xm这个变量&#xA;所以this.birth指的就是变量xm的birth属性&#xA;this存在于方法中，想在方法中调用对象的属性，必须通过this&#xA;如果在方法写在对象外部时，this的指向问题就要好好分析了，比如：&#xA;function getage() { var year = new Date().getFullYear(); return year - this.birth; } var xiaoming = { name: &amp;#39;小明&amp;#39;, birth: 1990, age: getage }; 单独调用getage()的时候，这时的getage()指的是一个方法，同时这个方法处于全局作用域下，此时this指向的是全局对象window，所以返回NaN&#xA;只有xiaoming.age()调用的才是对象xiaoming下面的方法getage()&#xA;因此：要保证this的指向正确，必须使用obj.xxx()的形式调用 如果没有使用这种方法，全部报错，如果是在&amp;rsquo;use strict&amp;rsquo;模式下，this会指向 undefined&#xA;2.that 如果在对象里面的方法，又套了一层事件，此时this指向又有问题了，它指向第一层方法，而不是方法对应的对象&#xA;所以，在写方法的时候，直接先声明一个var that = this，这个that指向对象里面的属性，接下来，在方法里面调用属性的时候，直接在前面加上that.即可，它直接指向到对象下面的属性&#xA;var xm = { name: &amp;#39;xiaoming&amp;#39;, birth: 1998, age: function() { var that = this; function getbirthage() { var y = new Date().getFullYear(); return y - that.birth; } return getbirthage(); } }; // xm.age(); 可以看到，通过定义var that = this，然后在方法里面使用that.指向属性，不管套了几层方法，都不会报错，直接指向对象下面的属性&#xA;通过var that = this，可以放心的在方法里面定义其他函数，不用担心获取不到对象属性的问题&#xA;但是有一个需要注意的地方，每个方法结束后，都要返回一下结果，return getbirthage()&#xA;3.apply 除了var that = this，还可以通过apply属性控制this的指向&#xA;apply是函数本身的方法，它拥有两个参数&#xA;function getage() { var y = new Date().getFullYear(); return y - this.birth; } var xm = { name: &amp;#39;xiaoming&amp;#39;, birth: 1998, age: getage } // xm.age(); // getage.apply(xm, []); 写法就是getage.apply(xm, [])，apply的第一个参数代表this指向，即对象，第二个参数，表示函数本身的参数&#xA;4.apply( ) 和 call( ) call()是与apply类似的方法，区别是：&#xA;apply()将参数打包成Array call()直接将参数按顺序传入 调用math.max(1,2,3)，分别采用两种方式&#xA;math.max.apply(null, [1,2,3]); // 3 math.max.call(null, [1,2,3]); // 3 两者的结果是一样的，调用普通函数时，把this绑定为null</description>
    </item>
    <item>
      <title>HTML 事件属性--DOM</title>
      <link>https://zishu.me/blog/12.html/</link>
      <pubDate>Thu, 29 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/12.html/</guid>
      <description>研究 html 的对象，事件和方法，从 js 的角度来思考，这个标签的属性是通过什么方法，触发什么事件来实现的&#xA;键盘鼠标事件&#xA;页面窗口事件&#xA;表单事件&#xA;一、window 事件属性 针对 window 对象触发的事件，在&amp;lt;body&amp;gt;中执行&#xA;1.onbeforeprint／onafterprint 在浏览器打印之间/后触发&#xA;&amp;lt;body onbeforeprint = print()&amp;gt; &amp;lt;script&amp;gt; function print() { alert(&amp;#34;打印之间！&amp;#34;) } &amp;lt;/script&amp;gt; 打印前和打印后的事件方法类似，一个是在打印前触发事件，一个是在打印这个事件结束之后触发onafterprint这个事件&#xA;demo 查看&#xA;2.onbeforeunload/unload 离开页面之间触发的事件／之后触发的事件&#xA;打开 f12，然后刷新，或者关闭浏览器，可以在浏览器触发事件&#xA;&amp;lt;script&amp;gt; window.onbeforeunload = function(){ return &amp;#34;提示&amp;#34; //返回的内容不会显示， //在刷新的时候触发，或者关闭浏览器，浏览会直接提示是否重新加载，不能直接返回return } &amp;lt;/script&amp;gt; demo 查看&#xA;3.onerror 当图片出错是可以触发该事件，支持该事件的标签只有 &amp;lt;img&amp;gt;,&amp;lt;object&amp;gt;,&amp;lt;style&amp;gt;&#xA;&amp;lt;img src=&amp;#34;1.gif&amp;#34; onerror = &amp;#34;myfun()&amp;#34;&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#34;图片出错&amp;#34;) } &amp;lt;/script&amp;gt; 1.gif 不存在，因此触发了一个 myfun() 事件，弹出窗口&#xA;demo 查看&#xA;4.onhashchange 当文档改变时发生的脚本 ？？？&#xA;5.onload 页面加载完成之后触发&#xA;demo 查看&#xA;6.onmessage 在消息被触发时运行 ???&#xA;7.onoffline 当浏览器离线时触发&#xA;&amp;lt;body onoffline=&amp;#34;myfun()&amp;#34;&amp;gt; 8.ononline 当浏览器在线工作时触发&#xA;&amp;lt;body ononline=&amp;#34;myfun()&amp;#34;&amp;gt; ononline和onoffline在网络断线或者连线时触发，可以控制电脑网络查看效果&#xA;9.onpagehide 当用户从网页离开时触发，也可以理解成当窗口隐藏时运行的脚本&#xA;刷新页面可以触发事件&#xA;demo 查看&#xA;10.onpageshow 打开一个新页面或者刷新的时候触发&#xA;demo 查看&#xA;相当于onload，加载页面时触发，但是在不同浏览器触发的有所不同&#xA;第一次加载页面时，onpageshow在ie浏览器中不触发，其他情况都触发&#xA;11.onresize 当浏览器窗口被改变大小时触发事件&#xA;&amp;lt;body onresize=&amp;#34;myfun()&amp;#34;&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;浏览器窗口改变了&amp;#39;) } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; demo 查看&#xA;12.onunload 页面被下载时触发，就是刷新或者关闭页面时触发&#xA;window.onunload = function() { return &amp;#39;确定关闭吗？&amp;#39; } 13.onpopstate 当浏览器窗口记录改变时运行的脚本，&#xA;14.onredo 当文档执行撤销时触发的事件&#xA;二、form 事件属性 由 html 表单内触发的事件，通常使用在 form 元素中&#xA;1.onblur 失去焦点时运行的脚本&#xA;&amp;lt;input name=&amp;#34;int&amp;#34; id=&amp;#34;int&amp;#34; onblur=&amp;#34;myfun()&amp;#34;&amp;gt; &amp;lt;script&amp;gt; function myfun() { var int = document.getElementById(&amp;#39;int&amp;#39;).value; document.getElementById(&amp;#39;int&amp;#39;).value = int.toUpperCase(); } &amp;lt;/script&amp;gt; 给 input 绑定一个 onblur=myfun() 的事件，当 input 失去焦点的时候产生什么样的效果&#xA;demo 查看&#xA;2.onfocus 元素获得焦点时触发事件，和 onblur 相反&#xA;demo 查看&#xA;3.onchange 当元素值被改变的时候触发事件&#xA;&amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;int&amp;#34; name=&amp;#34;int&amp;#34; onchange=&amp;#34;myfun()&amp;#34;&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;我的元素被改变啦！&amp;#39;) } &amp;lt;/script&amp;gt; 这个事件的意思就是，当我对 input 内容进行操作改变后，浏览器会弹出一个 alert&#xA;demo 查看&#xA;4.oncontextmenu 当用户右键操作时触发该事件&#xA;可以绑定在任意元素中触发，可以一直触发，不用刷新&#xA;&amp;lt;div oncontextmenu=&amp;#34;myfun()&amp;#34;&amp;gt;这是一个文本框！&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;oncontentmenu事件触发&amp;#39;) } &amp;lt;/script&amp;gt; demo 查看&#xA;5.onformchange 当表单获得输入时可以触发事件&#xA;触发发不了脚本&#xA;6.onforminput 当表单获得用户输入时触发的事件，无法触发&#xA;浏览器不支持&#xA;6.oninput 当元素获得用户输入时触发的事件 当输入框输入或者删除时都会触发 oninput&#xA;&amp;lt;input type=&amp;#34;text&amp;#34; oninput=&amp;#34;myfun()&amp;#34;&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;oninput触发了&amp;#39;) } &amp;lt;/script&amp;gt; onchange和oninput有相似的地方，都是改变文本内容时触发事件&#xA;但是onchange是在 input 失去焦点时才触发，oninput是立刻触发&#xA;demo 查看&#xA;7.oninvalid oninvalid事件要搭配required属性来使用&#xA;required如果使用该属性，代表必填字段，oninvalid是当元素无效时触发的事件&#xA;&amp;lt;form&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; oninvalid=&amp;#34;myfun()&amp;#34; required&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;填写为空&amp;#39;) } &amp;lt;/script&amp;gt; demo 查看&#xA;8.onreset 表单中重置按钮被点击时触发&#xA;&amp;lt;form onreset=&amp;#34;myfun()&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;reset&amp;#34; value=&amp;#34;reset&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script&amp;gt; function myfun(){ alert(&amp;#39;重置成功&amp;#39;) } &amp;lt;/script&amp;gt; demo 查看&#xA;9.onselect 文本被选中时触发&#xA;&amp;lt;input onselect=&amp;#34;myfun()&amp;#34; value=&amp;#34;选中我&amp;#34;&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;onselect被触发 &amp;#39;) } &amp;lt;/script&amp;gt; demo 查看&#xA;10.onsubmit 当表单被提交时触发&#xA;要把事件绑定到 form 标签里面&#xA;&amp;lt;form onsubmit=&amp;#34;myfun()&amp;#34;&amp;gt; &amp;lt;!-- 注意：事件要绑定到form标签上面 --&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;name&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;submit&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;提交了&amp;#39;) } &amp;lt;/script&amp;gt; demo 查看&#xA;注意：提交了之后会自动刷新页面，document 和 console 的触发内容会立刻刷新，一闪而过，只有 alert 能停留在页面上，等待点击确定&#xA;三、key 键盘事件 1.onkeydown 按下任意键时触发，包括系统按钮，箭头和功能键&#xA;demo 查看&#xA;2.onkeypress 按下任意字母数字键时触发，但系统按钮，箭头和功能无法识别&#xA;3.onkeyup 松开任何之前按下的键盘时触发&#xA;demo 查看&#xA;四、mouse 鼠标事件 利用鼠标触发的事件&#xA;1.onclick 鼠标点击元素触发的事件&#xA;&amp;lt;p onclick=&amp;#34;myfun()&amp;#34;&amp;gt;点击我&amp;lt;/p&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;点击成功&amp;#39;) } &amp;lt;/script&amp;gt; demo 查看&#xA;2.ondblclick 鼠标双击时触发的事件&#xA;&amp;lt;div ondblclick=&amp;#34;myfun()&amp;#34;&amp;gt;测试文本！&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;双击测试成功！&amp;#39;) } &amp;lt;/script&amp;gt; demo 查看&#xA;3.拖动事件 ondrag/ 元素被拖动时触发的事件&#xA;ondragstart/在拖动操作开端运行的脚本&#xA;ondrop/ 当元素正在被拖动时触发的事件&#xA;ondragend/在拖动操作末端运行的脚本&#xA;ondragenter/当元素元素已被拖动到有效拖放区域时运行的脚本&#xA;ondragleave/当元素离开有效拖放目标时运行的脚本&#xA;ondragover/当元素在有效拖放目标上正在被拖动时运行的脚本&#xA;4.onmousedown/onmouseup 当元素按下鼠标时触发的事件/鼠标释放时触发的事件&#xA;一个是按下去的瞬间就触发 一个是当鼠标被松开的时候触发 onmouseup效果和onclick一样，因为click也是点击过后触发&#xA;这两个事件加起来相当于一个click事件，但是并不能用这两个事件来做点击事件的效果&#xA;demo 查看&#xA;5.onmousemove 当鼠标移动到元素上时触发&#xA;相当于 css 里面的 :hover，但是作为事件拥有更灵活多变的用法&#xA;demo 查看&#xA;6.onmouseout 当鼠标离开元素时触发&#xA;demo 查看&#xA;7.onmouseover 当鼠标进入元素时触发&#xA;onmouseover和onmousemove都是鼠标进入元素触发&#xA;区别：&#xA;1.&#xA;over在进入元素时触发，但在元素内部移动时不触发 move是进入元素时和在元素里面移动时都触发&#xA;2.&#xA;over优先触发，然后才触发move&#xA;8.onmousewheel 当鼠标滚动被滚动时触发的事件&#xA;&amp;lt;style&amp;gt; div { height: 1000px; } &amp;lt;/style&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div onmousewheel=&amp;#34;myfun()&amp;#34;&amp;gt;测试&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; function myfun() { alert(&amp;#39;onmousewheel&amp;#39;) } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; 每次滚动时都可以触发，可以绑定到 body 上&#xA;demo 查看&#xA;9.onscroll 当元素滚动条被滚动时触发的事件&#xA;&amp;lt;div onscroll=&amp;#34;myfun()&amp;#34;&amp;gt;In my younger and more vulnerable years my father gave me some advice that I&amp;#39;ve been turning over in my mind ever since.&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;滑动了&amp;lt;span id=&amp;#34;ci&amp;#34;&amp;gt;&amp;lt;/span&amp;gt;次&amp;lt;/p&amp;gt; &amp;lt;script&amp;gt; x = 0 function myfun() { document.getElementById(&amp;#39;ci&amp;#39;).innerHTML = x += 1 } &amp;lt;/script&amp;gt; 这个案例－－－滑动滚动计数&#xA;demo 查看&#xA;区别：&#xA;1.wheel在滚轮滑动的时候有效，鼠标拖拽的时候无效&#xA;2.onscroll不管在滑动还是拖动的时候，均生效</description>
    </item>
    <item>
      <title>js 基本语法</title>
      <link>https://zishu.me/blog/11.html/</link>
      <pubDate>Wed, 21 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/11.html/</guid>
      <description>在学习 js 基本语法的过程中，把遇见的知识点和问题记录喜下来，以便未来复习和参考。&#xA;数据类型有：数据，字符串，数组，数字，布尔值等。&#xA;一、数据类型 1.number 2.布尔值 只有 true 和 false 两种，可以直接用 true 和 false 来表达，比如：&#xA;true;&#x9;//true false;&#x9;//false 2&amp;gt;1;&#x9;//true 2&amp;gt;3;&#x9;//fasle 与&#x9;&amp;amp;&amp;amp; 两者同时为true，运算结果为true&#xA;或&#x9;|| 只要有一个为true，运算结果就是true&#xA;非&#x9;！ 当程序为true时，运算结果取反为false&#xA;var age = 15; if(age &amp;gt;= 18) { alert(&amp;#39;adult&amp;#39;) }else{ alert(&amp;#39;teenager&amp;#39;) } age 值是 15，当 age 大于且等于 18 的时候浏览器弹出 adult，反之弹出 teenager&#xA;3.字符串 4.比较运算符 ==和===&#xA;当使用==进行比较的时候，一般会自动转换类型然后再进行比较&#xA;当使用===进行比较的时候，如果数据类型不一样，直接返回false，等到类型一致了，然后再进行比较&#xA;有一个特殊的number就是NaN，它不与任何值相等，包括它自己NaN&#xA;NaN === NaN&#x9;//false 5.null和undefined null表示一个空值，0表示一个数值，&#39;&#39;表示长度为 0 的字符串，但是null表示空&#xA;undefined表示未定义&#xA;但是区分两者意义不大，大多数还是在用null，undefined仅仅在判断函数参数是否传递的情况下有用&#xA;6.数组 Array [ ] ，表示一组按顺序排列的集合，其中的每个值称为元素&#xA;new Array(1,2,3)&#x9;//[1,2,3] 数组的索引&#xA;二、对象和变量 var person = { name: &amp;#39;jack&amp;#39;, age: 20, city: &amp;#39;hangzhou&amp;#39; } person是对象变量，name: &#39;jack&#39;这就是一个键值对，name是属性名，&#39;jack&#39;是属性&#xA;要获取一个对象的属性，用对象变量.属性，也就是person.name，结果是jack&#xA;person.name&#x9;//jack person.age&#x9;//20 var是一个动态语言，就算 var 定义了 x = 100，后面又有 x = x+ 100，所以就变成了 200,&#xA;var x = 100; x = x+ 100; console.log(x)&#x9;//200 假如用 int 来定义 x，后面的 x = x + 100 就会报错&#xA;并且使用 var 定义的变量只会存在与该函数作用域，并不是默认的全局变量&#xA;而如果没有使用var，直接定义i = 100，变量 i 会被默认为全局变量&#xA;三、字符串 需要用到转义字符\&#xA;1.模板字符串 var name = &amp;#39;小明&amp;#39;; var age = 20; var message = name + &amp;#39;今年&amp;#39; + age + &amp;#39;了&amp;#39;; //小明今年20了 var message = `${naem}，你今年${20}了` //ES6新增的语法，一样的结果 字符串不可改变&#xA;如果对字符串的某个索引赋值，不会报错，不会发生任何改变&#xA;var a = &amp;#39;hello,world!&amp;#39; a[0];&#x9;//h a[0] = k; console.log(a);&#x9;//结果为&amp;#39;hello,world!&amp;#39;，不会发生改变 2.toUpperCase 大写 他会返回一个新的字符串，把一个字符串全部变成大写&#xA;var a = &amp;#39;hello&amp;#39;; a.toUpperCase();&#x9;//返回HELLO 3.toLowerCase 小写 他会返回一个新的字符串，他会把一个字符串全部变成小写&#xA;var a = &amp;#39;hello&amp;#39; a.toLowerCase();&#x9;//HELLO 4.indexOf 他会返回指定字符串的索引，如果没有找到指定的字符串，则会返回-1&#xA;var a = &amp;#39;hello,world!&amp;#39; a.indexOf(&amp;#39;world&amp;#39;);&#x9;//6 5.substring 他会返回指定区间索引的字符串，包括前一个数，不包括后一个数&#xA;var a = &amp;#39;hello,world!&amp;#39; a.substrng(0, 5);&#x9;//hello 如果()里面只有一个数值，则从这个数值的索引开始直到结束，比如：&#xA;var a = &amp;#39;hello,world!&amp;#39;; a.substring(6);&#x9;//返回world! 四、数组 数组Array可以包含任何类型的数据，并通过索引来访问每个数据&#xA;1.length 属性 Array的长度可以用length属性来获取，它和索引不一样，从 1 开始计算&#xA;var arr = [1,2,3,&amp;#39;hello&amp;#39;,null,true] arr.length;&#x9;//返回6 并且通过改变length的值，可以改变数组的内容大小变化&#xA;var arr = [1,2,3,&amp;#39;hello&amp;#39;,null,true] arr.length;&#x9;//6 arr.length = 8;&#x9;//[1,2,3,&amp;#39;hello&amp;#39;,null,true,undefined,undefined] arr.length = 2;&#x9;//[1,2] 2.通过索引改变数组 Array可以直接通过索引修改对应的元素&#xA;var arr = [1,2,3] arr[1] = &amp;#39;hello&amp;#39; console.log(arr); //[1,&amp;#39;hello&amp;#39;,3] js 允许直接通过索引改变数组的长度，不会报错，但是不建议这么做&#xA;3.indexOf Array可以通过indexOf来搜索一个指定的元素的索引&#xA;var arr = [1,2,3,&amp;#39;hello&amp;#39;] arr.indexOf(1);&#x9;//0 arr.indexOf(3); //2 4.slice slice属性与substring类似，后者是截取字符串的内容，slice是截取数组的内容，然后返回一个新的数组&#xA;如果有两个数值，包括前面的数值，不包括后面的数值；如果只有一个数值，则从它开始算起一直到结束&#xA;var arr = [1,2,3,4,5]; arr.slice[0,2];&#x9;//返回[1,2] arr.slice[2];&#x9;//返回[3,4,5] 如果slice不指定数值，则返回数组的全部内容，可以利用这个特性复制一个相同的数组出来&#xA;var arr = [1,2,3]; var arr1 = arr.slice(); console.log(arr1);&#x9;//[1,2,3] arr1 === arr;&#x9;//true 注意：两个数组相比都是 false，就算数组内容一样也会 false&#xA;var arr = [1,2,3] var arr1 = [1,2,3] arr === arr1&#x9;//false 5.push 和 pop push()向数组的末尾添加元素&#xA;pop()把数组的最后一个元素删掉&#xA;6.unshifth 和 shift unshift()向数组的头部添加元素&#xA;shift()把数组的第一个元素删掉&#xA;7.sort sort()可以对数组进行排序，会直接修改当前数组的元素位置，直接调用时，会按照默认的方式排序&#xA;var arr = [B,A,C] arr.sort(); arr&#x9;//[A,B,C] 8.reverse reverse()会把整个数组调个个，不是反向排序&#xA;var arr = [2,1,3] arr.reverse(); arr;&#x9;//[3,1,2] 9.splice 这个属性是万能的方法，通过调用splice()，可以从指定的索引删除元素或者添加元素&#xA;五、条件判断 在 js 中，使用 if() {...} else {...}进行条件判断&#xA;var age = 22; if(age&amp;gt;20) { // 如果age&amp;gt;20成立，执行该语句 console.log(&amp;#39;22&amp;gt;20&amp;#39;) }else { // 如果age&amp;gt;20不成立，则执行该语句 conosle.log(&amp;#39;22&amp;lt;20&amp;#39;) } 最终，控制台会打印出22&amp;gt;20，因为条件成立&#xA;执行的语句要用{}包裹起来，防止其他情况会报错&#xA;多条件判断语句&#xA;三个或者三个以上多判断语句，被称为多条件判断语句&#xA;var a = 10 if(a&amp;lt;10) { console.log(&amp;#39;a&amp;lt;10&amp;#39;) }else if(a&amp;gt;20){ console.log(&amp;#39;a&amp;gt;10&amp;#39;) }else{ console.log(&amp;#39;10&amp;lt;=a&amp;lt;=20&amp;#39;) } 如果多个条件中都满足，则取第一个满足的结果，执行其代码，之后满足的自动忽略掉，所以在 进行条件判断的时候，不要重复判断情况&#xA;一个复杂的多条件判断语句&#xA;var height = parseFloat(prompt(&amp;#39;请输入身高(m):&amp;#39;)); var weight = parseFloat(prompt(&amp;#39;请输入体重(kg):&amp;#39;)); var bmi = weight/(height*height); if(bmi &amp;lt; 18.5) { console.log(&amp;#39;过轻&amp;#39;) }else if(bmi&amp;gt;18.5,bmi&amp;lt;25) { console.log(&amp;#39;正常&amp;#39;) }else if(bmi&amp;gt;25,bmi&amp;lt;28){ console.log(&amp;#39;过重&amp;#39;) }else if(bmi&amp;gt;28,bmi&amp;lt;32){ console.log(&amp;#39;肥胖&amp;#39;) }else{ console.log(&amp;#39;严重肥胖&amp;#39;) } parseFloat可以解析一个字符串，并返回一个数字&#xA;六、循环 简单的运算可以手打出来&#xA;1 + 2 + 3 // 控制台输出 6 但是几百次，几千次，几万次的运算无法手打，可以依靠循环语句来进行计算，为了让计算机能够进行成千上万次的运算&#xA;循环语句有两种 for 和 while，他们有不同的用法，适应不同的情况&#xA;1. for 循环 通过初始条件，结束条件和递增条件来循环执行语句块&#xA;var x = 0 var i for(i = 1; i &amp;lt;= 1000; i++) { x = x + i } i = 1 是初始条件，i 从 1 开始算起 i&amp;lt;=是判断条件，满足就执行循环，不满足就退出循环 i++ 是递增条件，每次循环过后都是＋1，当无数次后不满足了 i&amp;lt;=1000，会跳出循环&#xA;2. 通过 for 语句遍历数组 var arr = [&amp;#39;apple&amp;#39;, &amp;#39;banana&amp;#39;, &amp;#39;oringen&amp;#39;] var x,i for(i = 0; i &amp;lt;= arr.length; i++) { x = arr[i] console.log(x) } 3. 用 break 终止 for 循环 var x = 0; for ( ; ; ) { // 将无限循环下去 if (x &amp;gt; 100) { console.log(x) break; // 通过if判断来退出循环 } x ++; } 4. for&amp;hellip;in 可以把一个对象对属性循环遍历出来&#xA;var person = { name: &amp;#39;jack&amp;#39;, age: 20, city: &amp;#39;beijing&amp;#39; }; for(var i in person) { console.log(i) console.log(person[i]) } var i in person会把 person 里面所有对属性遍历，然后通过console.log(i)可以把属性名打印出来，console.log(person[i])可以把属性值打印出来&#xA;如果对一个数组进行这样的操作，就可以把数组元素对索引打印出来，打印结果是字符串形式&#xA;5. while 循环 while循环适用于忽视判断条件的情况，for适用于明确了初始条件和结束条件的情况&#xA;比如要计算 1-100 之间的寄数和，可以用while循环&#xA;var x = 0 var n = 99 while (n &amp;gt; 0) { x = x + n n = n - 2 } x 在变量内部，n 不断自减，直接 n=-1，不满足判断条件，此时退出循环&#xA;6. do&amp;hellip;while do...while循环是先循环，然后再判断条件，所以不论条件是否满足，do...while至少循环一次，这是它与for和while的区别&#xA;比如：&#xA;var n = 0 do{ n = n + 1 }while(n &amp;gt; 1) n;&#x9;//1 先定义n=0，然后执行n=n+1，所以n=1，再判断条件，当 n&amp;gt;1 的时候执行，不符合，退出循环，控制台输出n，结果为 1&#xA;七、Map 和 Set 1. Map Map是一组键值对的结构，具有极快的查找速度&#xA;只要我们定义一个属性名和属性值对应的数组，就可以从这个数组里面通过 name 直接查找数据&#xA;var m = new Map([[&amp;#39;jack&amp;#39;, 95], [&amp;#39;Bob&amp;#39;, 94], [&amp;#39;linda&amp;#39;, 93]]) m.get(&amp;#39;jack&amp;#39;) 首先，要初始化一个Map数组&#xA;var m = new Map();&#x9;//空map m.set(&amp;#39;jack&amp;#39;, 95)&#x9;//添加一个新的键值对&#x9;key-value m.has(&amp;#39;jack&amp;#39;)&#x9;//检查是否存在 &amp;#39;&#x9;jack&amp;#39;key m.get(&amp;#39;jack&amp;#39;)&#x9;//获取&amp;#39;jack&amp;#39;对应的数据&#x9;value m.delete(&amp;#39;jack&amp;#39;)&#x9;//删除&amp;#39;jack&amp;#39;键值对&#x9;key-value m.get(&amp;#39;jack&amp;#39;)&#x9;//undefined 一个 key 只能对应一个 value，所以如果重复赋值的话，后面的数据会把前面的数据覆盖掉&#xA;var m = new Map(); m.set(&amp;#39;Adam&amp;#39;, 67); m.set(&amp;#39;Adam&amp;#39;, 88); m.get(&amp;#39;Adam&amp;#39;); // 88 2. Set set中值储存key，不储存value，而且在set中，key不能重复，如果重复了，会自动忽略掉重复&#xA;首先，创建一个空的set&#xA;var m = new Set()&#x9;//空set m.add(1)&#x9;//添加一个key m.delete(1)&#x9;//删除一个key m&#x9;//控制台输入［ ］空数组，没有数据 </description>
    </item>
  </channel>
</rss>
