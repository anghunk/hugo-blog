<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
	<title>Js - 子舒的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/tags/js/index.xml" title="子舒的博客">

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="topbar">
		<a class="topbar__link" href="/" title="子舒的博客" rel="sidebar">
			<div class="topbar__item topbar__text">
					<div class="topbar__title">子舒的博客</div>
					<div class="topbar__tagline">我的独立博客，记录了很多东西，随笔、周刊、笔记等，欢迎访问！</div>
				</div>
		</a>
	</div>
		
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Js</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/220.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">值传递和引用传递、深拷贝和浅拷贝</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2024-03-01T00:00:00Z">2024-03-01</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 把一个值赋给两个变量，修改一个变量时，另一个变量也会修改。
原因分析
this.a = res.data; this.b = res.data; 同时给两个变量 a 和 b 赋值时，修改 a 的内容，打印 b 结果是一样的，因为这里的赋值是属于引用传递的，把 res.data 这个地址赋给 a 和 b，当修改 a 时，res.data 会同步变动，导致 b 也发生了改变。
这种赋值方式也被称为浅拷贝，当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
解决方案
this.a = JSON.parse(JSON.stringify(res.data)); this.b = JSON.parse(JSON.stringify(res.data)); 使用 JSON.parse 和 JSON.stringify，将他变成一个常量值，这时再赋值给 a 和 b 的时候，就属于值传递了，这种赋值方式也叫做深拷贝，每个对象都对应一个新的空间，和其他对象互不影响。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/218.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">无法从非 EcmaScript 模块导入命名导出</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2024-02-23T00:00:00Z">2024-02-23</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/markdown-it/markdown-it
markdown-it 是一个基于 vue 的解析 markdown 语法的库。
在 vue 中引入 markdown-it 模块时遇到一个问题，dev 开发运行时报出以下错误，无法从非 EcmaScript 模块导入命名导出。
# shell error in ./node_modules/markdown-it/lib/common/utils.mjs Can&#39;t import the named export &#39;P&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&#39;t import the named export &#39;decode&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&#39;t import the named export &#39;decode&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/common/utils.mjs Can&#39;t import the named export &#39;decodeHTML&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/rules_inline/entity.mjs Can&#39;t import the named export &#39;decodeHTML&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&#39;t import the named export &#39;encode&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&#39;t import the named export &#39;format&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&#39;t import the named export &#39;format&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&#39;t import the named export &#39;parse&#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&#39;t import the named export &#39;parse&#39; from non EcmaScript module (only default export is available) 导致 import 该库出现错误，解决方案需要修改 vue.config.js
// vue.config.js module.exports = { configureWebpack: { module: { rules: [{ test: /\.mjs$/, include: /node_modules/, type: &#34;javascript/auto&#34; }] } }, }; 参考文献：https://github.com/vuejs/pinia/issues/675
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/194.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">hugo 纯静态编写一个字数统计脚本</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2023-05-13T00:00:00Z">2023-05-13</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		早上起来的时候看到微信群中有博友分享自己的建站时间，聊着聊着说到总字数上面，这时我才发现我的网站没有统计的地方，索性就自己写一个吧，因为是静态博客，所以不涉及后端、服务器等，只用前端的方式来解决。
这里需要借助我之前的一篇文章，《用原生 js 给网站写个搜索功能》，里面有提到如何生成一个文章列表 json 文件，这里我们会用到这个文件 index.json。
写一个 ajax 方法，让浏览器遍历每个页面。
$(document).ready(function () { $.ajax({ url: &#39;/index.json&#39;, type: &#39;get&#39;, dataType: &#39;json&#39;, success: function (data) { const pageUrls = data; const totalNum = pageUrls.length; $(&#39;#totalNum&#39;).html(totalNum); let totalWords = 0; pageUrls.forEach(urlObj =&gt; { $.get(urlObj.permalink, function(data) { const content = data.replace(/(&lt;([^&gt;]+)&gt;)/gi, &#34; &#34;).replace(/[^\w\s]/gi, &#34; &#34;); const words = content.split(&#34; &#34;); const wordCount = words.filter(word =&gt; word !== &#34;&#34;).length; totalWords += wordCount; $(&#39;#totalWords&#39;).html(totalWords); }); }); }, error: function () { console.log(&#39;error&#39;) } }) }); 我是将信息放在我的 关于 页面下。
经过脚本统计，我已经写了 &lt;span id=&#34;totalNum&#34;&gt;&lt;/span&gt; 篇文章，总共 &lt;span id=&#34;totalWords&#34;&gt;&lt;/span&gt; 个字。 &lt;!-- 经过脚本统计，我已经写了 164 篇文章，总共 97577 个字。 --&gt; 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/189.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">用原生 js 给网站写个搜索功能</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2023-03-17T00:00:00Z">2023-03-17</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文也算是一篇教程，可以给 hugo 网站加个搜索功能，并且实现热更新，体验感更好。
如果是其他程序，只需要按照特定的模板生成以下格式的文件即可，主要代码从 第 2 部分 开始，第一章节写的是如何用 hugo 输出文章列表 json 文件。
title 是文章标题，permalink 是文章链接。
[{ &#34;permalink&#34;: &#34;&#34;, &#34;title&#34;: &#34;&#34; }, { &#34;permalink&#34;: &#34;&#34;, &#34;title&#34;: &#34;&#34; }] 1. hugo 模板生成文章列表 json 文件 在 layouts 文件夹下新建 index.json 文件，模板内容如下：
其中第 2 行最后面的 &quot;blog&quot; 是你文章文件夹的名称。大部分是 posts 等等，这里是我个人的名称。
{{- $.Scratch.Set &#34;posts&#34; slice -}} {{- range where .Site.RegularPages &#34;Type&#34; &#34;blog&#34; -}} {{- $.Scratch.Add &#34;posts&#34; (dict &#34;title&#34; .Title &#34;permalink&#34; .Permalink) -}} {{- end -}} {{- $.Scratch.Get &#34;posts&#34; | jsonify -}} 按照这个模板，hugo 本地预览可以打开 http://localhost:1313/index.json 查看，如果输出了一些数据如下图，说明你成功了。
2. js 代码 在 /layouts/_default 新建一个模板文件 search.html，大致的结构参考其他模板文件，然后写入我们需要的内容。
首先是一个简单的 html 结构，给 input 绑定一个事件。
&lt;form class=&#34;search&#34;&gt; &lt;input type=&#34;text&#34; id=&#34;searchTerm&#34; name=&#34;searchTerm&#34; autocomplete=&#34;off&#34; oninput=&#34;initiateSearch()&#34;&gt; &lt;/form&gt; &lt;div id=&#34;resultsContainer&#34;&gt;请输入关键词进行搜索...&lt;/div&gt; 然后通过一个 get 请求获取 json 文件，传入关键词参数，生成搜索列表。
&lt;script&gt; function search(jsonData, searchTerm) { let results = []; for (let i = 0; i &lt; jsonData.length; i++) { for (let property in jsonData[i]) { if (jsonData[i].hasOwnProperty(property) &amp;&amp; jsonData[i][property].toString().indexOf(searchTerm) &gt; -1) { results.push(jsonData[i]); break; } } } return results; } function displayResults(searchResults) { let container = document.getElementById(&#34;resultsContainer&#34;); container.innerHTML = &#34;&#34;; if (searchResults.length &gt; 0) { for (let i = 0; i &lt; searchResults.length; i++) { let resultDiv = document.createElement(&#34;div&#34;); let resultTitle = document.createElement(&#34;a&#34;); resultTitle.innerText = searchResults[i].title; resultTitle.setAttribute(&#39;href&#39;, searchResults[i].permalink) resultDiv.appendChild(resultTitle); container.appendChild(resultDiv); } } else { let noResultsMessage = document.createElement(&#34;p&#34;); noResultsMessage.innerText = &#34;没有找到搜索结果。&#34;; container.appendChild(noResultsMessage); } } function initiateSearch() { let searchTerm = document.getElementById(&#34;searchTerm&#34;).value; let xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;/index.json&#39;, true); xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { let jsonData = JSON.parse(xhr.responseText); let searchResults = search(jsonData, searchTerm); displayResults(searchResults); } }; xhr.send(); } &lt;/script&gt; 然后再在 /content 新建一个 search.md 文件调用该模板即可。
--- slug: search title: 搜索 layout: search --- 写了一个基础的样式，可以直接使用。
.search { width: 100%; display: flex; align-items: center; height: 36px; } .search #searchTerm { width: 100%; height: 100%; outline: none; border: none; padding: 0 15px; box-shadow: 1px 2px 10px rgba(0, 0, 0, 0.1); } #resultsContainer { margin-top: 20px; } #resultsContainer div { margin-bottom: 10px; margin: 0; } #resultsContainer div a { display: block; width: 100%; padding: 6px 10px; transition: all 0.1s linear; border-radius: 4px; } #resultsContainer div a:hover { background: #f3f3f3; } 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/181.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">利用 memos 生成的在线动态列表</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2023-01-09T00:00:00Z">2023-01-09</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		memos 是一个具有知识管理和社交功能的开源自托管备忘录中心。
Github 地址：https://github.com/usememos/memos
可以用它本身提供的 api，然后结合静态博客，做成一个在线的动态列表，类似于朋友圈功能。
接口 url 有固定的格式，openId 是每个用户自动生成的。
其次我又写了两个方法，一个是时间戳转成正常时间格式，一个是利用正则删去内容中多余的标签。
将下面代码复制到你想显示的页面编辑，只需修改 openId，提供了一个基础的样式，如果有其他优化方案，欢迎指出。
由于接口中带了用户密钥，建议完成代码后将 js 加密再引入，不然可能会有一定的安全风险。
推荐网址：https://tool.lu/js/
&lt;!-- 结构和 css --&gt; &lt;div class=&#34;sslist&#34;&gt;&lt;/div&gt; &lt;style&gt; .sslist-item { padding: 10px 10px 20px; margin-bottom: 20px; border-radius: 2px; background: #f3f3f3; box-shadow: 1px 2px 4px rgba(0, 0, 0, .2); transition: all 0.2s linear; animation: up 1s forwards; transform: translateY(20px); opacity: 0; } @keyframes up { 0% { transform: translateY(20px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } } .sslist-item:hover { background: #eee; } .sslist-item .sslist-date { opacity: 0.6; margin: 0; font-size: 15px; margin-bottom: 5px; } &lt;/style&gt; // 调用接口的 js 方法 function memosShow() { var memosStr = &#34;&#34;; var openId = &#34;xxx&#34;; $.ajax({ url: &#34;https://memos.zburu.com/api/memo?openId=&#34; + openId + &#34;&amp;tag=说说&#34;, type: &#34;get&#34;, dataType: &#34;json&#34;, success: function (data) { // 生成数组 const sslist = data.data; for (let i = 0; i &lt; sslist.length; i++) { const element = sslist[i]; // 把时间戳转为正常时间格式 2023-01-9 13:17:12 var date = new Date(element.createdTs * 1000); Y = date.getFullYear() + &#34;-&#34;; M = (date.getMonth() + 1 &lt; 10 ? &#34;0&#34; + (date.getMonth() + 1) : date.getMonth() + 1) + &#34;-&#34;; D = (date.getDate() &lt; 10 ? &#34;0&#34; + date.getDate() : date.getDate()) + &#34; &#34;; h = date.getHours() + &#34;:&#34;; m = date.getMinutes() + &#34;:&#34;; s = date.getSeconds(); const createdTsNew = Y + M + D + h + m + s; sslist[i].createdTs = createdTsNew; // 利用js正则删去内容前的标签字符 const contentNew = element.content.slice(4); sslist[i].content = contentNew; } $.each(data.data, function (i, item) { list = &#34;&lt;div class=&#39;sslist-item&#39;&gt;&#34; + &#34;&lt;p class=&#39;sslist-date&#39;&gt;&#34; + item.createdTs + &#34;&lt;/p&gt;&#34; + item.content + &#34;&lt;/div&gt;&#34;; memosStr += list; }), $(&#34;.sslist&#34;).html(memosStr); }, error: function () { console.log(&#34;error&#34;); } }); } memosShow(); 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/180.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">分享一个页面点击特效</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2023-01-06T00:00:00Z">2023-01-06</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击页面时可以弹出随机颜色小心心，目前我的网站就使用了这个特效。
直接将下面的代码复制到引入的 js 文件中即可，不用进行其他配置。
!function(e,t,a){function n(){c(&#34;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&#34;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&#34;left:&#34;+d[e].x+&#34;px;top:&#34;+d[e].y+&#34;px;opacity:&#34;+d[e].alpha+&#34;;transform:scale(&#34;+d[e].scale+&#34;,&#34;+d[e].scale+&#34;) rotate(45deg);background:&#34;+d[e].color+&#34;;z-index:99999&#34;);requestAnimationFrame(r)}function o(){var t=&#34;function&#34;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&#34;div&#34;);a.className=&#34;heart&#34;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&#34;style&#34;);a.type=&#34;text/css&#34;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&#34;head&#34;)[0].appendChild(a)}function s(){return&#34;rgb(&#34;+~~(255*Math.random())+&#34;,&#34;+~~(255*Math.random())+&#34;,&#34;+~~(255*Math.random())+&#34;)&#34;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/175.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">js 中 [ ]&#43;{ } 和 { }&#43;[ ] 的区别</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-11-15T00:00:00Z">2022-11-15</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		[ ]+{ }：一个数组加一个对象。
加法会进行隐式类型转换，规则是调用其 valueOf() 或 toString() 以取得一个非对象的值 (primitive value)。
如果两个值中的任何一个是字符串，则进行字符串串接，否则进行数字加法。[ ] 和 { } 的 valueOf() 都返回对象自身，所以都会调用 toString()，最后的结果是字符串串接。
[ ].toString() 返回空字符串，({ }).toString() 返回 &ldquo;[object Object]&quot;，最后的结果就是 &ldquo;[object Object]&quot;。
{ }+[ ]：看上去应该和上面一样。
但是{ }除了表示一个对象之外，也可以表示一个空的 bock。在 [ ] + { }中，[ ]被解析为数组，因此后续的 + 被解析为加法运算符，而{ }就解析为对象。
但在{ } + [ ]中，{ }被解析为空的 bock，随后的 + 被解析为正号运算符。即实际上成了：{∥empty block}+[ ]，即对一个空数组执行正号运算，实际上就是把数组转型为数字。首先调用.valueOf()，返回数组自身，不是 primitive value，因此继续调用 [ ].toString()，返回空字符串。空字符串转型为数字，返回 0，即最后的结果。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/171.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">localStorage 的相关运用</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-10-20T00:00:00Z">2022-10-20</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		localStorage 是浏览器自带的一个属性，只读的 localStorage 属性允许你访问一个 Document 源（origin）的对象 Storage；存储的数据将保存在浏览器会话中。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除。
应注意，无论数据存储在 localStorage 还是 sessionStorage，它们都特定于页面的协议。
另外，localStorage 中的键值对总是以字符串的形式存储。 (需要注意，和 js 对象相比，键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).
localStorage 的使用也非常简单，分为存入和读取，可以将其绑定在事件方法中。
// 存入 const arr= 100; localStorage.setItem(&#34;key&#34;, JSON.stringify(arr)); // 读取 const arr = JSON.parse(localStorage.getItem(&#34;key&#34;)); 这里 &quot;key&quot; 指的是存到浏览器中的参数名，arr 则是参数值。
localStorage.setItem(&quot;key&quot;, JSON.stringify(arr)); 这个方法就是将数组 arr 存到了浏览器的 localStorage 中，它的参数名叫 key const arr = JSON.parse(localStorage.getItem(&quot;key&quot;)); 就是读取浏览器中参数名为 key 的参数值。 比如静态保存某个设置参数，可以将其写入数组中，然后通过 localStorage 存储，原本刷新就会显示默认设置，现在可以在每次刷新的适合读取存入的参数。
在一些场景下非常好用，比如开发一个油猴脚本等等。
清除 localStorage，分为清除所以的存储值和清除某个特定的 key。
// 清除本地存储中的所有值 localStorage.clear(); // 本地存储中删除特定项 localStorage.removeItem(key); 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/168.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">将数组中多个对象的同名属性值取出合并成新数组</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-09-26T00:00:00Z">2022-09-26</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务中需求的方法，接口返回一个数组，里面包含了大量的对象，具有同名的属性名，比较常见。但是需要将其中参数为 name 的属性值全部取出，合并成数组。
const num = [ { id: 1, name: &#39;abc&#39;, }, { id: 2, name: &#39;xyz&#39;, } ] function getFields(arrnum, field) { const resnum = []; for (let i = 0; i &lt; arrnum.length; ++i) resnum.push(arrnum[i][field]); return resnum; } const result = getFields(num, &#34;name&#34;); console.log(result); // [&#39;abc&#39;, &#39;xyz&#39;] console.log(result.join(&#39; &#39;)); // &#34;abc xyz&#34; 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/145.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">人民币小写转大写</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2022-06-24T00:00:00Z">2022-06-24</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个有趣的 demo
this.smalltoBIG(43533534.78); //肆仟叁佰伍拾叁万叁仟伍佰叁拾肆元柒角捌分 smalltoBIG (n) { var fraction = [&#39;角&#39;, &#39;分&#39;]; var digit = [&#39;零&#39;, &#39;壹&#39;, &#39;贰&#39;, &#39;叁&#39;, &#39;肆&#39;, &#39;伍&#39;, &#39;陆&#39;, &#39;柒&#39;, &#39;捌&#39;, &#39;玖&#39;]; var unit = [ [&#39;元&#39;, &#39;万&#39;, &#39;亿&#39;],[&#39;&#39;, &#39;拾&#39;, &#39;佰&#39;, &#39;仟&#39;] ]; var head = n &lt; 0 ? &#39;欠&#39; : &#39;&#39;; n = Math.abs(n); var s = &#39;&#39;; for (var i = 0; i &lt; fraction.length; i++) { s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &#39;&#39;); } s = s || &#39;整&#39;; n = Math.floor(n); for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) { var p = &#39;&#39;; for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) { p = digit[n % 10] + unit[1][j] + p; n = Math.floor(n / 10); } s = p.replace(/(零.)*零$/, &#39;&#39;).replace(/^$/, &#39;零&#39;) + unit[0][i] + s; } return head + s.replace(/(零.)*零元/, &#39;元&#39;).replace(/(零.)+/g, &#39;零&#39;).replace(/^整$/, &#39;零元整&#39;); }, 
	</div>
</article>

</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/3</span>
	<a class="pagination__item pagination__item--next btn" href="/tags/js/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		<div class="footer__copyright">
			&copy; 2024 子舒的博客, 
			使用 hugo 构建
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

</body>
</html>