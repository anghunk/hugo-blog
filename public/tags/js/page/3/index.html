<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
	<title>Js - 子舒的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/tags/js/index.xml" title="子舒的博客">

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="topbar">
		<a class="topbar__link" href="/" title="子舒的博客" rel="sidebar">
			<div class="topbar__item topbar__text">
					<div class="topbar__title">子舒的博客</div>
					<div class="topbar__tagline">The Tao that is utterable is not the eternal Tao</div>
				</div>
		</a>
	</div>
		
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Js</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/22.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">在 js 中运算不能随便把 value 属性定义成变量</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-18T00:00:00Z">2020-11-18</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写一个小 demo 的时候，无意中发现定义变量的时候直接写入 value，会导致获取不到数据，或者获取的不是我们想要的内容，在 js 中运算不能随便把 value 属性定义成变量
先看一段代码
&lt;input type=&#34;text&#34;&#34; id=&#34;a&#34;&gt; &lt;span&gt;*&lt;/span&gt; &lt;input type=&#34;text&#34; id=&#34;b&#34;&gt; &lt;input type=&#34;button&#34; value=&#34;=&#34; onclick=&#34;beto()&#34;&gt; &lt;input type=&#34;text&#34; id=&#34;sub&#34; disabled&gt; &lt;script&gt; function beto() { var a = document.getElementById(&#39;a&#39;).value var b = document.getElementById(&#39;b&#39;).value var sub = document.getElementById(&#39;sub&#39;).value sub = a + b } &lt;/script&gt; 就这么一看，逻辑貌似没有问题，获取 a 和 b 的 value，乘法运算，然后输出 sub
但是放在浏览器运行的时候，发现完全没有反应
为什么呢？
（假装思考五分钟&hellip;）
因为 sub.value 不能直接定义在变量中
// 先定义 id 为 sub 的 input 框 var sub = document.getElementById(&#39;sub&#39;) // 然后在运算的时候在直接使用 sub.value sub.value = a * b 顺手放一个写 demo 时候用的简易计算器
&lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;简易计算器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&#34;text&#34;&#34; id=&#34;a&#34;&gt; &lt;select id=&#34;c&#34;&gt; &lt;option value=&#34;+&#34;&gt;+&lt;/option&gt; &lt;option value=&#34;-&#34;&gt;-&lt;/option&gt; &lt;option value=&#34;*&#34;&gt;*&lt;/option&gt; &lt;option value=&#34;/&#34;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&#34;text&#34; id=&#34;b&#34;&gt; &lt;input type=&#34;button&#34; value=&#34;=&#34; onclick=&#34;beto()&#34;&gt; &lt;input type=&#34;text&#34; id=&#34;sub&#34; disabled&gt; &lt;script&gt; function beto() { var a = document.getElementById(&#39;a&#39;).value var b = document.getElementById(&#39;b&#39;).value var c = document.getElementById(&#39;c&#39;).value var sub = document.getElementById(&#39;sub&#39;) switch(c) { case &#34;+&#34;: sub.value = parseInt(a) + parseInt(b); break; case &#34;-&#34;: sub.value = parseInt(a) - parseInt(b); break; case &#34;*&#34;: sub.value = parseInt(a) * parseInt(b); break; case &#34;/&#34;: sub.value = parseInt(a) / parseInt(b); break; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/21.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">事件监听函数，以及事件的捕获和冒泡机制</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-17T00:00:00Z">2020-11-17</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件，事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流
函数事件 事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件
事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流
true 是捕获，false 是冒泡，默认为冒泡事件
1.addEventListener()－－添加事件监听函数 给元素添加一个事件，假如有多个事件，不会覆盖，会依次执行
&lt;div id=&#34;demo&#34;&gt;dom&lt;/div&gt; &lt;script&gt; document.getElementById(&#39;demo&#39;).addEventListener(&#34;click&#34;, myfun) document.getElementById(&#39;demo&#39;).addEventListener(&#34;click&#34;, myfun1) function myfun() { console.log(&#39;事件监听函数&#39;) } function myfun1() { console.log(&#39;addEventListener&#39;) } &lt;/script&gt; 注意： 1.这里有一个细节，addEventListener() 里面有两个参数，第一个表示触发的条件，第二个表示触发的事件 正常情况下，第二个参数直接写函数名并且不加参数()，如果加了参数()则表示立即执行，不需要触发第一个参数要求的条件
2.在这里绑定事件的时候，事件名不能和定义的变量名一样，否则无效
2.removeEventListener()－－移除事件监听函数 下面这个 demo，当鼠标在 div 中移动的时候，出现随机数，点击按钮后，移除事件监听函数
&lt;!-- css --&gt; &lt;style&gt; #demo { width: 100px; height: 100px; border: 1px solid #000; } &lt;/style&gt; &lt;!-- html --&gt; &lt;div id=&#34;demo&#34;&gt;&lt;/div&gt; &lt;input type=&#34;button&#34; value=&#34;点击移除&#34; onclick=&#34;remove()&#34;&gt; &lt;div id=&#34;show&#34;&gt;&lt;/div&gt; &lt;!-- js --&gt; &lt;script&gt; document.getElementById(&#39;demo&#39;).addEventListener(&#34;mousemove&#34;, myfun) function myfun() { document.getElementById(&#39;show&#39;).innerHTML = Math.random() } function remove() { document.getElementById(&#39;demo&#39;).removeEventListener(&#34;mousemove&#34;, myfun) } &lt;/script&gt; 3.利用事件的捕获和冒泡做点事情 addEventListener() 和 removeEventListener() 其实拥有三个参数，刚才说过了，第一个表示触发条件，第二个表示触发事件，第三个参数正常情况下可以省略，但是要知道它代表的意思
用布尔值来表示，true 或者 false，默认是 false
true 表示在捕获阶段调用事件处理程序 false 表示在冒泡阶段调用事件处理程序 根据图片可以看出，捕获阶段要先于冒泡阶段，因此，true 事件要先于 flase 事件触发，多个 true 事件按顺序触发，多个 false 事件，写在后面的先触发
结论：写在前面的 true 事件 &gt; 写在后面的 true 事件 &gt; 写在后面的 false 事件 &gt; 写在前面的 false 事件
因此，利用这个参数，可以控制同一个元素的不同事件触发的顺序
&lt;div id=&#34;out&#34;&gt; &lt;p&gt;最外面&lt;/p&gt; &lt;div id=&#34;middle&#34;&gt; &lt;div id=&#34;inner&#34;&gt;最里面&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 第一种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：inner-------middle------out out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},false); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第二种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out------middle-------inner out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},true); &lt;/script&gt; &lt;!-- 第三种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out------inner-------middle out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第四种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out-------middle------inner out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第五种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：middle-------inner------out out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},false); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第六种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out-------inner------middle out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},true); &lt;/script&gt; 4.事件处理程序 HTML 事件处理程序 &lt;button onclick=&#34;test()&#34;&gt;测试&lt;/button&gt; &lt;script&gt; function test() { alert(&#34;HTML 事件处理程序&#34;); } &lt;/script&gt; 1.优点：事件处理程序中的代码，能够访问全局作用域中的任何变量 2.缺点：时差问题、扩展的作用域链在不同浏览器中会导致不同结果、html 代码与 js 代码高度耦合
DOM0 级事件处理程序 &lt;button id=&#34;btn&#34;&gt;测试&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#34;btn&#34;); btn.onclick = function test() { alert(&#34;DOM0 级事件处理程序&#34;); } &lt;/script&gt; 1.优点：代码简单，浏览器兼容性好，解决了 html 代码和 js 代码的高度耦合问题 2.缺点：一个元素只能绑定一个事件处理函数，只会在事件冒泡中运行
DOM2 级事件处理程序 该级别的事件处理程序，运用的就是事件捕获和冒泡机制
&lt;button id=&#34;btn&#34;&gt;测试&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#34;btn&#34;); // 事件监听 btn.addEventListener(&#34;click&#34;, function() { alert(&#34;DOM2 级事件处理程序，我在捕获阶段执行&#34;); }, true); btn.addEventListener(&#34;click&#34;, function() { alert(&#34;DOM2 级事件处理程序，我在冒泡阶段执行&#34;); }, false); // 移除事件监听 var fun = function() { alert(&#34;我要被移除了&#34;); } btn.addEventListener(&#34;click&#34;, fun, false); btn.removeEventListener(&#34;click&#34;, fun, false); &lt;/script&gt; 1.优点：同时支持事件处理的捕获和冒泡阶段，并且一个元素可以绑定多个处理函数 2.缺点：IE 不支持
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/17.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">有关 js 函数，方法的一些补充总结</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-14T00:00:00Z">2020-11-14</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型，构造函数，原型和原型链的一些讲解补充
一、数据类型 1.5 个基本类型 string number boolean undefined 未定义 null 值为空 symbol 表示一个符号，符号类型是唯一的并且是不可修改的
最常见的还是前三种，字符串，数字，布尔值
2.常见的引用类型 引用类型是一种数据结构，用于将数据和功能组织在一起
对象－Object, 数组－Array, 函数－Function, 正则－RegExp, 日期－Date 等
二、函数 1.什么是函数？ 具有独立功能的代码块，在 js 中使用 function 关键字定义函数 让代码结构更加清晰，提高代码可用性 js 函数的分类：自定义函数和系统函数 2.自定义函数 有一种匿名函数，没有名字的函数，创建闭包，避免造成全局变量的污染
匿名自执行函数
概念：匿名函数的定义完成后立即执行，执行函数表达式 作用：实现闭包和创建独立的命名空间 使用：分组操作符 ()，void 操作符，~操作符，! 操作符等等 使用场景：函数表达式，对象属性，事件，事件参数，返回值 定义完匿名函数后，一定要调用 // 函数表达式 window.onload = function() { let funcobj = function() { alert(&#34;函数表达式中的匿名函数&#34;) } funcobj(); } // 对象属性 window.onload = function() { let obj = { name: function() { alert(&#39;对象属性中的匿名函数&#39;) } } obj.name(); } 3.内置函数 放在全局下面叫做函数，放在对象里面被叫做方法，对象的方法
常规函数 alert() // 弹出框 confirm() // 弹出一个确认框 prompt() // 弹出一个输入框 isNaN() // 判断是否为数字 parseInt() // 将字符串或浮点数转换为整数 parseFloat() // 将字符串转换为整数或浮点数 eval() // 计算表达式的结果 数组函数 用for循环遍历数组
var arr = [1,2,3,4]; for(var i = 0; i&lt;arr.length; i++) { console.log(arr[i]) } // 输出 1,2,3,4 通过for in遍历数组
var arr = [1,2,3,4]; for (var i in arr) { console.log(arr[i]); } // 输出 1,2,3,4 // 增加 unshift() // 添加元素在数组首部，返回值是数组长度 push() // 添加元素在数组尾部，返回值是数组长度 conat() // 连接两个数组，返回值是连接后的数组 var arr1 = [1]; var arr2 = [2]; let arr = arr1.concat(arr2); console.log(arr); // [1,2] /*****************************************/ // 删除 pop() // 删除数组最后一个元素，返回值是删除的元素 shift() // 删除数组第一个元素，返回值是删除的元素 splice(a,b) // 删除指定位置a后的b个元素，返回值是删除的元素 slice(a,b) // 删除从a位置到b位置之间的元素 /*****************************************/ // 查找 indexOf() // 判断数组是否包含指定元素，存在返回元素，不存在返回-1 includes() // 判断数组是否包含指定元素，存在返回true，不存在返回false /*****************************************/ // 其他 sort() // 将数组按照规则排序 var arr1 = [4,5,6]; var arr2 = [1,2,3]; var arrAscSort = arr5.sort((a, b) =&gt; a-b); // 升序排序 console.log(arrAscSort); // [ 1, 1, 2, 3, 5, 6 ] var arrDescSort = arr5.sort((a, b) =&gt; b-a); // 降序排序 console.log(arrDescSort); // [ 6, 5, 3, 2, 1, 1 ] reerse() // 数组反转 var arr = [1,2,3,4,5,6]; // 直接通过reverse()方法调用 console.log(arr.reverse()) // [6,5,4,3,2,1] Array.from() // 将一串数据转换为数组形式 var str = &#39;将一串数据转换为数组形式&#39; console.log(Array.from(str)) // [&#34;将&#34;, &#34;一&#34;, &#34;串&#34;, &#34;数&#34;, &#34;据&#34;, &#34;转&#34;, &#34;换&#34;, &#34;为&#34;, &#34;数&#34;, &#34;组&#34;, &#34;形&#34;, &#34;式&#34;] Array.isArray() // 判断一个变量是否为数组 var str = &#39;将一串数据转换为数组形式&#39; console.log(Array.isArray(str)) // false 日期函数 Date() 获取时间
var time = new Date() // 获取当前时间 // Fri Nov 13 2020 20:21:35 GMT+0800 (中国标准时间) getFullYear() // 获取当前年份 getMonth() // 获取当月月份 -1 getDate() // 获取当天日期 getHours() // 获取当前小时 getMinutes() // 获取当前分钟 getSeconds() // 获取当前秒 getMilliseconds() // 获取当前毫秒 getTime() // 时间戳-获取1970年至今的毫秒数 设置时间
setYear() // 设置年份 setMonth() // 设置月份 setDate() // 设置日期 setHours() // 设置小时 setMinutes() // 设置分钟 setSeconds() // 设置秒 数学函数 Math 主要常用的数学函数方法
Math.abs() // 绝对值 Math.ceil() // 向上取整 Math.floor()// 向下取整 Math.round()// 四舍五入 Math.random() // 生成0-1之间的随机数 random() 的延伸用法－－－生成指定位的随机数
function getRandomNumber(min, max){ return Math.floor(Math.random()*(max - min)) + min; } console.log(getRandomNumber(1000, 9999)); 字符串函数 indexOf() // 查找字符串，返回索引值 var arr = [&#34;字&#34;, &#34;符&#34;, &#34;串&#34;, &#34;函&#34;, &#34;数&#34;] console.log(arr.indexOf(&#34;串&#34;)) // 2 split() // 将字符串按照指定的分隔符分割开来 var str = &#34;字符串函数&#34; console.log(str.split(&#39;&#39;)) // [&#34;字&#34;, &#34;符&#34;, &#34;串&#34;, &#34;函&#34;, &#34;数&#34;] trim() // 清除字符串两端的空格 var str = &#34; 字符串函数 &#34; console.log(str) // [ 字符串函数 ] console.log(str.trim()) // [字符串函数] match() // 按照制定规则查找值 var str = &#34;字符串函数字符串函数&#34; console.log(str.match(/字符串/)) // 字符串 document.write(str.match(/字符串/)) // 字符串 search() // 返回字符串 首次出现的位置 var str = &#34;字符串函数字符串函数&#34; console.log(str.search(&#39;串&#39;)) // 2 replace() // 替换指定的字符串 var str = &#34;字符串函数字符串函数&#34; console.log(str.replace(&#39;字&#39;,&#39;函&#39;)) // 函符串函数字符串函数 substring(a,b) // 从指定位置切割字符串，左闭右开 // 从索引a，截取到b var str = &#34;字符串函数字符串函数&#34; console.log(str.substring(0,3)) // 字符串 substr(a,b) // 从指定位置切指定个字符 // 从索引a开始，截取b个字符 var str = &#34;字符串函数字符串函数&#34; console.log(str.substr(0,3)) // 字符串 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/15.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">面向对象编程</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-11-12T00:00:00Z">2020-11-12</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
一、什么是面向对象编程 js 是基于原型的，基于面向对象编程
面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类
1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。
自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用
面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。
2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统
面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。
想要弄明白面向对象，需要先理解类和对象的概念
《什么是类和对象？》
二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = &#39;小明&#39;; person.age = 22; person.year = function() { console.log(this.name + &#39;今年&#39; + this.age + &#39;岁了！&#39;) }; person.year(); // 字面量 var student = { name: &#39;小明&#39;, age: 22, year: function () { console.log(this.name + &#39;今年&#39; + this.age + &#39;岁了！&#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出：
缺点：重复实例化对象，代码冗余高
2.工厂模式 window.onload = function() { function createObj(name, age) { var obj = new Object(); obj.name = name, obj.age = age, obj.year = function() { console.log(this.name + &#39;今年&#39; + this.age + &#39;岁了！&#39;) } return obj; } var obj = createObj(&#39;小明&#39;, 22); obj.year(); } // 小明今年22岁了！ 优点：解决重复实例化对象的问题 缺点：无法识别对象的类型，因为所有的实例都指向一个原型
3.构造函数 window.onload = function() { function Person(name, age) { this.name = name; this.age = age; this.year = function() { console.log(this.name + &#39;今年&#39; + this.age + &#39;岁了！&#39;) } } var student = new Person(&#39;小明&#39;, 22); student.year(); } // 小明今年22岁了！ 优点：可以识别对象的类型 缺点：多个实例重复创建方法，无法共享
4. 原型模式 window.onload = function() { function Par() {} Par.prototype = { constructor: &#39;Par&#39;, name: &#39;小明&#39;, age: 22, year: function() { console.log(this.name + &#39;今年&#39; + this.age + &#39;岁了！&#39;) } }; var son = new Par(); son.year(); } // 小明今年22岁了！ 缺点：所有实例共享他的属性和方法，不能传参和初始化属性值
5.混合模式 (推荐使用) 是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值
先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过 prototype 获取，有一个 constructor 属性，可以指向要操作的函数对象（构造函数）
比如constructor: Par，就代表下面这个原型方法指向Par()对象（构造函数）
window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + &#39;今年&#39; + this.age + &#39;岁了！&#39;); } }; var son = new Par(&#39;小明&#39;, 22) son.year(); } // 小明今年22岁了！ 三、原型，原型链 1.原型对象 函数对象都具有prototype属性，它指向函数的原型对象 (浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象 (构造函数) window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { // constructor指向对象 constructor: Par, year: function() { console.log(this.name + &#39;今年&#39; + this.age + &#39;岁了！&#39;); } }; var son = new Par(&#39;小明&#39;, 22) son.year(); /*********************************************/ console.log(Par.prototype) console.log(Par.prototype.constructor) /*********************************************/ } 通过控制台可以看到
构造函数的prototypr属性指向原型对象
原型对象的construcyor属性指向构造函数
当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ，它指向构造函数的原型对象 console.log(son.__proto__ === Par.prototype) // true 所有的构造函数的 prototype 都是 object 类型 console.log(typeof Par.prototype) // object Function 的 prototype 是一个空函数，所有内置函数的__proto__属性都指向这个空函数 console.log(Math.__proto__) 如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过delete方法将同名属性在实例（构造函数）中彻底删除 window.onload = function () { function Par(name) { this.name = name; } Par.prototype.name = &#34;张三&#34;; var son = new Par(&#34;李四&#34;); console.log(son.name); // 李四 console.log(son.__proto__.name); // 张三 // 使用 delete 删除实例的同名属性值 console.log(delete son.name); // true console.log(son.name); // 张三 } 通过hasOwnProperty(属性名)可以判断一个属性存在于构造函数中，还是原型对象中 true表示存在构造函数中；false表示存在原型对象中
console.log(Par.hasOwnProperty(name)); // false 操作符in，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可） window.onload = function () { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + this.age) } }; var son = new Par(&#39;xm&#39;, &#39;22&#39;) son.year(); console.log(&#39;name&#39; in Par); // true console.log(&#39;age&#39; in Par); // false } 同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样
参考:《对象中是否有某一个属性 in》https://www.cnblogs.com/IwishIcould/p/12333739.html
2.__proto__和 prototype 的区别 prototype属性只有函数对象上才有，而__proto__属性所有对象都有
prototype是由函数对象指向原型对象，而__proto__是由实例指向函数对象的原型对象
原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做原型链
3.继承 原型链继承 优点：父类原型定义的属性和方法可以复用 缺点：子类实例没有自己的属性，不能向父类传递参数
function test1() { function SuperType() { this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ]; this.property = true; } SuperType.prototype = { constructor : SuperType, // 保持构造函数和原型对象的完整性 age : 15, getSuperValue : function() { return this.property; } }; function SonType() { this.property = false; } // 重写子类的原型指向父类的实例：继承父类的原型 SubType.prototype = new SuperType(); SubType.prototype = { constructor : SubType, getSonType : function() { return this.property; } }; // 优点验证 let son = new SubType(); console.log(son.age); // 15 console.log(son.getSuperValue()); // false // 缺点验证 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] } // test1(); 构造函数继承 优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点 缺点：父类原型的属性和方法不可复用
function test2() { function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ] } SuperType.prototype = { constructor : SuperType, age : 18, showInfo : function() { return this.name; } }; function SubType() { // 父类调用 call() 或者 apply() 方法和子类共用同一个 this，实现子类实例属性的继承 SuperType.call(this, &#34;张三&#34;); } // 优点验证 let instance = new SubType(); instance.city.push(&#34;重庆&#34;); console.log(instance.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance1 = new SubType(); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] // 缺点验证 console.log(instance.age); // undefined instance.showInfo(); // son.showInfo is not a function } // test2(); 组合继承（推荐） 优点：原型的属性和方法可以复用，每个子类实例都有自己的属性 缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖
function test3() { function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ] } SuperType.prototype = { constructor : SuperType, showInfo : function() { console.log(this.name + &#34;今年&#34; + this.age + &#34;岁了&#34;); } }; function SubType(name, age) { // 1. 通过构造方法继承实现实例属性的继承 SuperType.call(this, name); this.age = age; } // 2. 通过原型链继承实现原型方法的继承 SubType.prototype = new SuperType(); // 优点验证 let instance = new SubType(&#34;张三&#34;, 15); instance.showInfo(); // 张三今年 15 岁了 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] } // test3(); 寄生组合继承（推荐） 优点：解决了组合继承的缺点，效率高 缺点：基本没有
function test4() { function inheritPrototype(subType, superType) { // 1. 继承父类的原型 var prototype = Object.create(superType.prototype); // 2. 重写被污染的 construct prototype.constructor = subType; // 3. 重写子类的原型 subType.prototype = prototype; } function SuperType(name) { this.name = name; this.city = [ &#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34; ]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); } // 优点验证 let instance = new SubType(&#34;张三&#34;, 15); instance.sayName(); // 张三 let instance1 = new SubType(); instance1.city.push(&#34;重庆&#34;); console.log(instance1.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;] let instance2 = new SubType(); console.log(instance2.city); // [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;] } // test4(); 4.ES6 新方法－－class 新的关键字class在 es6 开始被引入到 javascript 中来，class的目的就是让定义类更简单
用函数方法实现：
function Person(name) { this.name = name; } Person.prototype.hello = function () { console.log(&#39;Hello, &#39; + this.name + &#39;!&#39;); } var son = new Person(&#39;xm&#39;) son.hello(); // Hello, xm! 用class来实现：
class Person { constructor(name) { this.name = name; } hello() { console.log(&#39;Hello, &#39; + this.name + &#39;!&#39;); } } var son = new person(&#39;xm&#39;) son.hello(); // Hello, xm! 可以在看到，在定义class中，直接包含了构造函数constructor属性，和原型对象上的函数hello()方法，省略掉了function关键字
需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用class可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的
class 继承
用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Person派生一个PrimaryPerson需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：
class PrimaryPerson extends Person { constructor(name, grade) { super(name); // 记得用 super 调用父类的构造方法！ this.grade = grade; } myGrade() { alert(&#39;I am at grade &#39; + this.grade); } } 注意PrimaryPerson的定义也是通过 class 关键字实现的，而extends则表示原型链对象来自Person，子类的构造函数可能会和父类的不太相同
例如，PrimaryPerson需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
PrimaryPerson已经自动获得了父类Person的hello方法，我们又在子类中定义了新的myGrade方法。
ES6 引入的class和原有的JavaScript原型继承有什么区别呢？
实际上它们没有任何区别，class的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。
但是！
目前并不是所有的浏览器都支持class，所以在选择的时候一定要慎重！
	</div>
</article>

</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/tags/js/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/3</span>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 子舒的博客, 
			使用 hugo 构建
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

  <script>
    MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    id="MathJax-script"
    async
    src="https://gcore.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>
</body>
</html>