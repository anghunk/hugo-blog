<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Js on 子舒的博客</title>
    <link>https://zishu.me/tags/js/</link>
    <description>Recent content in Js on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Mar 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://zishu.me/tags/js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>值传递和引用传递、深拷贝和浅拷贝</title>
      <link>https://zishu.me/blog/220.html/</link>
      <pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/220.html/</guid>
      <description>vue 把一个值赋给两个变量，修改一个变量时，另一个变量也会修改。 原因分析 this.a = res.data; this.b = res.data; 同时给两个变量 a 和 b 赋值时，修改 a 的内容，打印 b 结果是一样的，因为这里的赋值是属于引用传递的，把 res.data 这个地址赋给 a 和 b，当修改 a 时，res.data 会同步变动，导致 b 也发生了改变。 这种赋值方式也被称为浅拷贝，当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。 解决方案 this.a = JSON.parse(JSON.stringify(res.data)); this.b = JSON.parse(JSON.stringify(res.data)); 使用 JSON.parse 和 JSON.stringify，将他变成一个常量值，这时再赋值给 a 和 b 的时候，就属于值传递了，这种赋值方式也叫做深拷贝，每个对象都对应一个新的空间，和其他对象互不影响。</description>
    </item>
    <item>
      <title>无法从非 EcmaScript 模块导入命名导出</title>
      <link>https://zishu.me/blog/218.html/</link>
      <pubDate>Fri, 23 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/218.html/</guid>
      <description>https://github.com/markdown-it/markdown-it markdown-it 是一个基于 vue 的解析 markdown 语法的库。 在 vue 中引入 markdown-it 模块时遇到一个问题，dev 开发运行时报出以下错误，无法从非 EcmaScript 模块导入命名导出。 # shell error in ./node_modules/markdown-it/lib/common/utils.mjs Can&amp;#39;t import the named export &amp;#39;P&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;decode&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;decode&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/common/utils.mjs Can&amp;#39;t import the named export &amp;#39;decodeHTML&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/rules_inline/entity.mjs Can&amp;#39;t import the named export &amp;#39;decodeHTML&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;encode&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;format&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;format&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;parse&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;parse&amp;#39; from non EcmaScript module (only default export is available) 导致 import 该库出现错误，解决方案需要修改 vue.config.js // vue.config.js module.exports = { configureWebpack: { module: { rules: [{ test: /\.mjs$/, include: /node_modules/, type: &amp;#34;javascript/auto&amp;#34; }] } }, }; 参考文献：https://github.com/vuejs/pinia/issues/675</description>
    </item>
    <item>
      <title>hugo 纯静态编写一个字数统计脚本</title>
      <link>https://zishu.me/blog/194.html/</link>
      <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/194.html/</guid>
      <description>早上起来的时候看到微信群中有博友分享自己的建站时间，聊着聊着说到总字数上面，这时我才发现我的网站没有统计的地方，索性就自己写一个吧，因为是静态博客，所以不涉及后端、服务器等，只用前端的方式来解决。 这里需要借助我之前的一篇文章，《用原生 js 给网站写个搜索功能》，里面有提到如何生成一个文章列表 json 文件，这里我们会用到这个文件 index.json。 写一个 ajax 方法，让浏览器遍历每个页面。 $(document).ready(function () { $.ajax({ url: &amp;#39;/index.json&amp;#39;, type: &amp;#39;get&amp;#39;, dataType: &amp;#39;json&amp;#39;, success: function (data) { const pageUrls = data; const totalNum = pageUrls.length; $(&amp;#39;#totalNum&amp;#39;).html(totalNum); let totalWords = 0; pageUrls.forEach(urlObj =&amp;gt; { $.get(urlObj.permalink, function(data) { const content = data.replace(/(&amp;lt;([^&amp;gt;]+)&amp;gt;)/gi, &amp;#34; &amp;#34;).replace(/[^\w\s]/gi, &amp;#34; &amp;#34;); const words = content.split(&amp;#34; &amp;#34;); const wordCount = words.filter(word =&amp;gt; word !== &amp;#34;&amp;#34;).length; totalWords += wordCount; $(&amp;#39;#totalWords&amp;#39;).html(totalWords); }); }); }, error: function () { console.log(&amp;#39;error&amp;#39;) } }) }); 我是将信息放在我的 关于 页面下。 经过脚本统计，我已经写了 &amp;lt;span id=&amp;#34;totalNum&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 篇文章，总共 &amp;lt;span id=&amp;#34;totalWords&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 个字。 &amp;lt;!-- 经过脚本统计，我已经写了 164 篇文章，总共 97577 个字。 --&amp;gt;</description>
    </item>
    <item>
      <title>用原生 js 给网站写个搜索功能</title>
      <link>https://zishu.me/blog/189.html/</link>
      <pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/189.html/</guid>
      <description>本文也算是一篇教程，可以给 hugo 网站加个搜索功能，并且实现热更新，体验感更好。 如果是其他程序，只需要按照特定的模板生成以下格式的文件即可，主要代码从 第 2 部分 开始，第一章节写的是如何用 hugo 输出文章列表 json 文件。 title 是文章标题，permalink 是文章链接。 [{ &amp;#34;permalink&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;&amp;#34; }, { &amp;#34;permalink&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;&amp;#34; }] 1. hugo 模板生成文章列表 json 文件 在 layouts 文件夹下新建 index.json 文件，模板内容如下： 其中第 2 行最后面的 &amp;quot;blog&amp;quot; 是你文章文件夹的名称。大部分是 posts 等等，这里是我个人的名称。 {{- $.Scratch.Set &amp;#34;posts&amp;#34; slice -}} {{- range where .Site.RegularPages &amp;#34;Type&amp;#34; &amp;#34;blog&amp;#34; -}} {{- $.Scratch.Add &amp;#34;posts&amp;#34; (dict &amp;#34;title&amp;#34; .Title &amp;#34;permalink&amp;#34; .Permalink) -}} {{- end -}} {{- $.Scratch.Get &amp;#34;posts&amp;#34; | jsonify -}} 按照这个模板，hugo 本地预览可以打开 http://localhost:1313/index.json 查看，如果输出了一些数据如下图，说明你成功了。 2. js 代码 在 /layouts/_default 新建一个模板文件 search.html，大致的结构参考其他模板文件，然后写入我们需要的内容。 首先是一个简单的 html 结构，给 input 绑定一个事件。 &amp;lt;form class=&amp;#34;search&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;searchTerm&amp;#34; name=&amp;#34;searchTerm&amp;#34; autocomplete=&amp;#34;off&amp;#34; oninput=&amp;#34;initiateSearch()&amp;#34;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;div id=&amp;#34;resultsContainer&amp;#34;&amp;gt;请输入关键词进行搜索...&amp;lt;/div&amp;gt; 然后通过一个 get 请求获取 json 文件，传入关键词参数，生成搜索列表。 &amp;lt;script&amp;gt; function search(jsonData, searchTerm) { let results = []; for (let i = 0; i &amp;lt; jsonData.length; i++) { for (let property in jsonData[i]) { if (jsonData[i].hasOwnProperty(property) &amp;amp;&amp;amp; jsonData[i][property].toString().indexOf(searchTerm) &amp;gt; -1) { results.push(jsonData[i]); break; } } } return results; } function displayResults(searchResults) { let container = document.getElementById(&amp;#34;resultsContainer&amp;#34;); container.innerHTML = &amp;#34;&amp;#34;; if (searchResults.length &amp;gt; 0) { for (let i = 0; i &amp;lt; searchResults.length; i++) { let resultDiv = document.createElement(&amp;#34;div&amp;#34;); let resultTitle = document.createElement(&amp;#34;a&amp;#34;); resultTitle.innerText = searchResults[i].title; resultTitle.setAttribute(&amp;#39;href&amp;#39;, searchResults[i].permalink) resultDiv.appendChild(resultTitle); container.appendChild(resultDiv); } } else { let noResultsMessage = document.createElement(&amp;#34;p&amp;#34;); noResultsMessage.innerText = &amp;#34;没有找到搜索结果。&amp;#34;; container.appendChild(noResultsMessage); } } function initiateSearch() { let searchTerm = document.getElementById(&amp;#34;searchTerm&amp;#34;).value; let xhr = new XMLHttpRequest(); xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;/index.json&amp;#39;, true); xhr.onreadystatechange = () =&amp;gt; { if (xhr.readyState === 4 &amp;amp;&amp;amp; xhr.status === 200) { let jsonData = JSON.parse(xhr.responseText); let searchResults = search(jsonData, searchTerm); displayResults(searchResults); } }; xhr.send(); } &amp;lt;/script&amp;gt; 然后再在 /content 新建一个 search.md 文件调用该模板即可。 --- slug: search title: 搜索 layout: search --- 写了一个基础的样式，可以直接使用。 .search { width: 100%; display: flex; align-items: center; height: 36px; } .search #searchTerm { width: 100%; height: 100%; outline: none; border: none; padding: 0 15px; box-shadow: 1px 2px 10px rgba(0, 0, 0, 0.1); } #resultsContainer { margin-top: 20px; } #resultsContainer div { margin-bottom: 10px; margin: 0; } #resultsContainer div a { display: block; width: 100%; padding: 6px 10px; transition: all 0.1s linear; border-radius: 4px; } #resultsContainer div a:hover { background: #f3f3f3; }</description>
    </item>
    <item>
      <title>利用 memos 生成的在线动态列表</title>
      <link>https://zishu.me/blog/181.html/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/181.html/</guid>
      <description>memos 是一个具有知识管理和社交功能的开源自托管备忘录中心。 Github 地址：https://github.com/usememos/memos 可以用它本身提供的 api，然后结合静态博客，做成一个在线的动态列表，类似于朋友圈功能。 接口 url 有固定的格式，openId 是每个用户自动生成的。 其次我又写了两个方法，一个是时间戳转成正常时间格式，一个是利用正则删去内容中多余的标签。 将下面代码复制到你想显示的页面编辑，只需修改 openId，提供了一个基础的样式，如果有其他优化方案，欢迎指出。 由于接口中带了用户密钥，建议完成代码后将 js 加密再引入，不然可能会有一定的安全风险。 推荐网址：https://tool.lu/js/ &amp;lt;!-- 结构和 css --&amp;gt; &amp;lt;div class=&amp;#34;sslist&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .sslist-item { padding: 10px 10px 20px; margin-bottom: 20px; border-radius: 2px; background: #f3f3f3; box-shadow: 1px 2px 4px rgba(0, 0, 0, .2); transition: all 0.2s linear; animation: up 1s forwards; transform: translateY(20px); opacity: 0; } @keyframes up { 0% { transform: translateY(20px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } } .sslist-item:hover { background: #eee; } .sslist-item .sslist-date { opacity: 0.6; margin: 0; font-size: 15px; margin-bottom: 5px; } &amp;lt;/style&amp;gt; // 调用接口的 js 方法 function memosShow() { var memosStr = &amp;#34;&amp;#34;; var openId = &amp;#34;xxx&amp;#34;; $.ajax({ url: &amp;#34;https://memos.zburu.com/api/memo?openId=&amp;#34; + openId + &amp;#34;&amp;amp;tag=说说&amp;#34;, type: &amp;#34;get&amp;#34;, dataType: &amp;#34;json&amp;#34;, success: function (data) { // 生成数组 const sslist = data.data; for (let i = 0; i &amp;lt; sslist.length; i++) { const element = sslist[i]; // 把时间戳转为正常时间格式 2023-01-9 13:17:12 var date = new Date(element.createdTs * 1000); Y = date.getFullYear() + &amp;#34;-&amp;#34;; M = (date.getMonth() + 1 &amp;lt; 10 ? &amp;#34;0&amp;#34; + (date.getMonth() + 1) : date.getMonth() + 1) + &amp;#34;-&amp;#34;; D = (date.getDate() &amp;lt; 10 ? &amp;#34;0&amp;#34; + date.getDate() : date.getDate()) + &amp;#34; &amp;#34;; h = date.getHours() + &amp;#34;:&amp;#34;; m = date.getMinutes() + &amp;#34;:&amp;#34;; s = date.getSeconds(); const createdTsNew = Y + M + D + h + m + s; sslist[i].createdTs = createdTsNew; // 利用js正则删去内容前的标签字符 const contentNew = element.content.slice(4); sslist[i].content = contentNew; } $.each(data.data, function (i, item) { list = &amp;#34;&amp;lt;div class=&amp;#39;sslist-item&amp;#39;&amp;gt;&amp;#34; + &amp;#34;&amp;lt;p class=&amp;#39;sslist-date&amp;#39;&amp;gt;&amp;#34; + item.createdTs + &amp;#34;&amp;lt;/p&amp;gt;&amp;#34; + item.content + &amp;#34;&amp;lt;/div&amp;gt;&amp;#34;; memosStr += list; }), $(&amp;#34;.sslist&amp;#34;).html(memosStr); }, error: function () { console.log(&amp;#34;error&amp;#34;); } }); } memosShow();</description>
    </item>
    <item>
      <title>分享一个页面点击特效</title>
      <link>https://zishu.me/blog/180.html/</link>
      <pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/180.html/</guid>
      <description>点击页面时可以弹出随机颜色小心心，目前我的网站就使用了这个特效。 直接将下面的代码复制到引入的 js 文件中即可，不用进行其他配置。 !function(e,t,a){function n(){c(&amp;#34;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &amp;#39;&amp;#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&amp;#34;),o(),r()}function r(){for(var e=0;e&amp;lt;d.length;e++)d[e].alpha&amp;lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&amp;#34;left:&amp;#34;+d[e].x+&amp;#34;px;top:&amp;#34;+d[e].y+&amp;#34;px;opacity:&amp;#34;+d[e].alpha+&amp;#34;;transform:scale(&amp;#34;+d[e].scale+&amp;#34;,&amp;#34;+d[e].scale+&amp;#34;) rotate(45deg);background:&amp;#34;+d[e].color+&amp;#34;;z-index:99999&amp;#34;);requestAnimationFrame(r)}function o(){var t=&amp;#34;function&amp;#34;==typeof e.onclick&amp;amp;&amp;amp;e.onclick;e.onclick=function(e){t&amp;amp;&amp;amp;t(),i(e)}}function i(e){var a=t.createElement(&amp;#34;div&amp;#34;);a.className=&amp;#34;heart&amp;#34;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&amp;#34;style&amp;#34;);a.type=&amp;#34;text/css&amp;#34;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&amp;#34;head&amp;#34;)[0].appendChild(a)}function s(){return&amp;#34;rgb(&amp;#34;+~~(255*Math.random())+&amp;#34;,&amp;#34;+~~(255*Math.random())+&amp;#34;,&amp;#34;+~~(255*Math.random())+&amp;#34;)&amp;#34;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);</description>
    </item>
    <item>
      <title>js 中 [ ]&#43;{ } 和 { }&#43;[ ] 的区别</title>
      <link>https://zishu.me/blog/175.html/</link>
      <pubDate>Tue, 15 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/175.html/</guid>
      <description>[ ]+{ }：一个数组加一个对象。 加法会进行隐式类型转换，规则是调用其 valueOf() 或 toString() 以取得一个非对象的值 (primitive value)。 如果两个值中的任何一个是字符串，则进行字符串串接，否则进行数字加法。[ ] 和 { } 的 valueOf() 都返回对象自身，所以都会调用 toString()，最后的结果是字符串串接。 [ ].toString() 返回空字符串，({ }).toString() 返回 &amp;ldquo;[object Object]&amp;quot;，最后的结果就是 &amp;ldquo;[object Object]&amp;quot;。 { }+[ ]：看上去应该和上面一样。 但是{ }除了表示一个对象之外，也可以表示一个空的 bock。在 [ ] + { }中，[ ]被解析为数组，因此后续的 + 被解析为加法运算符，而{ }就解析为对象。 但在{ } + [ ]中，{ }被解析为空的 bock，随后的 + 被解析为正号运算符。即实际上成了：{∥empty block}+[ ]，即对一个空数组执行正号运算，实际上就是把数组转型为数字。首先调用.valueOf()，返回数组自身，不是 primitive value，因此继续调用 [ ].toString()，返回空字符串。空字符串转型为数字，返回 0，即最后的结果。</description>
    </item>
    <item>
      <title>localStorage 的相关运用</title>
      <link>https://zishu.me/blog/171.html/</link>
      <pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/171.html/</guid>
      <description>localStorage 是浏览器自带的一个属性，只读的 localStorage 属性允许你访问一个 Document 源（origin）的对象 Storage；存储的数据将保存在浏览器会话中。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除。 应注意，无论数据存储在 localStorage 还是 sessionStorage，它们都特定于页面的协议。 另外，localStorage 中的键值对总是以字符串的形式存储。 (需要注意，和 js 对象相比，键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型). localStorage 的使用也非常简单，分为存入和读取，可以将其绑定在事件方法中。 // 存入 const arr= 100; localStorage.setItem(&amp;#34;key&amp;#34;, JSON.stringify(arr)); // 读取 const arr = JSON.parse(localStorage.getItem(&amp;#34;key&amp;#34;)); 这里 &amp;quot;key&amp;quot; 指的是存到浏览器中的参数名，arr 则是参数值。 localStorage.setItem(&amp;quot;key&amp;quot;, JSON.stringify(arr)); 这个方法就是将数组 arr 存到了浏览器的 localStorage 中，它的参数名叫 key const arr = JSON.parse(localStorage.getItem(&amp;quot;key&amp;quot;)); 就是读取浏览器中参数名为 key 的参数值。 比如静态保存某个设置参数，可以将其写入数组中，然后通过 localStorage 存储，原本刷新就会显示默认设置，现在可以在每次刷新的适合读取存入的参数。 在一些场景下非常好用，比如开发一个油猴脚本等等。 清除 localStorage，分为清除所以的存储值和清除某个特定的 key。 // 清除本地存储中的所有值 localStorage.clear(); // 本地存储中删除特定项 localStorage.removeItem(key);</description>
    </item>
    <item>
      <title>将数组中多个对象的同名属性值取出合并成新数组</title>
      <link>https://zishu.me/blog/168.html/</link>
      <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/168.html/</guid>
      <description>业务中需求的方法，接口返回一个数组，里面包含了大量的对象，具有同名的属性名，比较常见。但是需要将其中参数为 name 的属性值全部取出，合并成数组。 const num = [ { id: 1, name: &amp;#39;abc&amp;#39;, }, { id: 2, name: &amp;#39;xyz&amp;#39;, } ] function getFields(arrnum, field) { const resnum = []; for (let i = 0; i &amp;lt; arrnum.length; ++i) resnum.push(arrnum[i][field]); return resnum; } const result = getFields(num, &amp;#34;name&amp;#34;); console.log(result); // [&amp;#39;abc&amp;#39;, &amp;#39;xyz&amp;#39;] console.log(result.join(&amp;#39; &amp;#39;)); // &amp;#34;abc xyz&amp;#34;</description>
    </item>
    <item>
      <title>人民币小写转大写</title>
      <link>https://zishu.me/blog/145.html/</link>
      <pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/145.html/</guid>
      <description>一个有趣的 demo this.smalltoBIG(43533534.78); //肆仟叁佰伍拾叁万叁仟伍佰叁拾肆元柒角捌分 smalltoBIG (n) { var fraction = [&amp;#39;角&amp;#39;, &amp;#39;分&amp;#39;]; var digit = [&amp;#39;零&amp;#39;, &amp;#39;壹&amp;#39;, &amp;#39;贰&amp;#39;, &amp;#39;叁&amp;#39;, &amp;#39;肆&amp;#39;, &amp;#39;伍&amp;#39;, &amp;#39;陆&amp;#39;, &amp;#39;柒&amp;#39;, &amp;#39;捌&amp;#39;, &amp;#39;玖&amp;#39;]; var unit = [ [&amp;#39;元&amp;#39;, &amp;#39;万&amp;#39;, &amp;#39;亿&amp;#39;],[&amp;#39;&amp;#39;, &amp;#39;拾&amp;#39;, &amp;#39;佰&amp;#39;, &amp;#39;仟&amp;#39;] ]; var head = n &amp;lt; 0 ? &amp;#39;欠&amp;#39; : &amp;#39;&amp;#39;; n = Math.abs(n); var s = &amp;#39;&amp;#39;; for (var i = 0; i &amp;lt; fraction.length; i++) { s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &amp;#39;&amp;#39;); } s = s || &amp;#39;整&amp;#39;; n = Math.floor(n); for (var i = 0; i &amp;lt; unit[0].length &amp;amp;&amp;amp; n &amp;gt; 0; i++) { var p = &amp;#39;&amp;#39;; for (var j = 0; j &amp;lt; unit[1].length &amp;amp;&amp;amp; n &amp;gt; 0; j++) { p = digit[n % 10] + unit[1][j] + p; n = Math.floor(n / 10); } s = p.replace(/(零.)*零$/, &amp;#39;&amp;#39;).replace(/^$/, &amp;#39;零&amp;#39;) + unit[0][i] + s; } return head + s.replace(/(零.)*零元/, &amp;#39;元&amp;#39;).replace(/(零.)+/g, &amp;#39;零&amp;#39;).replace(/^整$/, &amp;#39;零元整&amp;#39;); },</description>
    </item>
    <item>
      <title>浏览器收藏夹一键填写博客评论信息</title>
      <link>https://zishu.me/blog/120.html/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/120.html/</guid>
      <description>先点击收藏一个页面，然后右键它，选择修改，在网址输入框复制下面的 js 代码，就可以一键填入了。 将其中的昵称，邮箱，网址修改成自己的信息。 目前支持绝大多数主流博客平台和系统，如果发现没有起作用，可以在下面代码里面修改增加一下 input 的属性。 如果你不会修改的话，可以在评论区留言没有起作用的网站，我可以更新代码。 javascript:void function(){var lauthor=[&amp;#34;#author&amp;#34;,&amp;#34;input[name=&amp;#39;comname&amp;#39;]&amp;#34;,&amp;#34;#inpName&amp;#34;,&amp;#34;input[name=&amp;#39;author&amp;#39;]&amp;#34;,&amp;#34;#ds-dialog-name&amp;#34;,&amp;#34;input[name=&amp;#39;wc_name&amp;#39;]&amp;#34;, &amp;#34;input[name=&amp;#39;nick&amp;#39;]&amp;#34;,],lmail=[&amp;#34;#mail&amp;#34;,&amp;#34;#email&amp;#34;,&amp;#34;input[name=&amp;#39;commail&amp;#39;]&amp;#34;,&amp;#34;#inpEmail&amp;#34;,&amp;#34;input[name=&amp;#39;email&amp;#39;]&amp;#34;,&amp;#34;#ds-dialog-email&amp;#34;,&amp;#34;input[name=&amp;#39;wc_email&amp;#39;]&amp;#34;,&amp;#34;input[name=&amp;#39;mail&amp;#39;]&amp;#34;,],lurl=[&amp;#34;#url&amp;#34;,&amp;#34;input[name=&amp;#39;comurl&amp;#39;]&amp;#34;,&amp;#34;#inpHomePage&amp;#34;,&amp;#34;#ds-dialog-url&amp;#34;,&amp;#34;input[name=&amp;#39;url&amp;#39;]&amp;#34;,&amp;#34;input[name=&amp;#39;wc_website&amp;#39;]&amp;#34;,&amp;#34;input[name=&amp;#39;link&amp;#39;]&amp;#34;,];for(i=0;i&amp;lt;lauthor.length;i++){var author=document.querySelector(lauthor[i]);if(author!=null){author.value=&amp;#39;子舒&amp;#39;;break}}for(j=0;j&amp;lt;lmail.length;j++){var mail=document.querySelector(lmail[j]);if(mail!=null){mail.value=&amp;#39;shuxhan@163.com&amp;#39;;break}}for(k=0;k&amp;lt;lurl.length;k++){var url=document.querySelector(lurl[k]);if(url!=null){url.value=&amp;#39;https://zishu.me&amp;#39;;break}}return!1}()</description>
    </item>
    <item>
      <title>揭秘箭头函数</title>
      <link>https://zishu.me/blog/82.html/</link>
      <pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/82.html/</guid>
      <description>英文地址：https://javascript.plainenglish.io/demystifying-javascript-arrow-functions-7b2a0908a2b3 通过掘金翻译计划活动进行翻译 箭头函数是函数表达式的替代方法，但在语法上有所不同，不能在所有情况下使用。如果您还没有阅读 JavaScript 中的函数表达式，我建议您在继续阅读之前先阅读这篇文章。 现在，让我们试着从语法、执行、作用域和提升以及代码示例方面来理解箭头函数。 1. 语法 const arrowFunctionSyntax = () =&amp;gt; { console.log(&amp;#39;Hi, I am an arrow function&amp;#39;); }; arrowFunctionSyntax(); 在上面的代码示例中，我们可以看到箭头函数类似于函数表达式，因为它们被赋值为变量。主要区别在于函数的编写方式。以下是我们可以根据其语法从上述代码中得出的观察结果： 它不包含 function 关键字。 它没有 函数名 ，这意味着这些是匿名函数。 引入了箭头 =&amp;gt; 符号。 const arrowFunctionWithOneParam = (number) =&amp;gt; number + 1; const arrowFunctionWithMultipleParams = (numberOne, numberTwo) =&amp;gt; { let sum = numberOne + numberTwo; return sum; }; console.log(arrowFunctionWithOneParam(5)); console.log(arrowFunctionWithMultipleParams(5, 6)); 如果我们同时观察 arrowFunctionWithOneParam 和 arrowFunctionWithMultipleParams，我们可以发现三者的不同&amp;mdash;括号 ()、块 {} 和 return 关键字的使用。根据箭头函数的语法，如果函数只接受一个参数，可以忽略括号()。如果函数只包含一条语句，则可以忽略块{}，最后其实也可以忽略return ，如果函数只包含一个语句。 2. 执行 const arrowFunctionExecution = () =&amp;gt; { console.log(&amp;#39;Hi, my execution is similar to normal function&amp;#39;); }; arrowFunctionExecution(); 在执行箭头函数时，它们的执行方式与其他普通函数的执行方式相似。当 JS 引擎执行 arrowFunctionExecution() 时，它会创建一个函数，执行上下文并被推送到调用堆栈。一旦创建了执行上下文，它就会启动创建阶段。在这个阶段，它将创建参数对象并在其本地内存堆中声明所有变量。 与普通函数相比，主要区别在于 this 的声明。箭头函数没有自己的 this 变量； this 在箭头函数中使用时会得到词法解析。在创建阶段之后不久，执行阶段开始。这时它开始执行语句 console.log() ，并将 &amp;quot;Hi, my execution is similar to normal function&amp;quot; 打印到控制台。 3. 作用域 const arrowFunctionScope = () =&amp;gt; { console.log(&amp;#39;Hi, my scoping rules works similar to function expression&amp;#39;); }; 这些函数遵循与其他函数表达式相同的作用域规则。这些函数有自己的作用域，函数内部声明的任何变量都不能在函数外部访问。这些函数也不适用于 call、apply 和 bind 方法，这些方法通常依赖于作用域。如果您还没有阅读过 JavaScript 中的作用域，我建议您阅读 这篇文章。 4. 提升 amIGoingToBeHoisted(); var amIGoingToBeHoisted = () =&amp;gt; { console.log(&amp;#39;The answer is NO&amp;#39;); }; 箭头函数没有被提升，因为它们也是函数表达式，其中函数被分配为变量的值。当 JavaScript 引擎执行上述代码时，在创建阶段，声明语句 var amIGoingToBeHoisted 将被移到顶部并使用值 undefined 进行初始化，而将初始值留在后面。在执行阶段，遇到语句amIGoingToBeHoisted 时会抛出类型错误，因为它的值是 undefined，这不是提升后的函数类型。要了解有关 JavaScript 提升的更多信息，我建议您阅读 文章。</description>
    </item>
    <item>
      <title>js 奇怪的知识--console.table</title>
      <link>https://zishu.me/blog/81.html/</link>
      <pubDate>Thu, 04 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/81.html/</guid>
      <description>这个属性对我来说还真有些陌生，无意中发现的，查询过 MDN 之后听得挺有意思的，就记录一下。 根据字面意思就是“将数据以表格的形式显示”。这个方法需要一个必须参数 data，data 必须是一个数组或者是一个对象；还可以使用一个可选参数 columns。 表格的第一列是 index。如果数据 data 是一个数组，那么这一列的单元格的值就是数组的索引。如果数据是一个对象，那么它们的值就是各对象的属性名称。注意（在 FireFox 中）console.table 被限制为只显示 1000 行（第一行是被标记的索引）。 1.直接输出 直接进行尝试，在控制台输出 console.table console.table([&amp;#34;双十一&amp;#34;, &amp;#34;双十二&amp;#34;, &amp;#34;双十三&amp;#34;]); PS E:\demo&amp;gt; node 1.js ┌─────────┬──────────┐ │ (index) │ Values │ ├─────────┼──────────┤ │ 1 │ &amp;#39;双十二&amp;#39; │ │ 2 │ &amp;#39;双十三&amp;#39; │ └─────────┴──────────┘ 复制下来怪怪的，直接上个图，就是下面这个样子。 2.定义对象进行输出 同样也可以定义一个对象然后输出 function Fun(title, date) { this.title = title this.date = date } const one = new Fun(&amp;#34;双十一&amp;#34;, &amp;#34;11.11&amp;#34;) const two = new Fun(&amp;#34;双十二&amp;#34;, &amp;#34;12.12&amp;#34;) const three = new Fun(&amp;#34;双十三&amp;#34;, &amp;#34;你是傻子吗，没有 13 月&amp;#34;) console.table([one, two, three], [&amp;#34;title&amp;#34;, &amp;#34;date&amp;#34;]) 打印出来，就是下面这个样子。 3.console.table() 的应用场景 前面是在通过在编辑器中使用 node.js 输出数据，看看在浏览器中输出会不会不一样的效果。 可以看到成功输出数据，并且点击表头时，可以按照不同顺序进行排序，这么一看&amp;hellip;.嗯，还挺有用的（假笑） 应用场景大概就是可以对打印的数据进行更直观的观看，在某些情况下有利于调试代码，以后看看是否能用得上这种方法。</description>
    </item>
    <item>
      <title>通过 getTimezoneOffset() 方法判断当前时区是否为夏令时</title>
      <link>https://zishu.me/blog/80.html/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/80.html/</guid>
      <description>getTimezoneOffset() 方法 方法返回 UTC 时间和本地时间之间的时差，以分钟为单位。 世界协调时间 (UTC) 是世界时间标准设定的时间，UTC 时间与 GMT 时间（格林威治时间）相同。 测一下我所在时区和标准时区的时间差 function myDate () { var d = new Date(); var n = d.getTimezoneOffset(); console.log(n) } myDate(); // PS E:\demo&amp;gt; node 1.js // -480 也就是 480 分钟（8 个小时），北京时间是东八区，刚好与格林威治时间相差 8 个小时，这说明 getTimezoneOffset() 方法是很有效的。 接下来利用这个方法，判断一下当前时区是否为夏令时。 const time1 = new Date(2021, 0, 1); const time2 = new Date(2021, 6, 1); if (time1.getTimezoneOffset() != time2.getTimezoneOffset()) { console.log(&amp;#39;夏令时&amp;#39;); } else { console.log(&amp;#39;非夏令时&amp;#39;); } // PS E:\demo&amp;gt; node 1.js // 非夏令时</description>
    </item>
    <item>
      <title>使用 js 随机生成背景颜色</title>
      <link>https://zishu.me/blog/78.html/</link>
      <pubDate>Wed, 29 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/78.html/</guid>
      <description>先写一个简单的 html 页面出来 &amp;lt;style&amp;gt; /* ... */ &amp;lt;/style&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;html&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;css&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;js&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 通过 Math.random() 属性可以随机生成一个数字，然后通过转化为十六进制的方法进行处理，下面就是随机生成 6 位数字的代码，并进行转化的代码。 const randomHex = () =&amp;gt; `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &amp;#34;0&amp;#34;)}`; 可以在控制台输出看一下结果，随机生成了一个结果 #62113b。 接下来就需要将这个颜色传给上面的 li 标签，首先需要将所有的 li 遍历然后生成一个数组，可以使用 for 循环进行遍历。 var arr = document.getElementsByTagName(&amp;#39;li&amp;#39;), temp = []; for (var i = 0; i &amp;lt; arr.length; i++) { temp.push(arr[i].innerHTML); } 然后再对数组进行循环处理，每个 li 标签要要运行一遍随机生成颜色，并且传给自身。同样也是通过 for 循环进行操作。 var li = document.getElementsByTagName(&amp;#34;li&amp;#34;); for (var i = 0; i &amp;lt; li.length; i++) { for (var num = 0; num &amp;lt; li.length; num++) { li[num].style.background = randomHex(); } } 这些事件都是在页面加载完成之后运行的，所以需要通过 window.onload 写入事件，然后把所有的代码合在一起。 看看效果如果。 把这些复制下来放到本地运行一下就可以看到效果了。 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;随机生成颜色&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; body { display: flex; justify-content: center; padding-top: 100px; } ul { list-style: none; padding: 0; display: flex; } li { width: 100px; height: 40px; color: #333; display: flex; justify-content: center; align-items: center; margin-right: 30px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;html&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;css&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;js&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; const randomHex = () =&amp;gt; `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &amp;#34;0&amp;#34;)}`; console.log(randomHex()); var arr = document.getElementsByTagName(&amp;#39;li&amp;#39;), temp = []; for (var i = 0; i &amp;lt; arr.length; i++) { temp.push(arr[i].innerHTML); } window.onload = function () { var li = document.getElementsByTagName(&amp;#34;li&amp;#34;); for (var i = 0; i &amp;lt; li.length; i++) { for (var num = 0; num &amp;lt; li.length; num++) { li[num].style.background = randomHex(); } } } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 如果有更好的写法，欢迎评论！</description>
    </item>
    <item>
      <title>实时监听页面的变化</title>
      <link>https://zishu.me/blog/60.html/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/60.html/</guid>
      <description>问题产生于需求，因为项目需要适配 pc 和移动端多套布局，所以某些元素在特定的宽度下会产生错位的现象。 如果是在 css 中，可以很好的判断，使用媒体查询可以实时检测页面的宽度，从而给予标签不同的属性。 @media (max-width:768px){ ... } 在 js 下可以使用下面这种方法 window.addEventListener(&amp;#39;load&amp;#39;, function() { window.addEventListener(&amp;#39;resize&amp;#39;, function() { console.log(window.innerWidth) var w = window.innerWidth; // ... }) }) 具体操作的细节可以尝试一下，还是很不错的一个方法，同时注意 window ，因为这是个例子我就直接写了，实际编码中，慎用 window 事件。</description>
    </item>
    <item>
      <title>用 ajax 请求获取数据</title>
      <link>https://zishu.me/blog/57.html/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/57.html/</guid>
      <description>通过 jquery 进行 ajax 请求数据是一种较为简便的方式，我简单写了一个本地的data.json文件，然后用get请求数据，下面是部分代码 // ajax 请求获取数据 function picShow(){ var str = &amp;#39;&amp;#39;; $.ajax({ url:&amp;#39;./js/data.json&amp;#39;, type:&amp;#39;get&amp;#39;, dataType:&amp;#39;json&amp;#39;, success:function(data){ console.log(&amp;#39;success&amp;#39;) }, error: function() { console.log(&amp;#39;error&amp;#39;) } }) } picShow(); 但是这样做有一个弊端，无法在本地预览，因为浏览器禁止客户端直接获取本地数据，这也算一个跨域问题了，不过这也是为了保证用户的安全。当然这对前端来说很不爽！ 其实解决的方法也很简单，通过 node 服务，用live server在本地跑一下，就可以让 ajax 获取数据，当然还有其他更好的解决方法，或者直接在服务器跑，通过 jsonp 等等。 live server 不明白的可以百度看看，也是一个技巧。</description>
    </item>
    <item>
      <title>ES5 和 ES6 的区别？</title>
      <link>https://zishu.me/blog/48.html/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/48.html/</guid>
      <description>一、javascript 由三部分组成 1.ECMAScript（核心） 它规定了语言的组成部分：法语，类型，语句，关键字，操作符等等。 2.DOM（文档对象模型） DOM 把整个页面映射为一个多层节点结果，开发人员可借助 DOM 提供的 API，轻松地删除、添加、替换或修改任何节点。 3.BOM（浏览器对象模型） 支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。 二、什么是 ES5？ 作为 ECMAScript 第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下。 1.strict 模式 严格模式，限制一些用法，&amp;lsquo;use strict&amp;rsquo;; 2.Array 增加方法 增加了 every、some、forEach、filter、indexOf、lastIndexOf、isArray、map、reduce、reduceRight 方法 PS：还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now 3.Object 方法 Object.getPrototypeOf Object.create Object.getOwnPropertyNames Object.defineProperty Object.getOwnPropertyDescriptor Object.defineProperties Object.keys Object.preventExtensions / Object.isExtensible Object.seal / Object.isSealed Object.freeze / Object.isFrozen PS：只讲有什么，不讲是什么。 2.什么是 ES6? ECMAScript6 在保证向下兼容的前提下，提供大量新特性，目前浏览器兼容情况如下： ES6 特性如下： 块级作用域 关键字 let, 常量 const 对象字面量的属性赋值简写（property value shorthand） var obj = { // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() { // Super calls return &amp;#34;d &amp;#34; + super.toString(); }, // Computed (dynamic) property names [ &amp;#39;prop_&amp;#39; + (() =&amp;gt; 42)() ]: 42 }; 赋值解构 let singer = { first: &amp;#34;Bob&amp;#34;, last: &amp;#34;Dylan&amp;#34; }; let { first: f, last: l } = singer; // 相当于 f = &amp;#34;Bob&amp;#34;, l = &amp;#34;Dylan&amp;#34; let [all, year, month, day] = /^(\d\d\d\d)-(\d\d)-(\d\d)$/.exec(&amp;#34;2015-10-25&amp;#34;); let [x, y] = [1, 2, 3]; // x = 1, y = 2 函数参数 - 默认值、参数打包、数组展开（Default、Rest、Spread） //Default function findArtist(name=&amp;#39;lu&amp;#39;, age=&amp;#39;26&amp;#39;) { ... } //Rest function f(x, ...y) { // y is an Array return x * y.length; } f(3, &amp;#34;hello&amp;#34;, true) == 6 //Spread function f(x, y, z) { return x + y + z; } // Pass each elem of array as argument f(...[1,2,3]) == 6 箭头函数 Arrow functions (1) 简化了代码形式，默认 return 表达式结果。 (2) 自动绑定语义 this，即定义函数时的 this。如上面例子中，forEach 的匿名函数参数中用到的 this。 6.字符串模板 Template strings var name = &amp;#34;Bob&amp;#34;, time = &amp;#34;today&amp;#34;; `Hello ${name}, how are you ${time}?` // return &amp;#34;Hello Bob, how are you today?&amp;#34; Iterators（迭代器）+ for..of 迭代器有个 next 方法，调用会返回： (1) 返回迭代对象的一个元素：{ done: false, value: elem } (2) 如果已到迭代对象的末端：{ done: true, value: retVal } for (var n of [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;]) { console.log(n); } // 打印a、b、c 生成器（Generators） Class Class，有 constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。 class Artist { constructor(name) { this.name = name; } perform() { return this.name + &amp;#34; performs &amp;#34;; } } class Singer extends Artist { constructor(name, song) { super.constructor(name); this.song = song; } perform() { return super.perform() + &amp;#34;[&amp;#34; + this.song + &amp;#34;]&amp;#34;; } } let james = new Singer(&amp;#34;Etta James&amp;#34;, &amp;#34;At last&amp;#34;); james instanceof Artist; // true james instanceof Singer; // true james.perform(); // &amp;#34;Etta James performs [At last]&amp;#34; Modules ES6 的内置模块功能借鉴了 CommonJS 和 AMD 各自的优点： (1) 具有 CommonJS 的精简语法、唯一导出出口 (single exports) 和循环依赖 (cyclic dependencies) 的特点。 (2) 类似 AMD，支持异步加载和可配置的模块加载。 // lib/math.js export function sum(x, y) { return x + y; } export var pi = 3.141593; // app.js import * as math from &amp;#34;lib/math&amp;#34;; alert(&amp;#34;2π = &amp;#34; + math.sum(math.pi, math.pi)); // otherApp.js import {sum, pi} from &amp;#34;lib/math&amp;#34;; alert(&amp;#34;2π = &amp;#34; + sum(pi, pi)); Module Loaders: // Dynamic loading – ‘System’ is default loader System.import(&amp;#39;lib/math&amp;#39;).then(function(m) { alert(&amp;#34;2π = &amp;#34; + m.sum(m.pi, m.pi)); }); // Directly manipulate module cache System.get(&amp;#39;jquery&amp;#39;); System.set(&amp;#39;jquery&amp;#39;, Module({$: $})); // WARNING: not yet finalized Map + Set + WeakMap + WeakSet 四种集合类型，WeakMap、WeakSet 作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。 // Sets var s = new Set(); s.add(&amp;#34;hello&amp;#34;).add(&amp;#34;goodbye&amp;#34;).add(&amp;#34;hello&amp;#34;); s.size === 2; s.has(&amp;#34;hello&amp;#34;) === true; // Maps var m = new Map(); m.set(&amp;#34;hello&amp;#34;, 42); m.set(s, 34); m.get(s) == 34; //WeakMap var wm = new WeakMap(); wm.set(s, { extra: 42 }); wm.size === undefined // Weak Sets var ws = new WeakSet(); ws.add({ data: 42 });//Because the added object has no other references, it will not be held in the set Math + Number + String + Array + Object APIs 一些新的 API Number.EPSILON Number.isInteger(Infinity) // false Number.isNaN(&amp;#34;NaN&amp;#34;) // false Math.acosh(3) // 1.762747174039086 Math.hypot(3, 4) // 5 Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2 &amp;#34;abcde&amp;#34;.includes(&amp;#34;cd&amp;#34;) // true &amp;#34;abc&amp;#34;.repeat(3) // &amp;#34;abcabcabc&amp;#34; Array.from(document.querySelectorAll(&amp;#39;*&amp;#39;)) // Returns a real Array Array.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior [0, 0, 0].fill(7, 1) // [0,7,7] [1, 2, 3].find(x =&amp;gt; x == 3) // 3 [1, 2, 3].findIndex(x =&amp;gt; x == 2) // 1 [1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2] [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;].entries() // iterator [0, &amp;#34;a&amp;#34;], [1,&amp;#34;b&amp;#34;], [2,&amp;#34;c&amp;#34;] [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;].keys() // iterator 0, 1, 2 [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;].values() // iterator &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34; Object.assign(Point, { origin: new Point(0,0) }) Proxies 使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。 var target = {}; var handler = { get: function (receiver, name) { return `Hello, ${name}!`; } }; var p = new Proxy(target, handler); p.world === &amp;#39;Hello, world!&amp;#39;; 可监听的操作：get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。 Symbols Symbol 是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的。 var key = Symbol(&amp;#34;key&amp;#34;); var key2 = Symbol(&amp;#34;key&amp;#34;); key == key2 //false Promises Promises 是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似 jQuery 的 deferred 对象）。 function fakeAjax(url) { return new Promise(function (resolve, reject) { // setTimeouts are for effect, typically we would handle XHR if (!url) { return setTimeout(reject, 1000); } return setTimeout(resolve, 1000); }); } // no url, promise rejected fakeAjax().then(function () { console.log(&amp;#39;success&amp;#39;); },function () { console.log(&amp;#39;fail&amp;#39;); });</description>
    </item>
    <item>
      <title>webpack 的核心概念和构建流程</title>
      <link>https://zishu.me/blog/47.html/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/47.html/</guid>
      <description>1.webpack 的核心概念 entry（入口）：一个可执行模块或者库的入口。定义了打包后的入口文件。 output（出口）：指示 webpack 如何去输出，以及在哪里输出。 path: 打包文件存放的绝对路径 publicPath: 网站运行时的访问路径 filename: 打包后的文件名 module（模块）：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。 chunk（代码块）：一个 chunk 由多个 模块 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk，这就是打包。 loader（模块转换器）：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。 plugin（扩展）：扩展 webpack 功能的插件。在 webpack 构建的生命周期节点上加入扩展 hook，添加功能。 2.webpack 构建流程 初始化参数：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。 开始编译：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。 确定入口：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。 编译模块：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。 完成模块编译并输出：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk。 输出完成：输出所有的 chunk 到文件系统。 3.有哪些常见的 loader？ babel-loader：把 es6 转成 es5； css-loader：加载 css，支持模块化，压缩，文件导入等特性； style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css； eslint-loader：通过 Eslint 检查 js 代码； image-loader：加载并且压缩图片晚间； file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件； url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。 source-map-loader：加载额外的 source map 文件，方便调试。 4.业务场景和对应解决方案 1.单页应用 一个单页应用需要配置一个 entry 指明执行入口，web-webpack-plugin 里的 WebPlugin 可以自动的完成这些工作：webpack 会为 entry 生成一个包含这个入口的所有依赖文件的 chunk，但是还需要一个 html 来加载 chunk 生成的 js，如果还提取出 css 需要 HTML 文件中引入提取的 css。 一个简单的 webpack 配置文件例子： const { WebPlugin } = require(&amp;#39;web-webpack-plugin&amp;#39;); module.exports = { entry: { app: &amp;#39;./src/doc/index.js&amp;#39;, home: &amp;#39;./src/doc/home.js&amp;#39; }, plugins: [ // 一个 WebPlugin 对应生成一个 html 文件 new WebPlugin({ //输出的 html 文件名称 filename: &amp;#39;index.html&amp;#39;, //这个 html 依赖的`entry` requires: [&amp;#39;app&amp;#39;,&amp;#39;home&amp;#39;], }), ], }; 说明：require: [&amp;lsquo;app&amp;rsquo;, &amp;lsquo;home&amp;rsquo;]指明这个 html 依赖哪些 entry，entry 生成的 js 和 css 会自动注入到 html 中。 还支持配置这些资源注入方式，支持如下属性： _dist 只有在生产环境中才引入的资源； _dev 只有在开发环境中才引入的资源； _inline 把资源的内容潜入到 html 中； _ie 只有 IE 浏览器才需要引入的资源。 这些属性可以通过在 js 里配置，看个简单例子： new WebPlugin({ filename: &amp;#39;index.html&amp;#39;, requires: { app:{ _dist:true, _inline:false, } }, }), 这些属性还可以在模板中设置，使用模板好处就是可以灵活的控制资源的注入点 new WebPlugin({ filename: &amp;#39;index.html&amp;#39;, template: &amp;#39;./template.html&amp;#39;, }), &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh-cn&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;app?_inline&amp;#34;&amp;gt; &amp;lt;script src=&amp;#34;ie-polyfill?_ie&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;react-body&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;app&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; WebPlugin 插件借鉴了 fis3 的思想，补足了 webpack 缺失的以 HTML 为入口的功能。想了解 WebPlugin 的更多功能，见文档。 2.一个项目管理多个单页面 一个项目中会包含多个单页应用，虽然多个单页面应用可以合成一个，但是这样做会导致用户没有访问的部分也加载了，如果项目中有很多的单页应用。为每一个单页应用配置一个 entry 和 WebPlugin？如果又新增，又要新增 webpack 配置，这样做麻烦，这时候有一个插件 web-webpack-plugin 里的 AutoWebPlugin 方法可以解决这些问题。 module.exports = { plugins: [ // 所有页面的入口目录 new AutoWebPlugin(&amp;#39;./src/&amp;#39;), ] }; 分析： AutoWebPlugin会把./src/目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个 WebPlugin 输出对应的 html。 要新增一个页面就在 ./src/ 下新建一个文件夹包含这个单页应用所依赖的代码，AutoWebPlugin 自动生成一个名叫文件夹名称的 html 文件。 3.代码分隔优化 一个好的代码分割对浏览器首屏效果提升很大。 最常见的 react 体系： 先抽出基础库 react react-dom redux react-redux 到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件 hash 值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。所以把基础库打包成一个文件。 // vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新 // 所有页面都依赖的第三方库 // react 基础 import &amp;#39;react&amp;#39;; import &amp;#39;react-dom&amp;#39;; import &amp;#39;react-redux&amp;#39;; // redux 基础 import &amp;#39;redux&amp;#39;; import &amp;#39;redux-thunk&amp;#39;; // webpack 配置 { entry: { vendor: &amp;#39;./path/to/vendor.js&amp;#39;, }, } 通过 CommonsChunkPlugin 可以提取出多个代码块都依赖的代码形成一个单独的 chunk。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。所以通过 CommonsChunkPlugin 可以提取出多个代码块都依赖的代码形成一个单独的 chunk。 4.构建服务端渲染 服务端渲染的代码要运行在 nodejs 环境，和浏览器不同的是，服务端渲染代码需要采用 commonjs 规范同时不应该包含除 js 之外的文件比如 css。 webpack 配置如下： module.exports = { target: &amp;#39;node&amp;#39;, entry: { &amp;#39;server_render&amp;#39;: &amp;#39;./src/server_render&amp;#39;, }, output: { filename: &amp;#39;./dist/server/[name].js&amp;#39;, libraryTarget: &amp;#39;commonjs2&amp;#39;, }, module: { rules: [ { test: /\.js$/, loader: &amp;#39;babel-loader&amp;#39;, }, { test: /\.(scss|css|pdf)$/, loader: &amp;#39;ignore-loader&amp;#39;, }, ] }, }; 分析一下： target: &#39;node&#39; 指明构建出代码要运行在 node 环境中。 libraryTarget: &#39;commonjs2&#39; 指明输出的代码要是 commonjs 规范。 {test: /\.(scss|css|pdf)$/,loader: &#39;ignore-loader&#39;} 是为了防止不能在 node 里执行服务端渲染也用不上的文件被打包进去。 5.fis3 迁移到 webpack fis3 和 webpack 有很多相似地方也有不同的地方，相似地方：都采用 commonjs 规范，不同地方：导入 css 这些非 js 资源的方式。 fis3 通过@require &amp;lsquo;./index.scss&amp;rsquo;，而 webpack 是通过 require(&amp;rsquo;./index.scss&amp;rsquo;)。 如果想把 fis3 平滑迁移到 webpack，可以使用 comment-require-loader。 比如：你想在 webpack 构建是使用采用了 fis3 方式的 imui 模块 loaders:[{ test: /\.js$/, loaders: [&amp;#39;comment-require-loader&amp;#39;], include: [path.resolve(__dirname, &amp;#39;node_modules/imui&amp;#39;),] }] 5.自定义 webpack 扩展 如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写 loader 或者 plugin 了。 在你编写自定义 webpack 扩展前你需要想明白到底是要做一个 loader 还是 plugin 呢？可以这样判断： 如果你的扩展是想对一个个单独的文件进行转换那么就编写 loader 剩下的都是 plugin。 其中对文件进行转换可以是像： babel-loader 把 es6 转为 es5； file-loader 把文件替换成对应的 url； raw-loader 注入文本文件内容到代码中。 1.编写 webpack loader 编写 loader 非常简单，以 comment-require-loader 为例： module.exports = function (content) { return replace(content); }; loader 的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。 函数接收的参数 content 是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过 loader。从这里可以看出 loader 只能处理一个个单独的文件而不能处理代码块。可以参考官方文档。 2. 编写 webpack plugin plugin 应用场景广泛，所以稍微复杂点。以 end-webpack-plugin 为例： class EndWebpackPlugin { constructor(doneCallback, failCallback) { this.doneCallback = doneCallback; this.failCallback = failCallback; } apply(compiler) { // 监听 webpack 生命周期里的事件，做相应的处理 compiler.plugin(&amp;#39;done&amp;#39;, (stats) =&amp;gt; { this.doneCallback(stats); }); compiler.plugin(&amp;#39;failed&amp;#39;, (err) =&amp;gt; { this.failCallback(err); }); } } module.exports = EndWebpackPlugin; loader 的入口需要导出一个 class，在 new EndWebpackPlugin() 的时候通过构造函数传入这个插件需要的参数，在 webpack 启动的时候会先实例化 plugin，再调用 plugin 的 apply 方法，插件在 apply 函数里监听 webpack 生命周期里的事件，做相应的处理。 webpack plugin 的两个核心概念： compiler：从 webpack 启动到退出只存在一个 Compiler，compiler 存放着 webpack 的配置。 compilation：由于 webpack 的监听文件变化自动编译机制，compilation 代表一次编译。 Compiler 和 Compilation 都会广播一系列事件。webpack 生命周期里有非常多的事件。 以上只是一个最简单的 demo，更复杂的可以查看 how to write a plugin 或参考 web-webpack-plugin。 参考文章：https://www.cnblogs.com/chengxs/p/11022842.html</description>
    </item>
    <item>
      <title>javascript 进阶问题</title>
      <link>https://zishu.me/blog/36.html/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/36.html/</guid>
      <description>Github: https://github.com/lydiahallie/javascript-questions 相当不错的一个 Github 仓库，javascript questions ，作者每周都会发布一些有关 javascript 的题目，虽然不难但是考察细节，刷了一会，其实一些很简单的问题，结果因为细节思考不到位直接出错。 引用作者的话：我在我的 Instagram 上每天都会发布 JavaScript 的多选问题，并且同时也会在这个仓库中发布。 从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！</description>
    </item>
    <item>
      <title>在 js 中运算不能随便把 value 属性定义成变量</title>
      <link>https://zishu.me/blog/22.html/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/22.html/</guid>
      <description>在写一个小 demo 的时候，无意中发现定义变量的时候直接写入 value，会导致获取不到数据，或者获取的不是我们想要的内容，在 js 中运算不能随便把 value 属性定义成变量 先看一段代码 &amp;lt;input type=&amp;#34;text&amp;#34;&amp;#34; id=&amp;#34;a&amp;#34;&amp;gt; &amp;lt;span&amp;gt;*&amp;lt;/span&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;b&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;=&amp;#34; onclick=&amp;#34;beto()&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;sub&amp;#34; disabled&amp;gt; &amp;lt;script&amp;gt; function beto() { var a = document.getElementById(&amp;#39;a&amp;#39;).value var b = document.getElementById(&amp;#39;b&amp;#39;).value var sub = document.getElementById(&amp;#39;sub&amp;#39;).value sub = a + b } &amp;lt;/script&amp;gt; 就这么一看，逻辑貌似没有问题，获取 a 和 b 的 value，乘法运算，然后输出 sub 但是放在浏览器运行的时候，发现完全没有反应 为什么呢？ （假装思考五分钟&amp;hellip;） 因为 sub.value 不能直接定义在变量中 // 先定义 id 为 sub 的 input 框 var sub = document.getElementById(&amp;#39;sub&amp;#39;) // 然后在运算的时候在直接使用 sub.value sub.value = a * b 顺手放一个写 demo 时候用的简易计算器 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;简易计算器&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34;&amp;#34; id=&amp;#34;a&amp;#34;&amp;gt; &amp;lt;select id=&amp;#34;c&amp;#34;&amp;gt; &amp;lt;option value=&amp;#34;+&amp;#34;&amp;gt;+&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;-&amp;#34;&amp;gt;-&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;*&amp;#34;&amp;gt;*&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;/&amp;#34;&amp;gt;/&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;b&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;=&amp;#34; onclick=&amp;#34;beto()&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;sub&amp;#34; disabled&amp;gt; &amp;lt;script&amp;gt; function beto() { var a = document.getElementById(&amp;#39;a&amp;#39;).value var b = document.getElementById(&amp;#39;b&amp;#39;).value var c = document.getElementById(&amp;#39;c&amp;#39;).value var sub = document.getElementById(&amp;#39;sub&amp;#39;) switch(c) { case &amp;#34;+&amp;#34;: sub.value = parseInt(a) + parseInt(b); break; case &amp;#34;-&amp;#34;: sub.value = parseInt(a) - parseInt(b); break; case &amp;#34;*&amp;#34;: sub.value = parseInt(a) * parseInt(b); break; case &amp;#34;/&amp;#34;: sub.value = parseInt(a) / parseInt(b); break; } } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;</description>
    </item>
    <item>
      <title>事件监听函数，以及事件的捕获和冒泡机制</title>
      <link>https://zishu.me/blog/21.html/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/21.html/</guid>
      <description>事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件，事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流 函数事件 事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件 事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流 true 是捕获，false 是冒泡，默认为冒泡事件 1.addEventListener()－－添加事件监听函数 给元素添加一个事件，假如有多个事件，不会覆盖，会依次执行 &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;dom&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; document.getElementById(&amp;#39;demo&amp;#39;).addEventListener(&amp;#34;click&amp;#34;, myfun) document.getElementById(&amp;#39;demo&amp;#39;).addEventListener(&amp;#34;click&amp;#34;, myfun1) function myfun() { console.log(&amp;#39;事件监听函数&amp;#39;) } function myfun1() { console.log(&amp;#39;addEventListener&amp;#39;) } &amp;lt;/script&amp;gt; 注意： 1.这里有一个细节，addEventListener() 里面有两个参数，第一个表示触发的条件，第二个表示触发的事件 正常情况下，第二个参数直接写函数名并且不加参数()，如果加了参数()则表示立即执行，不需要触发第一个参数要求的条件 2.在这里绑定事件的时候，事件名不能和定义的变量名一样，否则无效 2.removeEventListener()－－移除事件监听函数 下面这个 demo，当鼠标在 div 中移动的时候，出现随机数，点击按钮后，移除事件监听函数 &amp;lt;!-- css --&amp;gt; &amp;lt;style&amp;gt; #demo { width: 100px; height: 100px; border: 1px solid #000; } &amp;lt;/style&amp;gt; &amp;lt;!-- html --&amp;gt; &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;点击移除&amp;#34; onclick=&amp;#34;remove()&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;show&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- js --&amp;gt; &amp;lt;script&amp;gt; document.getElementById(&amp;#39;demo&amp;#39;).addEventListener(&amp;#34;mousemove&amp;#34;, myfun) function myfun() { document.getElementById(&amp;#39;show&amp;#39;).innerHTML = Math.random() } function remove() { document.getElementById(&amp;#39;demo&amp;#39;).removeEventListener(&amp;#34;mousemove&amp;#34;, myfun) } &amp;lt;/script&amp;gt; 3.利用事件的捕获和冒泡做点事情 addEventListener() 和 removeEventListener() 其实拥有三个参数，刚才说过了，第一个表示触发条件，第二个表示触发事件，第三个参数正常情况下可以省略，但是要知道它代表的意思 用布尔值来表示，true 或者 false，默认是 false true 表示在捕获阶段调用事件处理程序 false 表示在冒泡阶段调用事件处理程序 根据图片可以看出，捕获阶段要先于冒泡阶段，因此，true 事件要先于 flase 事件触发，多个 true 事件按顺序触发，多个 false 事件，写在后面的先触发 结论：写在前面的 true 事件 &amp;gt; 写在后面的 true 事件 &amp;gt; 写在后面的 false 事件 &amp;gt; 写在前面的 false 事件 因此，利用这个参数，可以控制同一个元素的不同事件触发的顺序 &amp;lt;div id=&amp;#34;out&amp;#34;&amp;gt; &amp;lt;p&amp;gt;最外面&amp;lt;/p&amp;gt; &amp;lt;div id=&amp;#34;middle&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;inner&amp;#34;&amp;gt;最里面&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 第一种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：inner-------middle------out out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},false); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},false); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第二种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out------middle-------inner out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},true); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},true); &amp;lt;/script&amp;gt; &amp;lt;!-- 第三种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out------inner-------middle out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},false); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第四种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out-------middle------inner out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},true); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第五种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：middle-------inner------out out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},false); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},true); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},false); &amp;lt;/script&amp;gt; &amp;lt;!-- 第六种情况 --&amp;gt; &amp;lt;script&amp;gt; var out = document.getElementById(&amp;#39;out&amp;#39;); var middle = document.getElementById(&amp;#39;middle&amp;#39;); var inner = document.getElementById(&amp;#39;inner&amp;#39;); //点击 inner 时，触发顺序为：out-------inner------middle out.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最外面的&amp;#34;);},true); middle.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是中间的&amp;#34;);},false); inner.addEventListener(&amp;#39;click&amp;#39;,function(){alert(&amp;#34;我是最里面的&amp;#34;);},true); &amp;lt;/script&amp;gt; 4.事件处理程序 HTML 事件处理程序 &amp;lt;button onclick=&amp;#34;test()&amp;#34;&amp;gt;测试&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function test() { alert(&amp;#34;HTML 事件处理程序&amp;#34;); } &amp;lt;/script&amp;gt; 1.优点：事件处理程序中的代码，能够访问全局作用域中的任何变量 2.缺点：时差问题、扩展的作用域链在不同浏览器中会导致不同结果、html 代码与 js 代码高度耦合 DOM0 级事件处理程序 &amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;测试&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; var btn = document.getElementById(&amp;#34;btn&amp;#34;); btn.onclick = function test() { alert(&amp;#34;DOM0 级事件处理程序&amp;#34;); } &amp;lt;/script&amp;gt; 1.优点：代码简单，浏览器兼容性好，解决了 html 代码和 js 代码的高度耦合问题 2.缺点：一个元素只能绑定一个事件处理函数，只会在事件冒泡中运行 DOM2 级事件处理程序 该级别的事件处理程序，运用的就是事件捕获和冒泡机制 &amp;lt;button id=&amp;#34;btn&amp;#34;&amp;gt;测试&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; var btn = document.getElementById(&amp;#34;btn&amp;#34;); // 事件监听 btn.addEventListener(&amp;#34;click&amp;#34;, function() { alert(&amp;#34;DOM2 级事件处理程序，我在捕获阶段执行&amp;#34;); }, true); btn.addEventListener(&amp;#34;click&amp;#34;, function() { alert(&amp;#34;DOM2 级事件处理程序，我在冒泡阶段执行&amp;#34;); }, false); // 移除事件监听 var fun = function() { alert(&amp;#34;我要被移除了&amp;#34;); } btn.addEventListener(&amp;#34;click&amp;#34;, fun, false); btn.removeEventListener(&amp;#34;click&amp;#34;, fun, false); &amp;lt;/script&amp;gt; 1.优点：同时支持事件处理的捕获和冒泡阶段，并且一个元素可以绑定多个处理函数 2.缺点：IE 不支持</description>
    </item>
    <item>
      <title>有关 js 函数，方法的一些补充总结</title>
      <link>https://zishu.me/blog/17.html/</link>
      <pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/17.html/</guid>
      <description>数据类型，构造函数，原型和原型链的一些讲解补充 一、数据类型 1.5 个基本类型 string number boolean undefined 未定义 null 值为空 symbol 表示一个符号，符号类型是唯一的并且是不可修改的 最常见的还是前三种，字符串，数字，布尔值 2.常见的引用类型 引用类型是一种数据结构，用于将数据和功能组织在一起 对象－Object, 数组－Array, 函数－Function, 正则－RegExp, 日期－Date 等 二、函数 1.什么是函数？ 具有独立功能的代码块，在 js 中使用 function 关键字定义函数 让代码结构更加清晰，提高代码可用性 js 函数的分类：自定义函数和系统函数 2.自定义函数 有一种匿名函数，没有名字的函数，创建闭包，避免造成全局变量的污染 匿名自执行函数 概念：匿名函数的定义完成后立即执行，执行函数表达式 作用：实现闭包和创建独立的命名空间 使用：分组操作符 ()，void 操作符，~操作符，! 操作符等等 使用场景：函数表达式，对象属性，事件，事件参数，返回值 定义完匿名函数后，一定要调用 // 函数表达式 window.onload = function() { let funcobj = function() { alert(&amp;#34;函数表达式中的匿名函数&amp;#34;) } funcobj(); } // 对象属性 window.onload = function() { let obj = { name: function() { alert(&amp;#39;对象属性中的匿名函数&amp;#39;) } } obj.name(); } 3.内置函数 放在全局下面叫做函数，放在对象里面被叫做方法，对象的方法 常规函数 alert() // 弹出框 confirm() // 弹出一个确认框 prompt() // 弹出一个输入框 isNaN() // 判断是否为数字 parseInt() // 将字符串或浮点数转换为整数 parseFloat() // 将字符串转换为整数或浮点数 eval() // 计算表达式的结果 数组函数 用for循环遍历数组 var arr = [1,2,3,4]; for(var i = 0; i&amp;lt;arr.length; i++) { console.log(arr[i]) } // 输出 1,2,3,4 通过for in遍历数组 var arr = [1,2,3,4]; for (var i in arr) { console.log(arr[i]); } // 输出 1,2,3,4 // 增加 unshift() // 添加元素在数组首部，返回值是数组长度 push() // 添加元素在数组尾部，返回值是数组长度 conat() // 连接两个数组，返回值是连接后的数组 var arr1 = [1]; var arr2 = [2]; let arr = arr1.concat(arr2); console.log(arr); // [1,2] /*****************************************/ // 删除 pop() // 删除数组最后一个元素，返回值是删除的元素 shift() // 删除数组第一个元素，返回值是删除的元素 splice(a,b) // 删除指定位置a后的b个元素，返回值是删除的元素 slice(a,b) // 删除从a位置到b位置之间的元素 /*****************************************/ // 查找 indexOf() // 判断数组是否包含指定元素，存在返回元素，不存在返回-1 includes() // 判断数组是否包含指定元素，存在返回true，不存在返回false /*****************************************/ // 其他 sort() // 将数组按照规则排序 var arr1 = [4,5,6]; var arr2 = [1,2,3]; var arrAscSort = arr5.sort((a, b) =&amp;gt; a-b); // 升序排序 console.log(arrAscSort); // [ 1, 1, 2, 3, 5, 6 ] var arrDescSort = arr5.sort((a, b) =&amp;gt; b-a); // 降序排序 console.log(arrDescSort); // [ 6, 5, 3, 2, 1, 1 ] reerse() // 数组反转 var arr = [1,2,3,4,5,6]; // 直接通过reverse()方法调用 console.log(arr.reverse()) // [6,5,4,3,2,1] Array.from() // 将一串数据转换为数组形式 var str = &amp;#39;将一串数据转换为数组形式&amp;#39; console.log(Array.from(str)) // [&amp;#34;将&amp;#34;, &amp;#34;一&amp;#34;, &amp;#34;串&amp;#34;, &amp;#34;数&amp;#34;, &amp;#34;据&amp;#34;, &amp;#34;转&amp;#34;, &amp;#34;换&amp;#34;, &amp;#34;为&amp;#34;, &amp;#34;数&amp;#34;, &amp;#34;组&amp;#34;, &amp;#34;形&amp;#34;, &amp;#34;式&amp;#34;] Array.isArray() // 判断一个变量是否为数组 var str = &amp;#39;将一串数据转换为数组形式&amp;#39; console.log(Array.isArray(str)) // false 日期函数 Date() 获取时间 var time = new Date() // 获取当前时间 // Fri Nov 13 2020 20:21:35 GMT+0800 (中国标准时间) getFullYear() // 获取当前年份 getMonth() // 获取当月月份 -1 getDate() // 获取当天日期 getHours() // 获取当前小时 getMinutes() // 获取当前分钟 getSeconds() // 获取当前秒 getMilliseconds() // 获取当前毫秒 getTime() // 时间戳-获取1970年至今的毫秒数 设置时间 setYear() // 设置年份 setMonth() // 设置月份 setDate() // 设置日期 setHours() // 设置小时 setMinutes() // 设置分钟 setSeconds() // 设置秒 数学函数 Math 主要常用的数学函数方法 Math.abs() // 绝对值 Math.ceil() // 向上取整 Math.floor()// 向下取整 Math.round()// 四舍五入 Math.random() // 生成0-1之间的随机数 random() 的延伸用法－－－生成指定位的随机数 function getRandomNumber(min, max){ return Math.floor(Math.random()*(max - min)) + min; } console.log(getRandomNumber(1000, 9999)); 字符串函数 indexOf() // 查找字符串，返回索引值 var arr = [&amp;#34;字&amp;#34;, &amp;#34;符&amp;#34;, &amp;#34;串&amp;#34;, &amp;#34;函&amp;#34;, &amp;#34;数&amp;#34;] console.log(arr.indexOf(&amp;#34;串&amp;#34;)) // 2 split() // 将字符串按照指定的分隔符分割开来 var str = &amp;#34;字符串函数&amp;#34; console.log(str.split(&amp;#39;&amp;#39;)) // [&amp;#34;字&amp;#34;, &amp;#34;符&amp;#34;, &amp;#34;串&amp;#34;, &amp;#34;函&amp;#34;, &amp;#34;数&amp;#34;] trim() // 清除字符串两端的空格 var str = &amp;#34; 字符串函数 &amp;#34; console.log(str) // [ 字符串函数 ] console.log(str.trim()) // [字符串函数] match() // 按照制定规则查找值 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.match(/字符串/)) // 字符串 document.write(str.match(/字符串/)) // 字符串 search() // 返回字符串 首次出现的位置 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.search(&amp;#39;串&amp;#39;)) // 2 replace() // 替换指定的字符串 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.replace(&amp;#39;字&amp;#39;,&amp;#39;函&amp;#39;)) // 函符串函数字符串函数 substring(a,b) // 从指定位置切割字符串，左闭右开 // 从索引a，截取到b var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.substring(0,3)) // 字符串 substr(a,b) // 从指定位置切指定个字符 // 从索引a开始，截取b个字符 var str = &amp;#34;字符串函数字符串函数&amp;#34; console.log(str.substr(0,3)) // 字符串</description>
    </item>
    <item>
      <title>面向对象编程</title>
      <link>https://zishu.me/blog/15.html/</link>
      <pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/15.html/</guid>
      <description>面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。 一、什么是面向对象编程 js 是基于原型的，基于面向对象编程 面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类 1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。 自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用 面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。 2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统 面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。 想要弄明白面向对象，需要先理解类和对象的概念 《什么是类和对象？》 二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = &amp;#39;小明&amp;#39;; person.age = 22; person.year = function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) }; person.year(); // 字面量 var student = { name: &amp;#39;小明&amp;#39;, age: 22, year: function () { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高 2.工厂模式 window.onload = function() { function createObj(name, age) { var obj = new Object(); obj.name = name, obj.age = age, obj.year = function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } return obj; } var obj = createObj(&amp;#39;小明&amp;#39;, 22); obj.year(); } // 小明今年22岁了！ 优点：解决重复实例化对象的问题 缺点：无法识别对象的类型，因为所有的实例都指向一个原型 3.构造函数 window.onload = function() { function Person(name, age) { this.name = name; this.age = age; this.year = function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } } var student = new Person(&amp;#39;小明&amp;#39;, 22); student.year(); } // 小明今年22岁了！ 优点：可以识别对象的类型 缺点：多个实例重复创建方法，无法共享 4. 原型模式 window.onload = function() { function Par() {} Par.prototype = { constructor: &amp;#39;Par&amp;#39;, name: &amp;#39;小明&amp;#39;, age: 22, year: function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } }; var son = new Par(); son.year(); } // 小明今年22岁了！ 缺点：所有实例共享他的属性和方法，不能传参和初始化属性值 5.混合模式 (推荐使用) 是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值 先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过 prototype 获取，有一个 constructor 属性，可以指向要操作的函数对象（构造函数） 比如constructor: Par，就代表下面这个原型方法指向Par()对象（构造函数） window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;); } }; var son = new Par(&amp;#39;小明&amp;#39;, 22) son.year(); } // 小明今年22岁了！ 三、原型，原型链 1.原型对象 函数对象都具有prototype属性，它指向函数的原型对象 (浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象 (构造函数) window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { // constructor指向对象 constructor: Par, year: function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;); } }; var son = new Par(&amp;#39;小明&amp;#39;, 22) son.year(); /*********************************************/ console.log(Par.prototype) console.log(Par.prototype.constructor) /*********************************************/ } 通过控制台可以看到 构造函数的prototypr属性指向原型对象 原型对象的construcyor属性指向构造函数 当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ，它指向构造函数的原型对象 console.log(son.__proto__ === Par.prototype) // true 所有的构造函数的 prototype 都是 object 类型 console.log(typeof Par.prototype) // object Function 的 prototype 是一个空函数，所有内置函数的__proto__属性都指向这个空函数 console.log(Math.__proto__) 如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过delete方法将同名属性在实例（构造函数）中彻底删除 window.onload = function () { function Par(name) { this.name = name; } Par.prototype.name = &amp;#34;张三&amp;#34;; var son = new Par(&amp;#34;李四&amp;#34;); console.log(son.name); // 李四 console.log(son.__proto__.name); // 张三 // 使用 delete 删除实例的同名属性值 console.log(delete son.name); // true console.log(son.name); // 张三 } 通过hasOwnProperty(属性名)可以判断一个属性存在于构造函数中，还是原型对象中 true表示存在构造函数中；false表示存在原型对象中 console.log(Par.hasOwnProperty(name)); // false 操作符in，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可） window.onload = function () { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + this.age) } }; var son = new Par(&amp;#39;xm&amp;#39;, &amp;#39;22&amp;#39;) son.year(); console.log(&amp;#39;name&amp;#39; in Par); // true console.log(&amp;#39;age&amp;#39; in Par); // false } 同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样 参考:《对象中是否有某一个属性 in》https://www.cnblogs.com/IwishIcould/p/12333739.html 2.__proto__和 prototype 的区别 prototype属性只有函数对象上才有，而__proto__属性所有对象都有 prototype是由函数对象指向原型对象，而__proto__是由实例指向函数对象的原型对象 原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做原型链 3.继承 原型链继承 优点：父类原型定义的属性和方法可以复用 缺点：子类实例没有自己的属性，不能向父类传递参数 function test1() { function SuperType() { this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ]; this.property = true; } SuperType.prototype = { constructor : SuperType, // 保持构造函数和原型对象的完整性 age : 15, getSuperValue : function() { return this.property; } }; function SonType() { this.property = false; } // 重写子类的原型指向父类的实例：继承父类的原型 SubType.prototype = new SuperType(); SubType.prototype = { constructor : SubType, getSonType : function() { return this.property; } }; // 优点验证 let son = new SubType(); console.log(son.age); // 15 console.log(son.getSuperValue()); // false // 缺点验证 let instance1 = new SubType(); instance1.city.push(&amp;#34;重庆&amp;#34;); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance2 = new SubType(); console.log(instance2.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] } // test1(); 构造函数继承 优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点 缺点：父类原型的属性和方法不可复用 function test2() { function SuperType(name) { this.name = name; this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ] } SuperType.prototype = { constructor : SuperType, age : 18, showInfo : function() { return this.name; } }; function SubType() { // 父类调用 call() 或者 apply() 方法和子类共用同一个 this，实现子类实例属性的继承 SuperType.call(this, &amp;#34;张三&amp;#34;); } // 优点验证 let instance = new SubType(); instance.city.push(&amp;#34;重庆&amp;#34;); console.log(instance.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance1 = new SubType(); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;] // 缺点验证 console.log(instance.age); // undefined instance.showInfo(); // son.showInfo is not a function } // test2(); 组合继承（推荐） 优点：原型的属性和方法可以复用，每个子类实例都有自己的属性 缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖 function test3() { function SuperType(name) { this.name = name; this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ] } SuperType.prototype = { constructor : SuperType, showInfo : function() { console.log(this.name + &amp;#34;今年&amp;#34; + this.age + &amp;#34;岁了&amp;#34;); } }; function SubType(name, age) { // 1. 通过构造方法继承实现实例属性的继承 SuperType.call(this, name); this.age = age; } // 2. 通过原型链继承实现原型方法的继承 SubType.prototype = new SuperType(); // 优点验证 let instance = new SubType(&amp;#34;张三&amp;#34;, 15); instance.showInfo(); // 张三今年 15 岁了 let instance1 = new SubType(); instance1.city.push(&amp;#34;重庆&amp;#34;); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance2 = new SubType(); console.log(instance2.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;] } // test3(); 寄生组合继承（推荐） 优点：解决了组合继承的缺点，效率高 缺点：基本没有 function test4() { function inheritPrototype(subType, superType) { // 1. 继承父类的原型 var prototype = Object.create(superType.prototype); // 2. 重写被污染的 construct prototype.constructor = subType; // 3. 重写子类的原型 subType.prototype = prototype; } function SuperType(name) { this.name = name; this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); } // 优点验证 let instance = new SubType(&amp;#34;张三&amp;#34;, 15); instance.sayName(); // 张三 let instance1 = new SubType(); instance1.city.push(&amp;#34;重庆&amp;#34;); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance2 = new SubType(); console.log(instance2.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;] } // test4(); 4.ES6 新方法－－class 新的关键字class在 es6 开始被引入到 javascript 中来，class的目的就是让定义类更简单 用函数方法实现： function Person(name) { this.name = name; } Person.prototype.hello = function () { console.log(&amp;#39;Hello, &amp;#39; + this.name + &amp;#39;!&amp;#39;); } var son = new Person(&amp;#39;xm&amp;#39;) son.hello(); // Hello, xm! 用class来实现： class Person { constructor(name) { this.name = name; } hello() { console.log(&amp;#39;Hello, &amp;#39; + this.name + &amp;#39;!&amp;#39;); } } var son = new person(&amp;#39;xm&amp;#39;) son.hello(); // Hello, xm! 可以在看到，在定义class中，直接包含了构造函数constructor属性，和原型对象上的函数hello()方法，省略掉了function关键字 需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用class可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的 class 继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Person派生一个PrimaryPerson需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class PrimaryPerson extends Person { constructor(name, grade) { super(name); // 记得用 super 调用父类的构造方法！ this.grade = grade; } myGrade() { alert(&amp;#39;I am at grade &amp;#39; + this.grade); } } 注意PrimaryPerson的定义也是通过 class 关键字实现的，而extends则表示原型链对象来自Person，子类的构造函数可能会和父类的不太相同 例如，PrimaryPerson需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。 PrimaryPerson已经自动获得了父类Person的hello方法，我们又在子类中定义了新的myGrade方法。 ES6 引入的class和原有的JavaScript原型继承有什么区别呢？ 实际上它们没有任何区别，class的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 但是！ 目前并不是所有的浏览器都支持class，所以在选择的时候一定要慎重！</description>
    </item>
  </channel>
</rss>
