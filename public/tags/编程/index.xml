<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on 子舒的博客</title>
    <link>https://zishu.me/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Jan 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://zishu.me/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用 React 与 Vue 创建同一款 App，差别究竟有多大？</title>
      <link>https://zishu.me/blog/43.html/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/43.html/</guid>
      <description>关于 React 框架 和 Vue 框架 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？ 转载于：https://blog.csdn.net/csdnnews/article/details/81880378 原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd 作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 译者：安翔，责编：屠敏 众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。 于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。 很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。 1.目标 我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面）构建，React 使用 create-react-app，Vue 使用 vue-cli。 两个应用程序的外观如下： 两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构： 你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。 两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。 在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观： 现在让我们正式开始，深入其中的细节！ 2.如何修改数据 首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象： vue 数据对象 React 状态对象 从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。 假设我们有一个名为 name: ‘Sunil’的数据元素。 在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name =&amp;lsquo;John&amp;rsquo; 来更新它。这样一来，名字就被成功改为了“Jhon”。 在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name =&amp;lsquo;John&amp;rsquo;，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：&amp;lsquo;John&amp;rsquo;})。 虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。那么为什么 React 没有进行简化，为什么需要 setState 呢？Revanth Kumar 对此做出了解释： “这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。&amp;quot; 3.添加新的待办事项 React 的实现方法 createNewToDoItem = () =&amp;gt; { this.setState( ({ list, todo }) =&amp;gt; ({ list: [ ...list, { todo } ], todo: &amp;#39;&amp;#39; }) ); }; 在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟： &amp;lt;input type=&amp;#34;text&amp;#34; value={this.state.todo} onChange={this.handleInput}/&amp;gt; 只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下： handleInput = e =&amp;gt; { this.setState({ todo: e.target.value }); }; 现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的 todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加 todo。整个列表是通过使用扩展运算符添加的。 最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。 Vue 的实现方法 createNewToDoItem() { this.list.push( { &amp;#39;todo&amp;#39;: this.todo } ); this.todo = &amp;#39;&amp;#39;; } 在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下： &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;todo&amp;#34;/&amp;gt; V-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：&amp;rsquo; &amp;lsquo;。如果已经存在数据，例如 todo：&amp;lsquo;添加文本处&amp;rsquo;，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。 因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中，然后将 todo 改为空字符串。 4.删除待办事项 React 的实现方法 deleteItem = indexToDelete =&amp;gt; { this.setState(({ list }) =&amp;gt; ({ list: list.filter((toDo, index) =&amp;gt; index !== indexToDelete) })); }; 尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递： &amp;lt;ToDoItem deleteItem={this.deleteItem.bind(this, key)}/&amp;gt; 这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem。然后，在 ToDoItem 组件内部，我们执行以下操作： &amp;lt;div className=”ToDoItem-Delete” onClick={this.props.deleteItem}&amp;gt;-&amp;lt;/div&amp;gt; 想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。 Vue 的实现方法 onDeleteItem(todo){ this.list = this.list.filter(item =&amp;gt; item !== todo); } Vue 的实现方法稍有不同，我们需要做到以下三点： 首先，在元素上调用函数： &amp;lt;div class=”ToDoItem-Delete” @click=”deleteItem(todo)”&amp;gt;-&amp;lt;/div&amp;gt; 然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为 ToDoItem.vue），如下所示： deleteItem(todo) { this.$emit(&amp;#39;delete&amp;#39;, todo) } 之后，你会发现，当我们添加 ToDo.vue 的 ToDoItem.vue 时，实际上引用了一个函数： &amp;lt;ToDoItem v-for=&amp;#34;todo in list&amp;#34; :todo=&amp;#34;todo&amp;#34; @delete=&amp;#34;onDeleteItem&amp;#34; // &amp;lt;-- this :) :key=&amp;#34;todo.id&amp;#34; /&amp;gt; 这就是所谓的自定义事件监听器。它会监听任何使用 &amp;lsquo;delete&amp;rsquo; 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组，以删除被点击的待办事项。 在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示： &amp;lt;div class=”ToDoItem-Delete” @click=”$emit(‘delete’, todo)”&amp;gt;-&amp;lt;/div&amp;gt; 如果你喜欢，这样做可以把 3 步减少到 2 步。 React 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。 5.如何传递事件监听器 React 的实现方法 事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下： &amp;lt;div className=”ToDo-Add” onClick={this.createNewToDoItem}&amp;gt;+&amp;lt;/div&amp;gt; 非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下： &amp;lt;input type=”text” onKeyPress={this.handleKeyPress}/&amp;gt; 该函数只要识别到&amp;rsquo;enter&amp;rsquo;键被按下，它就会触发 createNewToDoItem 函数，代码如下所示： handleKeyPress = (e) =&amp;gt; { if (e.key === ‘Enter’) { this.createNewToDoItem(); } }; Vue 的实现方法 Vue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码： &amp;lt;div class=”ToDo-Add” @click=”createNewToDoItem()”&amp;gt;+&amp;lt;/div&amp;gt; 注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下： &amp;lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&amp;gt; 6.如何将数据传递给子组件 React 的实现方法 在 React 中，我们将 props 传递到子组件的创建处。比如： &amp;lt;ToDoItem key={key} item={todo} /&amp;gt; 此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用 this.props.item。 Vue 的实现方法 在 Vue 中，我们将 props 传递到子组件创建处的方式如下： &amp;lt;ToDoItem v-for=&amp;#34;todo in list&amp;#34; :todo=&amp;#34;todo&amp;#34; :key=&amp;#34;todo.id&amp;#34; @delete=&amp;#34;onDeleteItem&amp;#34; /&amp;gt; 我们将它们传递给子组件中的 props 数组，如：props：[&amp;lsquo;id&amp;rsquo;，&amp;rsquo;todo&amp;rsquo;]。然后可以在子组件中通过名字引用它们。 7.如何将数据发送回父组件 React 的实现方法 我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。 Vue 的实现方法 在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。 8.总结 我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。 两个应用程序的 GitHub 地址： **Vue ToDo:**https://github.com/sunil-sandhu/vue-todo **React ToDo:**https://github.com/sunil-sandhu/react-todo</description>
    </item>
    <item>
      <title>为什么不可变性在 React 中那么重要？</title>
      <link>https://zishu.me/blog/32.html/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/32.html/</guid>
      <description>根据官网文档来解释，为什么不可变性的概念在 React 中非常重要的原因，一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据 React 文档 一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据 直接修改数据 var player = {score: 1, name: &amp;#39;Jeff&amp;#39;}; player.score = 2; // player 修改后的值为 {score: 2, name: &amp;#39;Jeff&amp;#39;} 新数据替换旧数据 var player = {score: 1, name: &amp;#39;Jeff&amp;#39;}; var newPlayer = Object.assign({}, player, {score: 2}); // player 的值没有改变，但是 newPlayer 的值是 {score: 2, name: &amp;#39;Jeff&amp;#39;} // 使用对象展开语法，就可以写成： // var newPlayer = {...player, score: 2}; 不直接修改（或改变底层数据）这种方式和前一种方式的结果是一样的，这种方式有以下几点好处： 简化复杂的功能 不可变性使得复杂的特性更容易实现。在后面的章节里，我们会实现一种叫做“时间旅行”的功能。“时间旅行”可以使我们回顾井字棋的历史步骤，并且可以“跳回”之前的步骤。这个功能并不是只有游戏才会用到——撤销和恢复功能在开发中是一个很常见的需求。不直接在数据上修改可以让我们追溯并复用游戏的历史记录 跟踪数据的改变 如果直接修改数据，那么就很难跟踪到数据的改变。跟踪数据的改变需要可变对象可以与改变之前的版本进行对比，这样整个对象树都需要被遍历一次 确定在 React 中何时重新渲染 不可变性最主要的优势在于它可以帮助我们在 React 中创建 pure components。我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染</description>
    </item>
    <item>
      <title>对象，类和接口之间的关系</title>
      <link>https://zishu.me/blog/25.html/</link>
      <pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/25.html/</guid>
      <description>类是对的类型，类是具有相同属性和方法的一组集合，一个类可以对应多个对象，对象通过他们公开的方法来定义他们与外界的交互行为，而方法就形成了与外界交互的接口 类，对象和接口 1.类和对象 区别： 对象是类的一个实例。就比如一个人，他有具体的属性，身高，体重，姓名等状态，跑步，跳舞等行为 类是抽象的概念，代表一类事物的模版。对一类对象的行为和状态进行描述，抽离出其共性，形成类 关系： 类就是对事物的一种描述，对象是具体存在的一个实例 类是对的类型，类是具有相同属性和方法的一组集合，一个类可以对应多个对象 2.什么是接口？ 对象通过他们公开的方法来定义他们与外界的交互行为，而方法就形成了与外界交互的接口 更深层次的含义是：使定义和实现分离开，他是交互的具体实现的抽象化 接口是面向对象编程的基础，它是一组包含了函数方法的数据结构，他是一个比类更抽象化的东西 可以这么说，类是对象的抽象化，接口是类的抽象化 比如生活中的接口，机顶盒，人们利用它来实现收看不同频道和信号的节目，它犹如对不同类型的信息进行集合和封装的设备，最后把各种不同类型的信息转换为电视能够识别的信息。 在编程语言中的接口，实际上是不同类的封装并提供统一的外部联系通道，这样其他对象就可以利用接口来调用不同类的成员了 接口和类，实际上都是相同的数据结构 在接口中，可以声明属性，方法，事件，类型，但是不能声明变量，也就是说，接口只能定义成员，不能给成员赋值 使用接口的好处，提高代码灵活性，降低对象之间的耦合度，在实际项目中非常有用</description>
    </item>
    <item>
      <title>面向对象编程</title>
      <link>https://zishu.me/blog/15.html/</link>
      <pubDate>Thu, 12 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/15.html/</guid>
      <description>面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。 一、什么是面向对象编程 js 是基于原型的，基于面向对象编程 面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类 1.面向过程程序设计 将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。 自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用 面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。 2.面向对象程序设计 将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统 面向对象把构成问题的 transaction 分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。 想要弄明白面向对象，需要先理解类和对象的概念 《什么是类和对象？》 二、创建对象的方法 1.创建字面量和实例 window.onload = function() { // 实例 var person = new Object(); person.name = &amp;#39;小明&amp;#39;; person.age = 22; person.year = function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) }; person.year(); // 字面量 var student = { name: &amp;#39;小明&amp;#39;, age: 22, year: function () { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } } student.year(); } // 小明今年22岁了！ 两者输出的结果是一样的，控制台输出： 缺点：重复实例化对象，代码冗余高 2.工厂模式 window.onload = function() { function createObj(name, age) { var obj = new Object(); obj.name = name, obj.age = age, obj.year = function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } return obj; } var obj = createObj(&amp;#39;小明&amp;#39;, 22); obj.year(); } // 小明今年22岁了！ 优点：解决重复实例化对象的问题 缺点：无法识别对象的类型，因为所有的实例都指向一个原型 3.构造函数 window.onload = function() { function Person(name, age) { this.name = name; this.age = age; this.year = function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } } var student = new Person(&amp;#39;小明&amp;#39;, 22); student.year(); } // 小明今年22岁了！ 优点：可以识别对象的类型 缺点：多个实例重复创建方法，无法共享 4. 原型模式 window.onload = function() { function Par() {} Par.prototype = { constructor: &amp;#39;Par&amp;#39;, name: &amp;#39;小明&amp;#39;, age: 22, year: function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;) } }; var son = new Par(); son.year(); } // 小明今年22岁了！ 缺点：所有实例共享他的属性和方法，不能传参和初始化属性值 5.混合模式 (推荐使用) 是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值 先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过 prototype 获取，有一个 constructor 属性，可以指向要操作的函数对象（构造函数） 比如constructor: Par，就代表下面这个原型方法指向Par()对象（构造函数） window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;); } }; var son = new Par(&amp;#39;小明&amp;#39;, 22) son.year(); } // 小明今年22岁了！ 三、原型，原型链 1.原型对象 函数对象都具有prototype属性，它指向函数的原型对象 (浏览器内存创建的对象)，原型对象都具有constructor属性，它指向prototype属性所在的函数对象 (构造函数) window.onload = function() { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { // constructor指向对象 constructor: Par, year: function() { console.log(this.name + &amp;#39;今年&amp;#39; + this.age + &amp;#39;岁了！&amp;#39;); } }; var son = new Par(&amp;#39;小明&amp;#39;, 22) son.year(); /*********************************************/ console.log(Par.prototype) console.log(Par.prototype.constructor) /*********************************************/ } 通过控制台可以看到 构造函数的prototypr属性指向原型对象 原型对象的construcyor属性指向构造函数 当调用构造函数创建一个实例后，该实例会有一个隐藏属性__proto__ ，它指向构造函数的原型对象 console.log(son.__proto__ === Par.prototype) // true 所有的构造函数的 prototype 都是 object 类型 console.log(typeof Par.prototype) // object Function 的 prototype 是一个空函数，所有内置函数的__proto__属性都指向这个空函数 console.log(Math.__proto__) 如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过delete方法将同名属性在实例（构造函数）中彻底删除 window.onload = function () { function Par(name) { this.name = name; } Par.prototype.name = &amp;#34;张三&amp;#34;; var son = new Par(&amp;#34;李四&amp;#34;); console.log(son.name); // 李四 console.log(son.__proto__.name); // 张三 // 使用 delete 删除实例的同名属性值 console.log(delete son.name); // true console.log(son.name); // 张三 } 通过hasOwnProperty(属性名)可以判断一个属性存在于构造函数中，还是原型对象中 true表示存在构造函数中；false表示存在原型对象中 console.log(Par.hasOwnProperty(name)); // false 操作符in，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可） window.onload = function () { function Par(name, age) { this.name = name; this.age = age; } Par.prototype = { constructor: Par, year: function() { console.log(this.name + this.age) } }; var son = new Par(&amp;#39;xm&amp;#39;, &amp;#39;22&amp;#39;) son.year(); console.log(&amp;#39;name&amp;#39; in Par); // true console.log(&amp;#39;age&amp;#39; in Par); // false } 同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样 参考:《对象中是否有某一个属性 in》https://www.cnblogs.com/IwishIcould/p/12333739.html 2.__proto__和 prototype 的区别 prototype属性只有函数对象上才有，而__proto__属性所有对象都有 prototype是由函数对象指向原型对象，而__proto__是由实例指向函数对象的原型对象 原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做原型链 3.继承 原型链继承 优点：父类原型定义的属性和方法可以复用 缺点：子类实例没有自己的属性，不能向父类传递参数 function test1() { function SuperType() { this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ]; this.property = true; } SuperType.prototype = { constructor : SuperType, // 保持构造函数和原型对象的完整性 age : 15, getSuperValue : function() { return this.property; } }; function SonType() { this.property = false; } // 重写子类的原型指向父类的实例：继承父类的原型 SubType.prototype = new SuperType(); SubType.prototype = { constructor : SubType, getSonType : function() { return this.property; } }; // 优点验证 let son = new SubType(); console.log(son.age); // 15 console.log(son.getSuperValue()); // false // 缺点验证 let instance1 = new SubType(); instance1.city.push(&amp;#34;重庆&amp;#34;); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance2 = new SubType(); console.log(instance2.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] } // test1(); 构造函数继承 优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点 缺点：父类原型的属性和方法不可复用 function test2() { function SuperType(name) { this.name = name; this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ] } SuperType.prototype = { constructor : SuperType, age : 18, showInfo : function() { return this.name; } }; function SubType() { // 父类调用 call() 或者 apply() 方法和子类共用同一个 this，实现子类实例属性的继承 SuperType.call(this, &amp;#34;张三&amp;#34;); } // 优点验证 let instance = new SubType(); instance.city.push(&amp;#34;重庆&amp;#34;); console.log(instance.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance1 = new SubType(); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;] // 缺点验证 console.log(instance.age); // undefined instance.showInfo(); // son.showInfo is not a function } // test2(); 组合继承（推荐） 优点：原型的属性和方法可以复用，每个子类实例都有自己的属性 缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖 function test3() { function SuperType(name) { this.name = name; this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ] } SuperType.prototype = { constructor : SuperType, showInfo : function() { console.log(this.name + &amp;#34;今年&amp;#34; + this.age + &amp;#34;岁了&amp;#34;); } }; function SubType(name, age) { // 1. 通过构造方法继承实现实例属性的继承 SuperType.call(this, name); this.age = age; } // 2. 通过原型链继承实现原型方法的继承 SubType.prototype = new SuperType(); // 优点验证 let instance = new SubType(&amp;#34;张三&amp;#34;, 15); instance.showInfo(); // 张三今年 15 岁了 let instance1 = new SubType(); instance1.city.push(&amp;#34;重庆&amp;#34;); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance2 = new SubType(); console.log(instance2.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;] } // test3(); 寄生组合继承（推荐） 优点：解决了组合继承的缺点，效率高 缺点：基本没有 function test4() { function inheritPrototype(subType, superType) { // 1. 继承父类的原型 var prototype = Object.create(superType.prototype); // 2. 重写被污染的 construct prototype.constructor = subType; // 3. 重写子类的原型 subType.prototype = prototype; } function SuperType(name) { this.name = name; this.city = [ &amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34; ]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } // 将父类原型指向子类 inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); } // 优点验证 let instance = new SubType(&amp;#34;张三&amp;#34;, 15); instance.sayName(); // 张三 let instance1 = new SubType(); instance1.city.push(&amp;#34;重庆&amp;#34;); console.log(instance1.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;, &amp;#34;重庆&amp;#34;] let instance2 = new SubType(); console.log(instance2.city); // [&amp;#34;北京&amp;#34;, &amp;#34;上海&amp;#34;, &amp;#34;天津&amp;#34;] } // test4(); 4.ES6 新方法－－class 新的关键字class在 es6 开始被引入到 javascript 中来，class的目的就是让定义类更简单 用函数方法实现： function Person(name) { this.name = name; } Person.prototype.hello = function () { console.log(&amp;#39;Hello, &amp;#39; + this.name + &amp;#39;!&amp;#39;); } var son = new Person(&amp;#39;xm&amp;#39;) son.hello(); // Hello, xm! 用class来实现： class Person { constructor(name) { this.name = name; } hello() { console.log(&amp;#39;Hello, &amp;#39; + this.name + &amp;#39;!&amp;#39;); } } var son = new person(&amp;#39;xm&amp;#39;) son.hello(); // Hello, xm! 可以在看到，在定义class中，直接包含了构造函数constructor属性，和原型对象上的函数hello()方法，省略掉了function关键字 需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用class可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的 class 继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Person派生一个PrimaryPerson需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class PrimaryPerson extends Person { constructor(name, grade) { super(name); // 记得用 super 调用父类的构造方法！ this.grade = grade; } myGrade() { alert(&amp;#39;I am at grade &amp;#39; + this.grade); } } 注意PrimaryPerson的定义也是通过 class 关键字实现的，而extends则表示原型链对象来自Person，子类的构造函数可能会和父类的不太相同 例如，PrimaryPerson需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。 PrimaryPerson已经自动获得了父类Person的hello方法，我们又在子类中定义了新的myGrade方法。 ES6 引入的class和原有的JavaScript原型继承有什么区别呢？ 实际上它们没有任何区别，class的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 但是！ 目前并不是所有的浏览器都支持class，所以在选择的时候一定要慎重！</description>
    </item>
  </channel>
</rss>
