<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vue on 子舒的博客</title>
    <link>https://zishu.me/tags/vue/</link>
    <description>Recent content in Vue on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Apr 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://zishu.me/tags/vue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>vue 中配置 env 文件</title>
      <link>https://zishu.me/blog/226.html/</link>
      <pubDate>Wed, 24 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/226.html/</guid>
      <description>.env 命名规则。 # 开发环境 .env 文件名 .env.development # 开发环境 .env 文件名 .env.production 在 vue-cli 中，要求环境配置文件必须以 VUE_APP 开头，如下： # .env VUE_APP_BASE_URL = http://0.0.0.0 # 使用 const baseURL = process.env.VUE_APP_BASE_URL; 修改 package.json 文件，在运行指令后加上 --mode 标识。 // package.json &amp;#34;scripts&amp;#34;: { &amp;#34;dev&amp;#34;: &amp;#34;vue-cli-service serve --mode development&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;vue-cli-service build --mode production&amp;#34;, }</description>
    </item>
    <item>
      <title>无法从非 EcmaScript 模块导入命名导出</title>
      <link>https://zishu.me/blog/218.html/</link>
      <pubDate>Fri, 23 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/218.html/</guid>
      <description>https://github.com/markdown-it/markdown-it markdown-it 是一个基于 vue 的解析 markdown 语法的库。 在 vue 中引入 markdown-it 模块时遇到一个问题，dev 开发运行时报出以下错误，无法从非 EcmaScript 模块导入命名导出。 # shell error in ./node_modules/markdown-it/lib/common/utils.mjs Can&amp;#39;t import the named export &amp;#39;P&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;decode&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;decode&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/common/utils.mjs Can&amp;#39;t import the named export &amp;#39;decodeHTML&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/rules_inline/entity.mjs Can&amp;#39;t import the named export &amp;#39;decodeHTML&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;encode&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;format&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;format&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;parse&amp;#39; from non EcmaScript module (only default export is available) error in ./node_modules/markdown-it/lib/index.mjs Can&amp;#39;t import the named export &amp;#39;parse&amp;#39; from non EcmaScript module (only default export is available) 导致 import 该库出现错误，解决方案需要修改 vue.config.js // vue.config.js module.exports = { configureWebpack: { module: { rules: [{ test: /\.mjs$/, include: /node_modules/, type: &amp;#34;javascript/auto&amp;#34; }] } }, }; 参考文献：https://github.com/vuejs/pinia/issues/675</description>
    </item>
    <item>
      <title>this.$set 给 vue 数组添加数据</title>
      <link>https://zishu.me/blog/186.html/</link>
      <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/186.html/</guid>
      <description>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性，它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。 如果直接给数组添加对象，视图不会更新，但是可以输出正确的值；只有通过 this.$set 覆盖才可以更新视图。 for (let i = 0; i &amp;lt; this.data.length; i++) { // this.data[i].state = false; this.$set(this.data[i], &amp;#39;state&amp;#39;, false) }</description>
    </item>
    <item>
      <title>在 vue 中制作 canvas 波浪图</title>
      <link>https://zishu.me/blog/111.html/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/111.html/</guid>
      <description>新建组件 Canvas.vue 。 // @/components/Canvas.vue &amp;lt;template&amp;gt; &amp;lt;div :style=&amp;#34;{ height: waveAllHeight + &amp;#39;px&amp;#39;, background: bgColor }&amp;#34; class=&amp;#34;wave&amp;#34;&amp;gt; &amp;lt;canvas id=&amp;#34;wave1&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;canvas id=&amp;#34;wave2&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;canvas id=&amp;#34;wave3&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { name: &amp;#34;Canvas&amp;#34;, props: { bgColor: { default: &amp;#34;none&amp;#34;, }, // 背景色 waveAllHeight: { default: 160 }, // 波浪的整体高度 waveCount: { default: 2 }, // 波峰个数 waveHeight: { default: 50 }, // 波浪起伏高度 // 波浪颜色 waveColor: { default () { return [ &amp;#34;#f3f3f3&amp;#34;, &amp;#34;#f3f3f3&amp;#34;, &amp;#34;#f3f3f3&amp;#34;, ]; }, }, // 波浪速率 waveTime: { default () { return [4000, 4000, 4000]; }, }, }, data () { return {}; }, mounted () { this.wavePlay(&amp;#34;wave1&amp;#34;, 140, this.waveColor[0], this.waveTime[0]); this.wavePlay(&amp;#34;wave2&amp;#34;, 140, this.waveColor[1], this.waveTime[1]); this.wavePlay(&amp;#34;wave3&amp;#34;, 140, this.waveColor[2], this.waveTime[2]); }, methods: { wavePlay ($canvasID, $progress, $maveColor, $time) { const that = this; let waveWidth = 3300, // 波浪长度 offset = 0, waveHeight = that.waveHeight, // 波浪起伏高度 waveCount = that.waveCount, // 波浪个数 startX = -1200, startY = 212, // canvas 高度 progress = $progress, // 波浪位置高度 d2 = waveWidth / waveCount, // 单个波浪的宽度 d = d2 / 2, hd = d / 2, c = document.getElementById($canvasID), ctx = c.getContext(&amp;#34;2d&amp;#34;); c.width = 1920; // 画布宽度 c.height = that.waveAllHeight; // 画布高度 function move () { offset -= 5; if (-1 * offset === d2) { offset = 0; } ctx.clearRect(0, 0, c.width, c.height); ctx.fillStyle = $maveColor; // 画布填充色 ctx.beginPath(); let offsetY = startY - progress; // 绘制贝塞尔曲线 ctx.moveTo(startX - offset, offsetY); // 开始点 for (let i = 0; i &amp;lt; waveCount; i++) { let dx = i * d2; let offsetX = dx + startX - offset; ctx.quadraticCurveTo( offsetX + hd, offsetY + waveHeight, offsetX + d, offsetY ); ctx.quadraticCurveTo( offsetX + hd + d, offsetY - waveHeight, offsetX + d2, offsetY ); } ctx.lineTo(startX + waveWidth, 3000); ctx.lineTo(startX, 0); ctx.fill(); setTimeout(move, $time / 60); // 速度 } move(); }, }, }; &amp;lt;/script&amp;gt; &amp;lt;style scoped lang=&amp;#34;scss&amp;#34;&amp;gt; .wave { width: 100%; height: 100%; position: relative; top: 0; left: 0; margin-top: -8%; canvas { width: 100%; opacity: 1; position: absolute; top: 0; left: 0; } } @media (max-width: 900px) { .wave { display: none; } } &amp;lt;/style&amp;gt;</description>
    </item>
    <item>
      <title>在 vue 中使用 axios 调用数据</title>
      <link>https://zishu.me/blog/71.html/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/71.html/</guid>
      <description>如何在 vue 中完成一次接口的调用？首选就是 axios，方便快捷又好用，支持各种 api ,封装也很方便。 先用 node 安装一下。 npm install axios 然后在 main.js 文件中引入。 import axios from &amp;#39;axios&amp;#39; import VueAxios from &amp;#39;vue-axios&amp;#39; Vue.use(VueAxios, axios) 以我的一个工程目录作为实例，看一下代码。 // ListThere.vue // html 代码 ... &amp;lt;div&amp;gt;{{ info }}&amp;lt;/div&amp;gt; ... // js 代码 import axios from &amp;#34;axios&amp;#34;; export default { name: &amp;#34;ListThere&amp;#34;, data() { return { ... }; }, components: { ... }, methods: { ... }, mounted() { axios .get(&amp;#34;http://api.h-camel.com/api?mod=interview&amp;amp;ctr=issues&amp;amp;act=today&amp;#34;) .then((response) =&amp;gt; (this.info = response)) }, }; 数据成功的被取到，然后需要将它在页面中展示出来。使用 vue 自带的 v-for 列表渲染。 &amp;lt;ul class=&amp;#34;list-api-show&amp;#34;&amp;gt; &amp;lt;li v-for=&amp;#34;(item, index) in show&amp;#34; :key=&amp;#34;index&amp;#34;&amp;gt; {{ item.title }} &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 然后通过 axios 把数据指向 v-for. mounted() { axios // ... .then((response) =&amp;gt; (this.show = response.data.result.today)) } 数据成功取出然后展示在 v-for 里面。 当然了，这是成功的情况，加入失败了呢？我们需要浏览器给出提示，所以 axios 给出了一个 api &amp;mdash; err 语法。 mounted() { axios // ... .catch(function (error) { if (error.response) { console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); console.log(&amp;#39;err&amp;#39;) } else if (error.request) { console.log(error.request); console.log(&amp;#39;err&amp;#39;) } else { console.log(&amp;#39;Error&amp;#39;, error.message); console.log(&amp;#39;err&amp;#39;) } console.log(error.config); console.log(&amp;#39;err&amp;#39;) }); } 如果接口有问题，或者我们调用时代码写错了，都会给出报错提示，具体什么样的错误会有什么样的警告，需要我们一一去经历摸索。</description>
    </item>
    <item>
      <title>使用 React 与 Vue 创建同一款 App，差别究竟有多大？</title>
      <link>https://zishu.me/blog/43.html/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/43.html/</guid>
      <description>关于 React 框架 和 Vue 框架 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？ 转载于：https://blog.csdn.net/csdnnews/article/details/81880378 原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd 作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 译者：安翔，责编：屠敏 众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。 于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。 很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。 1.目标 我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面）构建，React 使用 create-react-app，Vue 使用 vue-cli。 两个应用程序的外观如下： 两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构： 你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。 两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。 在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观： 现在让我们正式开始，深入其中的细节！ 2.如何修改数据 首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象： vue 数据对象 React 状态对象 从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。 假设我们有一个名为 name: ‘Sunil’的数据元素。 在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name =&amp;lsquo;John&amp;rsquo; 来更新它。这样一来，名字就被成功改为了“Jhon”。 在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name =&amp;lsquo;John&amp;rsquo;，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：&amp;lsquo;John&amp;rsquo;})。 虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。那么为什么 React 没有进行简化，为什么需要 setState 呢？Revanth Kumar 对此做出了解释： “这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。&amp;quot; 3.添加新的待办事项 React 的实现方法 createNewToDoItem = () =&amp;gt; { this.setState( ({ list, todo }) =&amp;gt; ({ list: [ ...list, { todo } ], todo: &amp;#39;&amp;#39; }) ); }; 在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟： &amp;lt;input type=&amp;#34;text&amp;#34; value={this.state.todo} onChange={this.handleInput}/&amp;gt; 只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下： handleInput = e =&amp;gt; { this.setState({ todo: e.target.value }); }; 现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的 todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加 todo。整个列表是通过使用扩展运算符添加的。 最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。 Vue 的实现方法 createNewToDoItem() { this.list.push( { &amp;#39;todo&amp;#39;: this.todo } ); this.todo = &amp;#39;&amp;#39;; } 在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下： &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;todo&amp;#34;/&amp;gt; V-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：&amp;rsquo; &amp;lsquo;。如果已经存在数据，例如 todo：&amp;lsquo;添加文本处&amp;rsquo;，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。 因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中，然后将 todo 改为空字符串。 4.删除待办事项 React 的实现方法 deleteItem = indexToDelete =&amp;gt; { this.setState(({ list }) =&amp;gt; ({ list: list.filter((toDo, index) =&amp;gt; index !== indexToDelete) })); }; 尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递： &amp;lt;ToDoItem deleteItem={this.deleteItem.bind(this, key)}/&amp;gt; 这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem。然后，在 ToDoItem 组件内部，我们执行以下操作： &amp;lt;div className=”ToDoItem-Delete” onClick={this.props.deleteItem}&amp;gt;-&amp;lt;/div&amp;gt; 想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。 Vue 的实现方法 onDeleteItem(todo){ this.list = this.list.filter(item =&amp;gt; item !== todo); } Vue 的实现方法稍有不同，我们需要做到以下三点： 首先，在元素上调用函数： &amp;lt;div class=”ToDoItem-Delete” @click=”deleteItem(todo)”&amp;gt;-&amp;lt;/div&amp;gt; 然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为 ToDoItem.vue），如下所示： deleteItem(todo) { this.$emit(&amp;#39;delete&amp;#39;, todo) } 之后，你会发现，当我们添加 ToDo.vue 的 ToDoItem.vue 时，实际上引用了一个函数： &amp;lt;ToDoItem v-for=&amp;#34;todo in list&amp;#34; :todo=&amp;#34;todo&amp;#34; @delete=&amp;#34;onDeleteItem&amp;#34; // &amp;lt;-- this :) :key=&amp;#34;todo.id&amp;#34; /&amp;gt; 这就是所谓的自定义事件监听器。它会监听任何使用 &amp;lsquo;delete&amp;rsquo; 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组，以删除被点击的待办事项。 在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示： &amp;lt;div class=”ToDoItem-Delete” @click=”$emit(‘delete’, todo)”&amp;gt;-&amp;lt;/div&amp;gt; 如果你喜欢，这样做可以把 3 步减少到 2 步。 React 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。 5.如何传递事件监听器 React 的实现方法 事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下： &amp;lt;div className=”ToDo-Add” onClick={this.createNewToDoItem}&amp;gt;+&amp;lt;/div&amp;gt; 非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下： &amp;lt;input type=”text” onKeyPress={this.handleKeyPress}/&amp;gt; 该函数只要识别到&amp;rsquo;enter&amp;rsquo;键被按下，它就会触发 createNewToDoItem 函数，代码如下所示： handleKeyPress = (e) =&amp;gt; { if (e.key === ‘Enter’) { this.createNewToDoItem(); } }; Vue 的实现方法 Vue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码： &amp;lt;div class=”ToDo-Add” @click=”createNewToDoItem()”&amp;gt;+&amp;lt;/div&amp;gt; 注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下： &amp;lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&amp;gt; 6.如何将数据传递给子组件 React 的实现方法 在 React 中，我们将 props 传递到子组件的创建处。比如： &amp;lt;ToDoItem key={key} item={todo} /&amp;gt; 此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用 this.props.item。 Vue 的实现方法 在 Vue 中，我们将 props 传递到子组件创建处的方式如下： &amp;lt;ToDoItem v-for=&amp;#34;todo in list&amp;#34; :todo=&amp;#34;todo&amp;#34; :key=&amp;#34;todo.id&amp;#34; @delete=&amp;#34;onDeleteItem&amp;#34; /&amp;gt; 我们将它们传递给子组件中的 props 数组，如：props：[&amp;lsquo;id&amp;rsquo;，&amp;rsquo;todo&amp;rsquo;]。然后可以在子组件中通过名字引用它们。 7.如何将数据发送回父组件 React 的实现方法 我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。 Vue 的实现方法 在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。 8.总结 我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。 两个应用程序的 GitHub 地址： **Vue ToDo:**https://github.com/sunil-sandhu/vue-todo **React ToDo:**https://github.com/sunil-sandhu/react-todo</description>
    </item>
    <item>
      <title>vue 学习笔记 (3)－－computed, watch，calss, style</title>
      <link>https://zishu.me/blog/29.html/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/29.html/</guid>
      <description>一、计算属性 computed 1.例子 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{revermessage}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, computed: { revermessage: function() { return this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) } } }) &amp;lt;/script&amp;gt; 声明一个计算属性severmessage，在computed中被指向对message进行一些方法操作后的返回值 此时vm.severmessage依赖于vm.message的变化，对message改变数据，会引起severmessage的更新 2.计算属性缓存和方法 还可以通过在表达式中调用方法来达到想要的效果 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{revermessage()}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, methods: { revermessage: function() { return this.message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) } } }) &amp;lt;/script&amp;gt; 经过测试，两者的结果是一样的 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的 区别是：计算属性是基于他们的响应式依赖进行缓存的，只有当响应式依赖，也就是message发生改变时才会重新求值，就意味着，只要message还没改变，多次访问revermessage计算属性只会返回之前计算结果的缓存，而不是直接执行计算属性的函数 而方法，在每次触发重新渲染时，调用方法都会执行一次函数，这就多了一份开销 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代 3.计算属性和侦听属性 vue 还有一种方式来观测 vue 实例上的数据变动：侦听属性－－watch &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{fullname}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { firstname: &amp;#39;a&amp;#39;, lastname: &amp;#39;b&amp;#39;, fullname: &amp;#39;ab&amp;#39; }, watch: { firstname: function(val) { this.fullName = val + &amp;#39; &amp;#39; + this.lastName }, lastname: function(val) { this.fullName = this.firstName + &amp;#39; &amp;#39; + val } } }) &amp;lt;/script&amp;gt; 使用过程是极其繁琐且重复的，再来用计算属性试一下 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{fullname}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { firstname: &amp;#39;a&amp;#39;, lastname: &amp;#39;b&amp;#39; }, computed: { fullname: function() { return this.firstname + this.lastname } } }) &amp;lt;/script&amp;gt; 很简单快速的就得到了我们想要的函数表达式 4.计算属性的 setter computed: { fullName: { // getter get: function () { return this.firstName + &amp;#39; &amp;#39; + this.lastName }, // setter set: function (newValue) { var names = newValue.split(&amp;#39; &amp;#39;) this.firstName = names[0] this.lastName = names[names.length - 1] } } } 现在在控制台输入vm.fullName = &#39;John Doe&#39;，页面会响应，并且setter会被调用，vm.firstname和vm.lastname也会相应地被更新 二、绑定 class 和 style 1.对象语法 可以给v-bind:class传入一个对象，动态的切换class &amp;lt;div v-bind:class=&amp;#34;{active: ok}&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 可以通过控制ok的布尔值来动态的控制 class 还可以创建多个字段，并且不影响普通的className的存在 html: &amp;lt;div class=&amp;#34;static&amp;#34; v-bind:class=&amp;#34;{ active: isActive, &amp;#39;text-danger&amp;#39;: hasError }&amp;#34; &amp;gt;&amp;lt;/div&amp;gt; data: data{ isActive: true, hasError: false } 结果为： &amp;lt;div class=&amp;#34;static active&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 当isActive或者hasError变化时，class 列表将相应地更新。例如，如果hasError的值为true，class 列表将变为&amp;quot;static active text-danger&amp;quot;。 绑定的数据对象也不必直接写在内联模板里 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-bind:class=&amp;#34;classobject&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { classobject: { active: true, &amp;#39;text-danger&amp;#39;: true } }, }) &amp;lt;/script&amp;gt; &amp;lt;!-- &amp;lt;div class=&amp;#34;active text-danger&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; --&amp;gt; 如果className有特殊符号，必须加上引号&#39;&#39;，或者&amp;quot;&amp;quot; 2.数组语法 我们可以把一个数组传给v-bind:class，以应用一个 class 列表 &amp;lt;div v-bind:class=&amp;#34;[activeClass, errorClass]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; data: { activeClass: &amp;#39;active&amp;#39;, errorClass: &amp;#39;text-danger&amp;#39; } 渲染为： &amp;lt;div class=&amp;#34;active text-danger&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 3.用在组件上 当在一个自定义组件上使用classproperty 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。 Vue.component(&amp;#39;my-component&amp;#39;, { template: &amp;#39;&amp;lt;p class=&amp;#34;foo bar&amp;#34;&amp;gt;Hi&amp;lt;/p&amp;gt;&amp;#39; }) 然后在使用的使用的时候添加了一些class： &amp;lt;my-component class=&amp;#34;baz boo&amp;#34;&amp;gt;&amp;lt;/my-component&amp;gt; html 将会被渲染成： &amp;lt;p class=&amp;#34;foo bar baz boo&amp;#34;&amp;gt;Hi&amp;lt;/p&amp;gt; 对于带数据绑定的class也同样适用 &amp;lt;my-component v-bind:class=&amp;#34;{ active: isActive }&amp;#34;&amp;gt;&amp;lt;/my-component&amp;gt; 当isActive为 truthy 时，HTML 将被渲染成为： &amp;lt;p class=&amp;#34;foo bar active&amp;#34;&amp;gt;Hi&amp;lt;/p&amp;gt; 4.绑定内联样式 style v-bind:style的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式或带引号的短横线来命名 &amp;lt;div v-bind:style=&amp;#34;{ color: activeColor, fontSize: fontSize + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; js: data: { activeColor: &amp;#39;red&amp;#39;, fontSize: 30 } 或者直接绑定到一个对象，会让模板更加清晰 &amp;lt;div v-bind:style=&amp;#34;styleObject&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; js: data: { styleObject: { color: &amp;#39;red&amp;#39;, fontSize: &amp;#39;13px&amp;#39; } } 也可以将多个对象应用到一个元素上 &amp;lt;div v-bind:style=&amp;#34;[baseStyles, overridingStyles]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 自动添加前缀 当v-bind:style需要使用浏览器前缀的时候，如：-webkit-等，vue 会自动侦测并帮生成相应的前缀</description>
    </item>
    <item>
      <title>vue 学习笔记 (2)－－vue 实例和模板语法</title>
      <link>https://zishu.me/blog/28.html/</link>
      <pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/28.html/</guid>
      <description>一、vue 实例 1.创建 vue 实例 一个 vue 实例应该通过new Vue来创建根实例，所有的 vue 组件其实都是 vue 实例 var vm = new Vue({ ... }) 当一个实例被创建时，data对象中的 property 都被加入到 vue 的响应式系统中，当值发生改变时，试图也会改变 var data = {a: 1} var vm = new Vue({ data: data }) 此时在控制台输入vm.a == data.a会返回 true，变量data已经被赋给vue实例中的data对象了 同时，对两个对象的数据进行操作改变也会影响到另一个 vm.a = 2 // data.a = 2 data.a = 3 // vm.a = 3 当数据改变时，视图也会重新渲染，如果在 vue 实例被创建后，又添加了一个新的 property，则不会被加入到响应式系统中 如果一开始就知道后面会添加一个 property，但是一开始不存在或为空，需要设置一些初始值 data: { newTodoText: &amp;#39;&amp;#39;, visitCount: 0, hideCompletedTods: fasle, todos: [], error: null } 使用 Object.freeze() 方法的时候，无法修改数据引起视图变化 Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var data = {message: &amp;#39;hello,wolrd&amp;#39;} Object.freeze(data) var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: data }) &amp;lt;/script&amp;gt; 在控制台改变vm.message的值会直接报错，因为 data 对象已经被冻结了，不可改变 vm.$data 代表 vue 实例观察的数据对象 console.log(vm.$data) // 返回数据对象的数组形式 var data = { a: 1 } var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: data }) vm.$data === data // true vm.$el === document.getElementById(&amp;#39;app&amp;#39;) // true 2.生命周期函数 每个实例在被创建的时候，都要经历一些初始化过程，比如：设置数据监听，编译模板，将实例挂载到 dom，更新 dom 等 在这个过程中会运行一些叫做生命周期的钩子函数，可以在不同阶段添加自己需要的代码 比如created钩子可以用来表示一个实例被创建之后执行的代码 new Vue({ data: { a: 1 }, created: function () { console.log(&amp;#39;a is: &amp;#39; + this.a) } }) // &amp;#34;a is: 1&amp;#34; this用来指向 vm 实例 但是不要在 property 或者回调上使用箭头函数，created: () =&amp;gt; console.log(this.a)，因为箭头函数没有this的概念，他会把this当作变量一直向上级作用域查找，经常产生Uncaught TypeError: Cannot read property of undefined或Uncaught TypeError: this.myMethod is not a function之类的报错 二、模板语法 1.插值 最简单的就是 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,world&amp;#39; } }) &amp;lt;/script&amp;gt; &amp;lt;/script&amp;gt; 。。。 下面这段代码给input绑定了一个disabled属性，但是通过ok的真伪来控制属性是否渲染 当ok为fasle,null,undefined值时，属性都不会被渲染，有点类似于v-if，但是这种写法只是针对属性 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; v-bind:disabled=&amp;#34;ok&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39;, ok: false } }) &amp;lt;/script&amp;gt; 在模板语法中还可以使用 javascript 表达式 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{number + 1}}&amp;lt;/div&amp;gt; &amp;lt;div v-bind:id=&amp;#34;&amp;#39;list-&amp;#39; + id&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;)}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { number: 2, id: &amp;#39;li&amp;#39;, message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; 每个模板只能包含一个 javascript 表达式，如果有多个，则不会生效 &amp;lt;!-- 这是语句，不是表达式 --&amp;gt; {{ var a = 1 }} &amp;lt;!-- 流控制也不会生效，请使用三元表达式 --&amp;gt; {{ if (ok) { return message } }} 2.指令 参数 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind指令可以用于响应式地更新 HTML attribute： &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;a v-bind:href=&amp;#34;url&amp;#34;&amp;gt;百度&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { url: &amp;#39;https://www.baidu.com&amp;#39; } }) &amp;lt;/script&amp;gt; 在这里href是参数，告知v-bind指令将该元素的hrefattribute 与表达式url的值绑定 另一个例子是v-on指令，它用于监听 dom 事件 &amp;lt;a v-on:click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; 动态参数 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数 &amp;lt;!--注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。--&amp;gt; &amp;lt;a v-bind:[attributeName]=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; 这里的attributeName会被作为一个 javascript 表达式进行动态求值，最终结果被作为参数来使用 比如：vue 实例中有一个attributeName属性其值为href，则这个绑定将等价于v-bind:href &amp;lt;a v-bind:href=&amp;#34;url&amp;gt;...&amp;lt;/a&amp;gt; 也可以使用动态的事件名绑定监听函数 &amp;lt;a v-on:[eventName]=&amp;#34;doSomething&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; 如果eventName值为click，则该绑定等价于v-on:click=&amp;quot;doSomething&amp;quot;，一个鼠标点击事件 对动态参数的值的约束 动态参数预期会求出一个字符串，异常情况下值为null，这个特殊的null值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 对动态参数表达式的约束 动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的，例如： &amp;lt;!-- 这会触发一个编译警告 --&amp;gt; &amp;lt;a v-bind:[&amp;#39;foo&amp;#39; + bar]=&amp;#34;value&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; 因此，尽量不要使用空格和引号的表达式，或者采用计算属性来替代这种复杂表达式 在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写 修饰符 修饰符是以.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，例如，.prevent修饰符告诉v-on指令对于触发的事件调用event.preentDefault() &amp;lt;form v-on:submit.prevent=&amp;#34;onSubmit&amp;#34;&amp;gt;...&amp;lt;/form&amp;gt; 3.缩写 v-前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v-前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v-前缀也变得没那么重要了。因此，Vue 为v-bind和v-on这两个最常用的指令，提供了特定简写 v-bind &amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-bind:href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;a :href=&amp;#34;url&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt; &amp;lt;a :[key]=&amp;#34;url&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; v-on &amp;lt;!-- 完整语法 --&amp;gt; &amp;lt;a v-on:click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;a @click=&amp;#34;doSomething&amp;#34;&amp;gt;...&amp;lt;/a&amp;gt; &amp;lt;!-- 动态参数的缩写 (2.6.0+) --&amp;gt; &amp;lt;a @[event]=&amp;#34;doSomething&amp;#34;&amp;gt; ... &amp;lt;/a&amp;gt; 它们看起来可能与普通的 HTML 略有不同，但:与@对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</description>
    </item>
    <item>
      <title>vue 学习笔记 (1)－－什么是 vue?</title>
      <link>https://zishu.me/blog/27.html/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/27.html/</guid>
      <description>一、什么是 vue? 练习时使用，最新版本 &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 生产时使用，明确版本号的版本，避免造成不可预见的问题 &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue@2.6.12&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; hello world &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; {{message}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,world&amp;#39; } }) &amp;lt;/script&amp;gt; 1.v-指令 v-bind－－绑定属性 &amp;lt;div id=&amp;#34;app-2&amp;#34;&amp;gt; &amp;lt;span v-bind:title=&amp;#34;message&amp;#34;&amp;gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;页面加载于 &amp;#39; + new Date().toLocaleString() } }) &amp;lt;/script&amp;gt; v-bind是 vue 特有的提供的属性，他会在 dom 上应用一个响应式的操作 打开 console，输入app.message = &amp;quot;hello&amp;quot;，页面会改变内容只显示hello 又或者输入app.message = false，内容会直接不显示 vue 官网例子： &amp;lt;!-- 绑定一个 attribute --&amp;gt; &amp;lt;img v-bind:src=&amp;#34;imageSrc&amp;#34;&amp;gt; &amp;lt;!-- 动态 attribute 名 (2.6.0+) --&amp;gt; &amp;lt;button v-bind:[key]=&amp;#34;value&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;!-- 缩写 --&amp;gt; &amp;lt;img :src=&amp;#34;imageSrc&amp;#34;&amp;gt; &amp;lt;!-- 动态 attribute 名缩写 (2.6.0+) --&amp;gt; &amp;lt;button :[key]=&amp;#34;value&amp;#34;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;!-- 内联字符串拼接 --&amp;gt; &amp;lt;img :src=&amp;#34;&amp;#39;/path/to/images/&amp;#39; + fileName&amp;#34;&amp;gt; &amp;lt;!-- class 绑定 --&amp;gt; &amp;lt;div :class=&amp;#34;{ red: isRed }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :class=&amp;#34;[classA, classB]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :class=&amp;#34;[classA, { classB: isB, classC: isC }]&amp;#34;&amp;gt; &amp;lt;!-- style 绑定 --&amp;gt; &amp;lt;div :style=&amp;#34;{ fontSize: size + &amp;#39;px&amp;#39; }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div :style=&amp;#34;[styleObjectA, styleObjectB]&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- 绑定一个全是 attribute 的对象 --&amp;gt; &amp;lt;div v-bind=&amp;#34;{ id: someProp, &amp;#39;other-attr&amp;#39;: otherProp }&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- 通过 prop 修饰符绑定 DOM attribute --&amp;gt; &amp;lt;div v-bind:text-content.prop=&amp;#34;text&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&amp;gt; &amp;lt;my-component :prop=&amp;#34;someThing&amp;#34;&amp;gt;&amp;lt;/my-component&amp;gt; &amp;lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&amp;gt; &amp;lt;child-component v-bind=&amp;#34;$props&amp;#34;&amp;gt;&amp;lt;/child-component&amp;gt; &amp;lt;!-- XLink --&amp;gt; &amp;lt;svg&amp;gt;&amp;lt;a :xlink:special=&amp;#34;foo&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/svg&amp;gt; v-if－－控制元素的显示隐藏 刚才写了，通过app.message = false，可以让message代表的内容处于隐藏状态，但是控制的只能是通过v-for引入的内容，无法直接让元素隐藏 其实，vue 中还有一个专门控制元素显示隐藏的指令－－v-if &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;span v-if=&amp;#34;show&amp;#34;&amp;gt; {{message}} &amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,world&amp;#39;, show: true } }) &amp;lt;/script&amp;gt; 给元素绑定一个指令v-if = &amp;quot;show&amp;quot;，然后在 data 中控制show的布尔值，true 显示，false 隐藏 同时还有这个功能的指令v-show，根据表达式之真假值，切换元素的display CSS property，也是通过绑定的布尔值来显示隐藏 但是v-if和v-show有些区别 (1) v-if 是控制元素是否渲染最终控制元素的显示隐藏，适用于切换频率低的情况 (2) v-show 不管显示隐藏都渲染，然后通过布尔值绑定display: none属性，适用于切换频率高的情况 注意：v-show不支持&amp;lt;tempalte&amp;gt;元素，也不支持v-else 搭配用法 v-else和v-else-if 可以通过使用v-else达到v-if的效果，必须和v-if搭配使用，比如： &amp;lt;div v-if=&amp;#34;1&amp;gt;2&amp;#34;&amp;gt; hello &amp;lt;/div&amp;gt; &amp;lt;div v-else&amp;gt; hi &amp;lt;/div&amp;gt; 如果v-if不成立，执行v-else，也就是显示 v-else 里面的内容 是不是有点 javascript 里面if函数的感觉了 v-else-if用法大致一样，必须和v-if和v-else搭配使用 v-for－－遍历数组并显示到页面上 v-for算是 vue 的核心指令之一了把，主要是渲染一个项目列表的 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-for=&amp;#34;item in list&amp;#34;&amp;gt;{{item.message}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { list: [ {message: &amp;#39;html&amp;#39;}, {message: &amp;#39;css&amp;#39;} ] } }) &amp;lt;/script&amp;gt; 可以直接把列表数据循环输出 并且在控制台中通过push()还能添加新的列表项 app.list.push({message: &amp;#34;js&amp;#34;}) vue 对数据操作，就是这么神奇 不推荐v-for和v-if同时使用，因为v-for拥有更高的优先级 v-on－－绑定事件监听器 即绑定事件，通过v-on给 div 绑定了一个点击事件，注意，在reverseMessage方法中，我们更新了应用的状态，但是吗诶呀触碰到 dom，直接通过 vue 来进行处理，编写代码时只需要关注逻辑层即可 v-on:click=&amp;quot;messagenone&amp;quot;，然后在methods里面写上事件方法 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-on:click=&amp;#34;messagenone&amp;#34; id=&amp;#34;demo&amp;#34;&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,wolrd&amp;#39; }, methods: { messagenone: function() { var demo = document.getElementById(&amp;#39;demo&amp;#39;); demo.innerHTML = &amp;#39;&amp;#39; } } }) &amp;lt;/script&amp;gt; v-model－－数据的双向绑定 vue 还提供了v-model指令，它能轻松实现表单输入和应用状态之间的双向绑定 可使用场景：标签 input, select, textarea 和 components &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;message&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; v-text 更新元素的内容 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div v-text=&amp;#34;message&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; 上面的 div 和下面的 div 内容跟随一致变化 v-html－－更新元素的 innerHTML 不建议使用，在网站上动态渲染 html 是非常危险的，容易导致XXS 攻击，不能用在用户提交的内容上，如果必须使用 v-html，可以考虑通过使用组件来代替 v-pre 跳过绑定的元素和他的子元素的编译，直接显示原始内容 跳过没有指令的节点不进行编译，直接显示内容，会加快页面的响应 v-cloak 在编译没有编译完成之前，模板处于的状态 &amp;lt;style&amp;gt;v-cloak] { display: none; }&amp;lt;/style&amp;gt; &amp;lt;div v-cloak&amp;gt; {{message}} &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39; } }) &amp;lt;/script&amp;gt; 上述代码表示的含义是，如果网络不好，{{message}}模板代表的hello,world还没有编译成功，此时{{message}}处于隐藏状态，当编译完成，页面直接显示hello,world v-once－－一次性渲染 绑定该指令的元素及其子元素只会进行一次渲染，之后页面的第二次渲染会将其视为静态资源并跳过，可以用来优化性能 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;span v-once&amp;gt;{{message}}&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var vm = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;hello,wolrd&amp;#39;, } }) &amp;lt;/script&amp;gt; 使用场景：表单提交。可防止用户在请求未及时响应时，多次提交~ 2.组件化构建应用 组件化也是 vue 的核心机制之一，它允许我们使用小型，可复用的组件来构建大型应用 在 vue 里，一个组件本质上是一个拥有预定义选项的一个 vue 实例。在 vue 中注册组件很简单 // 定义名为 todo-item 的新组件 Vue.component(&amp;#39;todo-item&amp;#39;, { template: &amp;#39;&amp;lt;li&amp;gt;这是个待办项&amp;lt;/li&amp;gt;&amp;#39; }) var app = new Vue(...) 现在可以用它构建另一个组件模板 &amp;lt;ol&amp;gt; &amp;lt;!-- 创建一个 todo-item 组件的实例 --&amp;gt; &amp;lt;todo-item&amp;gt;&amp;lt;/todo-item&amp;gt; &amp;lt;/ol&amp;gt; 但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个props Vue.component(&amp;#39;todo-item&amp;#39;, { // todo-item 组件现在接受一个 // &amp;#34;props&amp;#34;，类似于一个自定义 attribute。 // 这个 props 名为 todo。 props: [&amp;#39;todo&amp;#39;], template: &amp;#39;&amp;lt;li&amp;gt;{{ todo.text }}&amp;lt;/li&amp;gt;&amp;#39; }) 现在，我们可以使用v-bind指令将待办项传到循环输出的每个组件中 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的，我们也需要为每个组件提供一个key &amp;lt;div id=&amp;#34;app-7&amp;#34;&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;todo-item v-for=&amp;#34;item in groceryList&amp;#34; v-bind:todo=&amp;#34;item&amp;#34; v-bind:key=&amp;#34;item.id&amp;#34; &amp;gt;&amp;lt;/todo-item&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; Vue.component(&amp;#39;todo-item&amp;#39;, { props: [&amp;#39;todo&amp;#39;], template: &amp;#39;&amp;lt;li&amp;gt;{{ todo.text }}&amp;lt;/li&amp;gt;&amp;#39; }) var app7 = new Vue({ el: &amp;#39;#app-7&amp;#39;, data: { groceryList: [ { id: 0, text: &amp;#39;蔬菜&amp;#39; }, { id: 1, text: &amp;#39;奶酪&amp;#39; }, { id: 2, text: &amp;#39;随便其它什么人吃的东西&amp;#39; } ] } }) 尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过prop接口与父单元进行了良好的解耦。我们现在可以进一步改进 组件，提供更为复杂的模板和逻辑，而不会影响到父单元 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;app-nav&amp;gt;&amp;lt;/app-nav&amp;gt; &amp;lt;app-view&amp;gt; &amp;lt;app-sidebar&amp;gt;&amp;lt;/app-sidebar&amp;gt; &amp;lt;app-content&amp;gt;&amp;lt;/app-content&amp;gt; &amp;lt;/app-view&amp;gt; &amp;lt;/div&amp;gt;</description>
    </item>
    <item>
      <title>vue 使用 cli 脚手架构建项目工程</title>
      <link>https://zishu.me/blog/24.html/</link>
      <pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/24.html/</guid>
      <description>vue 使用 cli 脚手架构建项目工程，执行的命令以及遇到的相关的问题 1.下载安装 node 测试一下是否成功安装， $ node -v // 返回下载的版本号 2.安装 webpack 环境 $ npm install webpack -g // 如果失败，可能是因为用户没有权限 // 使用下面这种，管理员权限 $ sudo npm install webpack -g 如果返回版本号代表成功，如果没有，则需要输入下面的命令 $ npm install webpack webpack-cli -g webpack 4.X 开始，需要安装 webpack-cli 依赖 3.全局安装 vue-cli $ npm install --global vue-cli // 如果失败，使用sudo $ sudo npm install --global vue-cli 安装完成之后，输入 $ vue -V 如果返会版本号，说明安装成功 4.构建项目 前面那些命令执行完之后，就可以构建 ci 项目了，找到我们想要放置项目的文件夹，进入终端，cd 到这个文件夹 输入命令： $ vue init webpack vuedemo // 名字自己根据要求起,vuedemo Project name (vuedomo)： &amp;mdash;&amp;ndash;项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错 Sorry, name can no longer contain capital letters） Project description (A Vue.js project)： &amp;mdash;-项目描述，也可直接点击回车，使用默认名字 Author ()： &amp;mdash;-作者，输入你的大名 Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了 Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n) 是否安装 vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n) 是否使用 ESLint 管理代码，ESLint 是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。 接下来也是选择题 Pick an ESLint preset (Use arrow keys) 选择一个 ESLint 预设，编写 vue 项目时的代码风格，直接 y 回车 Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试，我选择安装 y 回车 Setup e2e tests with Nightwatch(Y/n)? 是否安装 e2e 测试，我选择安装 y 回车 然后就是缓慢的构建过程，等到构建完成，cd 进入构建的项目 $ cd vuedemo 然后安装需要的依赖 $ npm install 5.运行项目 运行命令，看看是否能够成功运行项目 $ npm run dev 根据提示，浏览器输入http://localhost:8080 如果端口打不开，肯能是因为被占用了，需要修改配置文件，config &amp;gt; index.js 查看项目工程目录 6.其他 一些其他相关的指令 $ npm run build // 项目完成之后打包 打包完成之后，会在根目录下生成一个 dist 文件夹，需要修改配置文件的路径，可以在本地查看 项目上线发布，直接上传 dist 到服务器即可</description>
    </item>
    <item>
      <title>vue 生命周期</title>
      <link>https://zishu.me/blog/5.html/</link>
      <pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/5.html/</guid>
      <description>学习 vue 中一个非常重要的领域，就是生命周期，它包含了很多的内容。每个 vue 实例在被创建的时候都要经历一系列的初始化过程，这个过程就是 vue 的生命周期。 每个 vue 实例在被创建的时候都要经过一系列的初始化过程——例如，需要把设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等，我们要把这一系列的过程称为组件的生命周期（组件从注册到销毁的整个过程）。我们有时候需要在组件生命周期的某个过程中，执行某些代码，基于此，vue 提供了生命周期钩子函数，给了用户在不同阶段添加自己的代码的机会。 但是在此之前，我们要详细的介绍下组件的生命周期，以及生命后期中每个阶段组件完成和未完成的部分。 一、组件的生命周期 放一张大家都很熟悉的官网文章中对生命周期的注释图。 从图中可以看出，vue 为生命周期提供了 8 个钩子函数，分别是： beforeCreate: 创建前 created: 创建后 beforeMount: 挂载前 mounted: 挂载后 beforeUpate: 更新前 upated: 更新后 beforeDestoy: 销毁前 destoyed: 销毁后 1.beforeCreate beforeCreate 在 vue 实例发生之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 我们在上面的例子中在的 beforeCreate 钩子中调用 Vue 的 data 和 method，来看一下结果： 可以看到 Vue 中的 data 和方法都是去不到的，并且是在 wath 之前执行 2.created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 主要应用：调用数据，调用方法，调用异步函数 console 输出的结果我们看一下 可以看到：created 钩子可以获取 Vue 的 data，调用 Vue 方法，获取原本 HTML 上的直接加载出来的 DOM，但是无法获取到通过挂载模板生成的 DOM（例如：v-for 循环遍历 Vue.list 生成 li） 3.beforeMount 在挂载开始之前被调用：相关的 render 函数（模板）首次被调用。 例如通过 v-for 生成的 html 还没有被挂载到页面上 beforeMount: function () { console.log(&amp;#39;beforeMount:&amp;#39;,document.getElementsByTagName(&amp;#39;li&amp;#39;).length); }, console 打印出来的 beforeMount 为 1 4.mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 有初始值的 DOM 渲染，例如我们的初始数据 list，渲染出来的 li，只有这里才能获取 mounted: function () { console.log(&amp;#39;mounted:&amp;#39;,document.getElementsByTagName(&amp;#39;li&amp;#39;).length); }, 结果 mounted: 3 , 可以看到到这里为止，挂载到实例上了，我们可以获取到 li 的个数了 5.beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 当我们更改 Vue 的任何数据，都会触发该函数 beforeUpdate: &amp;#34;function () { console.log(&amp;#39;beforeUpdate 钩子执行.&amp;#39;); console.log(&amp;#39;beforeUpdate:&amp;#39;+this.message) }, 6.updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 数据更新就会触发（vue 所有的数据只有有更新就会触发）,如果想数据一遍就做统一的处理，可以用这个，如果想对不同数据的更新做不同的处理可以用 nextTick，或者是 watch 进行监听 updated: function () { console.log(&amp;#39;updated 钩子执行...&amp;#39;); console.log(&amp;#39;updated:&amp;#39;,this.message) }, 7.beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 8.destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 结果 可以看打到销毁 Vue 实例时会调用这两个函数</description>
    </item>
  </channel>
</rss>
