<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.146.5">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/blog/23.html/" />
<link rel="canonical" href="https://zishu.me/blog/23.html/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "blog",
"name" : "react 学习路径－－怎么学习 react？",
"headline" : "react 学习路径－－怎么学习 react？",
"description" : "转载于：https:\/\/github.com\/petehunt\/react-howto，react 开源作者对于 react 框架的一个学习路径的建议，个人感觉还是相当不错的学习路线\n如何学习 React? 如果你是一个 React (或者前端) 新手，出于以下的原因，你可能会对这个生态圈感到困惑：\nReact 的目标群体历来是喜欢尝试新事物的开发者和前端专家。 Facebook 开源的内容是应用在他们的实际应用中，因此他们没有关注那些比 Facebook 小的工程需求。 现有的 React 指引水平参差不齐。 在本文中，我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础。\n为什么要听我的？ 关于 React, 现在已经有大量的相互冲突的建议了，为什么要听我的？\n因为我是在 Facebook 构建并开源 React 的最初成员之一。现在我离开了 Facebook 并加入了一家初创公司，所以我也不会站在 Facebook 的立场上来表态。\n如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的，你需要对整个技术栈有足够深入的理解，才能建造你的应用。为什么 React 生态圈的工具似乎总让人感觉压力山大呢，因为它总是以错误的顺序被解释：\n你应该按照以下的顺序进行学习，而不是跳着学或者同时学习:\nReact npm JavaScript“打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候，才进入下一步的学习。\n另外，在 React 社区中，有一些前沿主题是经常被提及到的，以下的这些主题很有意思，但也很难弄懂，所以它们远没有上面的主题流行，大多数应用也不需要用到这些。\n内联样式 服务器端渲染 Immutable.js Relay, Falcor 等 学习 React 本身 有一种常见的误解是：你需要花费大量时间在配置工具上，然后才开始学习 React. 在官方文档里，你可以找到 copy-paste HTML template. 只需要保存为 .html 文件，你就可以马上开始学习了。这个步骤不需要任何工具，你也无需额外学习工具使用，直到你能熟练掌握 React 基础。\n我依然觉得，学习 React 最简单的方法是通过官方教程 the official tutorial.\n学习 npm npm 是 Node.js 包管理工具，也是前端工程师和设计师分享 JavaScript 代码最流行的方式。它包含了名为 CommonJS 的模块系统，让你可以安装 JavaScript 写的命令行工具。作为背景知识，可以阅读 这篇文章 了解 CommonJS 对于浏览器的重要性，阅读 CommonJS Spec Wiki 了解关于 CommonJS API 的更多内容\n在 React 生态圈中，大部分可重用的组件、库和工具遵循 CommonJS 模块规范，可通过 npm 来安装。\n学习 JavaScript 打包工具 出于若干技术原因，CommonJS 模块 (也就是 npm 里的所有内容) 不能直接用到浏览器。你需要一个 JavaScript“打包工具 (bundler)”来把这些模块打包成 .js 文件，使你可以在网页中通过 \u0026lt;script\u0026gt; 标签引入它们。\nJavaScript 打包工具包括 webpack 和 browserify. 它们都是好的选择，但我个人更喜欢 webpack , 因为它有许多功能简化大型应用开发。鉴于 webpack 文档可能令人感到困惑，我也写了两篇文章：plug-and-play template for getting started 和针对更复杂用例的 how-to guide for webpack.\n要记住的一点：CommonJS 使用了 require() 函数来引入模块，因此许多人对此感到疑惑，并认为需要导入 require.js 到工程里。出于若干技术原因，我建议你避免使用 require.js. 它在 React 生态圈并不流行。\n学习 ES6 在 JSX (你会在 React tutorial 中学习到) 以外，你可能会注意到 React 例子中一些有趣的语法。这被称为 ECMAScript6, 是 JavaScript 的最新版本。由于 ES6 很新，你可能还没学习到，浏览器也可能尚未兼容，但别担心，通过合适的配置，你的打包工具会为你自动转换成兼容代码。\n如果你只想要使用 React 来把事情做完，你可以跳过 ES6 的学习， 或者留到以后再学习。\n你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件。这并不是真的，大多数人 (包括 Facebook) 用的还是 React.createClass().\n学习路由 (routing) “单页面应用”是时下的技术热点。当网页加载完成，用户点击链接或者按钮的时候，JavaScript 会更新页面和改变地址栏，但网页不会刷新。地址栏的管理就是通过 路由 (router) 来完成的。\n目前 React 生态圈最受欢迎的路由解决方案是 react-router. 如果你正在创建一个单页面应用，有什么理由不去使用它呢？\n如果你创建的并非单页面应用，请不要使用路由。 无论如何，大部分项目都是从大型应用中的小组件开始的。\n学习内联样式 在 React 出现之前，很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表。鉴于 React 使开发可重用组件变得容易，你的样式表可以变得没那么复杂了。社区中许多人 (包括我) 正尝试完全抛弃样式表。\n由于一些原因，其实这是个相当疯狂的主意。这让媒体查询 (media quries) 更加困难了，而且这种技术可能有性能上的局限性。当你开始用 React 的时候，只要用你平常使用的方法去写就好了。\n一旦你找到了用 React 开发的感觉，你就可以关注那些可作为替代的技术了。其中一种流行技术是 BEM. 我建议你逐渐停用 CSS 预处理器，因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经在 OSCON 上发表过关于这个的演讲). 说了这么多，总之 React 就像其他 JavaScript 库一样，可以和 CSS 预处理器很好地配合工作。\n另一种可选项是 CSS 模块, 更具体地说，是 react-css-modules. 虽然有了这些 CSS 模块，你还是写 CSS (或者是 SASS\/LESS\/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件。你也不需要担心用到 BEM 那样的方法学去管理类名，因为模块系统在底层已经帮你处理好了。\n学习服务器端渲染 服务器端渲染经常被称为 \u0026ldquo;通用应用\u0026rdquo; 或 \u0026ldquo;同构应用\u0026rdquo;. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能，因为用户不用等到 JS 下载完才看到初始界面，并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成。\n如果你发现首屏渲染速度过慢，或者想提高网站在搜索引擎的排行，你就需要服务器端渲染了。尽管 Google 现在也会索引客户端渲染的内容，但截至 2016 年 1 月，这样做仍被证实会对排行有负面影响，这可能是由于客户端渲染的性能问题所造成的。\n服务器端渲染还需要许多工具的辅助，因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的，你应该先构建你的应用，之后再关心服务器端渲染的问题。不用担心，你不需要重写所有组件去支持它。\n学习 Flux 你可能听过 Flux, 不过关于 Flux 有大量的错误资讯。\n许多人一坐下来刚开始构建应用，就认为需要用 Flux 来定义他们的数据模型。这样采用 Flux 是不对的，Flux 应该在大量组件被建立完成以后才被引入。\nReact 组件之间存在层级关系。在很多时候，你的数据模型也跟随这种层级。这种情况下，Flux 不会给你很大帮助。但有些时候，你的数据模型没有层次，当你的 React 组件开始接受没有关联的 props 的时候，或者当小部分组件开始变得复杂的时候，你才可能需要看看 Flux.\n你会知道什么时候需要用 Flux. 如果你不确定是否需要用它，你就不需要它。\n如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 Redux. 当然也有许多其他选择，你或者会有兴趣尝试使用它们，但我的建议是只需要用最流行的 Redux 就足够了。\n学习 Immutable.js Immutable.js 提供了一系列的数据结构，以帮助解决构造 React 应用时的某些性能问题。这是一个很棒的库，你可能会在应用发展的过程里大量用到它，但直到你在意识到性能问题以前，它是完全不必要的。\n学习 Relay, Falcor 等 这些技术可以帮你减少 AJAX 请求数，它们仍然是非常前沿的，所以如果你没有遇到过多 AJAX 请求的问题，就不需要用到 Relay 或者 Falcor.\n",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2020",
"datePublished": "2020-11-19 00:00:00 \u002b0000 UTC",
"dateModified" : "2020-11-19 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/blog\/23.html\/",
"keywords" : [ "react", ]
}
</script><title>react 学习路径－－怎么学习 react？ - 子舒的博客</title>
<meta property="og:title" content="react 学习路径－－怎么学习 react？" />
<meta property="og:type" content="article" />


<meta property="og:keywords" content="转载于：https://github.com/petehunt/react-howto，react 开源作者对于 react 框架的一个学习路径的建议，个人感觉还是相当不错的学习路线
如何学习 React? 如果你是一个 React (或者前端) 新手，出于以下的原因，你可能会对这个生态圈感到困惑：
React 的目标群体历来是喜欢尝试新事物的开发者和前端专家。 Facebook 开源的内容是应用在他们的实际应用中，因此他们没有关注那些比 Facebook 小的工程需求。 现有的 React 指引水平参差不齐。 在本文中，我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础。
为什么要听我的？ 关于 React, 现在已经有大量的相互冲突的建议了，为什么要听我的？
因为我是在 Facebook 构建并开源 React 的最初成员之一。现在我离开了 Facebook 并加入了一家初创公司，所以我也不会站在 Facebook 的立场上来表态。
如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的，你需要对整个技术栈有足够深入的理解，才能建造你的应用。为什么 React 生态圈的工具似乎总让人感觉压力山大呢，因为它总是以错误的顺序被解释：
你应该按照以下的顺序进行学习，而不是跳着学或者同时学习:
React npm JavaScript“打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候，才进入下一步的学习。
另外，在 React 社区中，有一些前沿主题是经常被提及到的，以下的这些主题很有意思，但也很难弄懂，所以它们远没有上面的主题流行，大多数应用也不需要用到这些。
内联样式 服务器端渲染 Immutable.js Relay, Falcor 等 学习 React 本身 有一种常见的误解是：你需要花费大量时间在配置工具上，然后才开始学习 React. 在官方文档里，你可以找到 copy-paste HTML template. 只需要保存为 .html 文件，你就可以马上开始学习了。这个步骤不需要任何工具，你也无需额外学习工具使用，直到你能熟练掌握 React 基础。
我依然觉得，学习 React 最简单的方法是通过官方教程 the official tutorial.
学习 npm npm 是 Node.js 包管理工具，也是前端工程师和设计师分享 JavaScript 代码最流行的方式。它包含了名为 CommonJS 的模块系统，让你可以安装 JavaScript 写的命令行工具。作为背景知识，可以阅读 这篇文章 了解 CommonJS 对于浏览器的重要性，阅读 CommonJS Spec Wiki 了解关于 CommonJS API 的更多内容
在 React 生态圈中，大部分可重用的组件、库和工具遵循 CommonJS 模块规范，可通过 npm 来安装。
学习 JavaScript 打包工具 出于若干技术原因，CommonJS 模块 (也就是 npm 里的所有内容) 不能直接用到浏览器。你需要一个 JavaScript“打包工具 (bundler)”来把这些模块打包成 .js 文件，使你可以在网页中通过 &lt;script&gt; 标签引入它们。
JavaScript 打包工具包括 webpack 和 browserify. 它们都是好的选择，但我个人更喜欢 webpack , 因为它有许多功能简化大型应用开发。鉴于 webpack 文档可能令人感到困惑，我也写了两篇文章：plug-and-play template for getting started 和针对更复杂用例的 how-to guide for webpack.
要记住的一点：CommonJS 使用了 require() 函数来引入模块，因此许多人对此感到疑惑，并认为需要导入 require.js 到工程里。出于若干技术原因，我建议你避免使用 require.js. 它在 React 生态圈并不流行。
学习 ES6 在 JSX (你会在 React tutorial 中学习到) 以外，你可能会注意到 React 例子中一些有趣的语法。这被称为 ECMAScript6, 是 JavaScript 的最新版本。由于 ES6 很新，你可能还没学习到，浏览器也可能尚未兼容，但别担心，通过合适的配置，你的打包工具会为你自动转换成兼容代码。
如果你只想要使用 React 来把事情做完，你可以跳过 ES6 的学习， 或者留到以后再学习。
你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件。这并不是真的，大多数人 (包括 Facebook) 用的还是 React.createClass().
学习路由 (routing) “单页面应用”是时下的技术热点。当网页加载完成，用户点击链接或者按钮的时候，JavaScript 会更新页面和改变地址栏，但网页不会刷新。地址栏的管理就是通过 路由 (router) 来完成的。
目前 React 生态圈最受欢迎的路由解决方案是 react-router. 如果你正在创建一个单页面应用，有什么理由不去使用它呢？
如果你创建的并非单页面应用，请不要使用路由。 无论如何，大部分项目都是从大型应用中的小组件开始的。
学习内联样式 在 React 出现之前，很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表。鉴于 React 使开发可重用组件变得容易，你的样式表可以变得没那么复杂了。社区中许多人 (包括我) 正尝试完全抛弃样式表。
由于一些原因，其实这是个相当疯狂的主意。这让媒体查询 (media quries) 更加困难了，而且这种技术可能有性能上的局限性。当你开始用 React 的时候，只要用你平常使用的方法去写就好了。
一旦你找到了用 React 开发的感觉，你就可以关注那些可作为替代的技术了。其中一种流行技术是 BEM. 我建议你逐渐停用 CSS 预处理器，因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经在 OSCON 上发表过关于这个的演讲). 说了这么多，总之 React 就像其他 JavaScript 库一样，可以和 CSS 预处理器很好地配合工作。
另一种可选项是 CSS 模块, 更具体地说，是 react-css-modules. 虽然有了这些 CSS 模块，你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件。你也不需要担心用到 BEM 那样的方法学去管理类名，因为模块系统在底层已经帮你处理好了。
学习服务器端渲染 服务器端渲染经常被称为 &ldquo;通用应用&rdquo; 或 &ldquo;同构应用&rdquo;. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能，因为用户不用等到 JS 下载完才看到初始界面，并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成。
如果你发现首屏渲染速度过慢，或者想提高网站在搜索引擎的排行，你就需要服务器端渲染了。尽管 Google 现在也会索引客户端渲染的内容，但截至 2016 年 1 月，这样做仍被证实会对排行有负面影响，这可能是由于客户端渲染的性能问题所造成的。
服务器端渲染还需要许多工具的辅助，因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的，你应该先构建你的应用，之后再关心服务器端渲染的问题。不用担心，你不需要重写所有组件去支持它。
学习 Flux 你可能听过 Flux, 不过关于 Flux 有大量的错误资讯。
许多人一坐下来刚开始构建应用，就认为需要用 Flux 来定义他们的数据模型。这样采用 Flux 是不对的，Flux 应该在大量组件被建立完成以后才被引入。
React 组件之间存在层级关系。在很多时候，你的数据模型也跟随这种层级。这种情况下，Flux 不会给你很大帮助。但有些时候，你的数据模型没有层次，当你的 React 组件开始接受没有关联的 props 的时候，或者当小部分组件开始变得复杂的时候，你才可能需要看看 Flux.
你会知道什么时候需要用 Flux. 如果你不确定是否需要用它，你就不需要它。
如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 Redux. 当然也有许多其他选择，你或者会有兴趣尝试使用它们，但我的建议是只需要用最流行的 Redux 就足够了。
学习 Immutable.js Immutable.js 提供了一系列的数据结构，以帮助解决构造 React 应用时的某些性能问题。这是一个很棒的库，你可能会在应用发展的过程里大量用到它，但直到你在意识到性能问题以前，它是完全不必要的。
学习 Relay, Falcor 等 这些技术可以帮你减少 AJAX 请求数，它们仍然是非常前沿的，所以如果你没有遇到过多 AJAX 请求的问题，就不需要用到 Relay 或者 Falcor.
" />
<meta name="keywords" content="转载于：https://github.com/petehunt/react-howto，react 开源作者对于 react 框架的一个学习路径的建议，个人感觉还是相当不错的学习路线
如何学习 React? 如果你是一个 React (或者前端) 新手，出于以下的原因，你可能会对这个生态圈感到困惑：
React 的目标群体历来是喜欢尝试新事物的开发者和前端专家。 Facebook 开源的内容是应用在他们的实际应用中，因此他们没有关注那些比 Facebook 小的工程需求。 现有的 React 指引水平参差不齐。 在本文中，我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础。
为什么要听我的？ 关于 React, 现在已经有大量的相互冲突的建议了，为什么要听我的？
因为我是在 Facebook 构建并开源 React 的最初成员之一。现在我离开了 Facebook 并加入了一家初创公司，所以我也不会站在 Facebook 的立场上来表态。
如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的，你需要对整个技术栈有足够深入的理解，才能建造你的应用。为什么 React 生态圈的工具似乎总让人感觉压力山大呢，因为它总是以错误的顺序被解释：
你应该按照以下的顺序进行学习，而不是跳着学或者同时学习:
React npm JavaScript“打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候，才进入下一步的学习。
另外，在 React 社区中，有一些前沿主题是经常被提及到的，以下的这些主题很有意思，但也很难弄懂，所以它们远没有上面的主题流行，大多数应用也不需要用到这些。
内联样式 服务器端渲染 Immutable.js Relay, Falcor 等 学习 React 本身 有一种常见的误解是：你需要花费大量时间在配置工具上，然后才开始学习 React. 在官方文档里，你可以找到 copy-paste HTML template. 只需要保存为 .html 文件，你就可以马上开始学习了。这个步骤不需要任何工具，你也无需额外学习工具使用，直到你能熟练掌握 React 基础。
我依然觉得，学习 React 最简单的方法是通过官方教程 the official tutorial.
学习 npm npm 是 Node.js 包管理工具，也是前端工程师和设计师分享 JavaScript 代码最流行的方式。它包含了名为 CommonJS 的模块系统，让你可以安装 JavaScript 写的命令行工具。作为背景知识，可以阅读 这篇文章 了解 CommonJS 对于浏览器的重要性，阅读 CommonJS Spec Wiki 了解关于 CommonJS API 的更多内容
在 React 生态圈中，大部分可重用的组件、库和工具遵循 CommonJS 模块规范，可通过 npm 来安装。
学习 JavaScript 打包工具 出于若干技术原因，CommonJS 模块 (也就是 npm 里的所有内容) 不能直接用到浏览器。你需要一个 JavaScript“打包工具 (bundler)”来把这些模块打包成 .js 文件，使你可以在网页中通过 &lt;script&gt; 标签引入它们。
JavaScript 打包工具包括 webpack 和 browserify. 它们都是好的选择，但我个人更喜欢 webpack , 因为它有许多功能简化大型应用开发。鉴于 webpack 文档可能令人感到困惑，我也写了两篇文章：plug-and-play template for getting started 和针对更复杂用例的 how-to guide for webpack.
要记住的一点：CommonJS 使用了 require() 函数来引入模块，因此许多人对此感到疑惑，并认为需要导入 require.js 到工程里。出于若干技术原因，我建议你避免使用 require.js. 它在 React 生态圈并不流行。
学习 ES6 在 JSX (你会在 React tutorial 中学习到) 以外，你可能会注意到 React 例子中一些有趣的语法。这被称为 ECMAScript6, 是 JavaScript 的最新版本。由于 ES6 很新，你可能还没学习到，浏览器也可能尚未兼容，但别担心，通过合适的配置，你的打包工具会为你自动转换成兼容代码。
如果你只想要使用 React 来把事情做完，你可以跳过 ES6 的学习， 或者留到以后再学习。
你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件。这并不是真的，大多数人 (包括 Facebook) 用的还是 React.createClass().
学习路由 (routing) “单页面应用”是时下的技术热点。当网页加载完成，用户点击链接或者按钮的时候，JavaScript 会更新页面和改变地址栏，但网页不会刷新。地址栏的管理就是通过 路由 (router) 来完成的。
目前 React 生态圈最受欢迎的路由解决方案是 react-router. 如果你正在创建一个单页面应用，有什么理由不去使用它呢？
如果你创建的并非单页面应用，请不要使用路由。 无论如何，大部分项目都是从大型应用中的小组件开始的。
学习内联样式 在 React 出现之前，很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表。鉴于 React 使开发可重用组件变得容易，你的样式表可以变得没那么复杂了。社区中许多人 (包括我) 正尝试完全抛弃样式表。
由于一些原因，其实这是个相当疯狂的主意。这让媒体查询 (media quries) 更加困难了，而且这种技术可能有性能上的局限性。当你开始用 React 的时候，只要用你平常使用的方法去写就好了。
一旦你找到了用 React 开发的感觉，你就可以关注那些可作为替代的技术了。其中一种流行技术是 BEM. 我建议你逐渐停用 CSS 预处理器，因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经在 OSCON 上发表过关于这个的演讲). 说了这么多，总之 React 就像其他 JavaScript 库一样，可以和 CSS 预处理器很好地配合工作。
另一种可选项是 CSS 模块, 更具体地说，是 react-css-modules. 虽然有了这些 CSS 模块，你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件。你也不需要担心用到 BEM 那样的方法学去管理类名，因为模块系统在底层已经帮你处理好了。
学习服务器端渲染 服务器端渲染经常被称为 &ldquo;通用应用&rdquo; 或 &ldquo;同构应用&rdquo;. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能，因为用户不用等到 JS 下载完才看到初始界面，并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成。
如果你发现首屏渲染速度过慢，或者想提高网站在搜索引擎的排行，你就需要服务器端渲染了。尽管 Google 现在也会索引客户端渲染的内容，但截至 2016 年 1 月，这样做仍被证实会对排行有负面影响，这可能是由于客户端渲染的性能问题所造成的。
服务器端渲染还需要许多工具的辅助，因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的，你应该先构建你的应用，之后再关心服务器端渲染的问题。不用担心，你不需要重写所有组件去支持它。
学习 Flux 你可能听过 Flux, 不过关于 Flux 有大量的错误资讯。
许多人一坐下来刚开始构建应用，就认为需要用 Flux 来定义他们的数据模型。这样采用 Flux 是不对的，Flux 应该在大量组件被建立完成以后才被引入。
React 组件之间存在层级关系。在很多时候，你的数据模型也跟随这种层级。这种情况下，Flux 不会给你很大帮助。但有些时候，你的数据模型没有层次，当你的 React 组件开始接受没有关联的 props 的时候，或者当小部分组件开始变得复杂的时候，你才可能需要看看 Flux.
你会知道什么时候需要用 Flux. 如果你不确定是否需要用它，你就不需要它。
如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 Redux. 当然也有许多其他选择，你或者会有兴趣尝试使用它们，但我的建议是只需要用最流行的 Redux 就足够了。
学习 Immutable.js Immutable.js 提供了一系列的数据结构，以帮助解决构造 React 应用时的某些性能问题。这是一个很棒的库，你可能会在应用发展的过程里大量用到它，但直到你在意识到性能问题以前，它是完全不必要的。
学习 Relay, Falcor 等 这些技术可以帮你减少 AJAX 请求数，它们仍然是非常前沿的，所以如果你没有遇到过多 AJAX 请求的问题，就不需要用到 Relay 或者 Falcor.
" />


<meta property="og:description" content="转载于：https://github.com/petehunt/react-howto，react 开源作者对于 react 框架的一个学习路径的建议，个人感觉还是相当不错的学习路线
如何学习 React? 如果你是一个 React (或者前端) 新手，出于以下的原因，你可能会对这个生态圈感到困惑：
React 的目标群体历来是喜欢尝试新事物的开发者和前端专家。 Facebook 开源的内容是应用在他们的实际应用中，因此他们没有关注那些比 Facebook 小的工程需求。 现有的 React 指引水平参差不齐。 在本文中，我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础。
为什么要听我的？ 关于 React, 现在已经有大量的相互冲突的建议了，为什么要听我的？
因为我是在 Facebook 构建并开源 React 的最初成员之一。现在我离开了 Facebook 并加入了一家初创公司，所以我也不会站在 Facebook 的立场上来表态。
如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的，你需要对整个技术栈有足够深入的理解，才能建造你的应用。为什么 React 生态圈的工具似乎总让人感觉压力山大呢，因为它总是以错误的顺序被解释：
你应该按照以下的顺序进行学习，而不是跳着学或者同时学习:
React npm JavaScript“打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候，才进入下一步的学习。
另外，在 React 社区中，有一些前沿主题是经常被提及到的，以下的这些主题很有意思，但也很难弄懂，所以它们远没有上面的主题流行，大多数应用也不需要用到这些。
内联样式 服务器端渲染 Immutable.js Relay, Falcor 等 学习 React 本身 有一种常见的误解是：你需要花费大量时间在配置工具上，然后才开始学习 React. 在官方文档里，你可以找到 copy-paste HTML template. 只需要保存为 .html 文件，你就可以马上开始学习了。这个步骤不需要任何工具，你也无需额外学习工具使用，直到你能熟练掌握 React 基础。
我依然觉得，学习 React 最简单的方法是通过官方教程 the official tutorial.
学习 npm npm 是 Node.js 包管理工具，也是前端工程师和设计师分享 JavaScript 代码最流行的方式。它包含了名为 CommonJS 的模块系统，让你可以安装 JavaScript 写的命令行工具。作为背景知识，可以阅读 这篇文章 了解 CommonJS 对于浏览器的重要性，阅读 CommonJS Spec Wiki 了解关于 CommonJS API 的更多内容
在 React 生态圈中，大部分可重用的组件、库和工具遵循 CommonJS 模块规范，可通过 npm 来安装。
学习 JavaScript 打包工具 出于若干技术原因，CommonJS 模块 (也就是 npm 里的所有内容) 不能直接用到浏览器。你需要一个 JavaScript“打包工具 (bundler)”来把这些模块打包成 .js 文件，使你可以在网页中通过 &lt;script&gt; 标签引入它们。
JavaScript 打包工具包括 webpack 和 browserify. 它们都是好的选择，但我个人更喜欢 webpack , 因为它有许多功能简化大型应用开发。鉴于 webpack 文档可能令人感到困惑，我也写了两篇文章：plug-and-play template for getting started 和针对更复杂用例的 how-to guide for webpack.
要记住的一点：CommonJS 使用了 require() 函数来引入模块，因此许多人对此感到疑惑，并认为需要导入 require.js 到工程里。出于若干技术原因，我建议你避免使用 require.js. 它在 React 生态圈并不流行。
学习 ES6 在 JSX (你会在 React tutorial 中学习到) 以外，你可能会注意到 React 例子中一些有趣的语法。这被称为 ECMAScript6, 是 JavaScript 的最新版本。由于 ES6 很新，你可能还没学习到，浏览器也可能尚未兼容，但别担心，通过合适的配置，你的打包工具会为你自动转换成兼容代码。
如果你只想要使用 React 来把事情做完，你可以跳过 ES6 的学习， 或者留到以后再学习。
你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件。这并不是真的，大多数人 (包括 Facebook) 用的还是 React.createClass().
学习路由 (routing) “单页面应用”是时下的技术热点。当网页加载完成，用户点击链接或者按钮的时候，JavaScript 会更新页面和改变地址栏，但网页不会刷新。地址栏的管理就是通过 路由 (router) 来完成的。
目前 React 生态圈最受欢迎的路由解决方案是 react-router. 如果你正在创建一个单页面应用，有什么理由不去使用它呢？
如果你创建的并非单页面应用，请不要使用路由。 无论如何，大部分项目都是从大型应用中的小组件开始的。
学习内联样式 在 React 出现之前，很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表。鉴于 React 使开发可重用组件变得容易，你的样式表可以变得没那么复杂了。社区中许多人 (包括我) 正尝试完全抛弃样式表。
由于一些原因，其实这是个相当疯狂的主意。这让媒体查询 (media quries) 更加困难了，而且这种技术可能有性能上的局限性。当你开始用 React 的时候，只要用你平常使用的方法去写就好了。
一旦你找到了用 React 开发的感觉，你就可以关注那些可作为替代的技术了。其中一种流行技术是 BEM. 我建议你逐渐停用 CSS 预处理器，因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经在 OSCON 上发表过关于这个的演讲). 说了这么多，总之 React 就像其他 JavaScript 库一样，可以和 CSS 预处理器很好地配合工作。
另一种可选项是 CSS 模块, 更具体地说，是 react-css-modules. 虽然有了这些 CSS 模块，你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件。你也不需要担心用到 BEM 那样的方法学去管理类名，因为模块系统在底层已经帮你处理好了。
学习服务器端渲染 服务器端渲染经常被称为 &ldquo;通用应用&rdquo; 或 &ldquo;同构应用&rdquo;. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能，因为用户不用等到 JS 下载完才看到初始界面，并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成。
如果你发现首屏渲染速度过慢，或者想提高网站在搜索引擎的排行，你就需要服务器端渲染了。尽管 Google 现在也会索引客户端渲染的内容，但截至 2016 年 1 月，这样做仍被证实会对排行有负面影响，这可能是由于客户端渲染的性能问题所造成的。
服务器端渲染还需要许多工具的辅助，因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的，你应该先构建你的应用，之后再关心服务器端渲染的问题。不用担心，你不需要重写所有组件去支持它。
学习 Flux 你可能听过 Flux, 不过关于 Flux 有大量的错误资讯。
许多人一坐下来刚开始构建应用，就认为需要用 Flux 来定义他们的数据模型。这样采用 Flux 是不对的，Flux 应该在大量组件被建立完成以后才被引入。
React 组件之间存在层级关系。在很多时候，你的数据模型也跟随这种层级。这种情况下，Flux 不会给你很大帮助。但有些时候，你的数据模型没有层次，当你的 React 组件开始接受没有关联的 props 的时候，或者当小部分组件开始变得复杂的时候，你才可能需要看看 Flux.
你会知道什么时候需要用 Flux. 如果你不确定是否需要用它，你就不需要它。
如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 Redux. 当然也有许多其他选择，你或者会有兴趣尝试使用它们，但我的建议是只需要用最流行的 Redux 就足够了。
学习 Immutable.js Immutable.js 提供了一系列的数据结构，以帮助解决构造 React 应用时的某些性能问题。这是一个很棒的库，你可能会在应用发展的过程里大量用到它，但直到你在意识到性能问题以前，它是完全不必要的。
学习 Relay, Falcor 等 这些技术可以帮你减少 AJAX 请求数，它们仍然是非常前沿的，所以如果你没有遇到过多 AJAX 请求的问题，就不需要用到 Relay 或者 Falcor.
" />
<meta name="description" content="转载于：https://github.com/petehunt/react-howto，react 开源作者对于 react 框架的一个学习路径的建议，个人感觉还是相当不错的学习路线
如何学习 React? 如果你是一个 React (或者前端) 新手，出于以下的原因，你可能会对这个生态圈感到困惑：
React 的目标群体历来是喜欢尝试新事物的开发者和前端专家。 Facebook 开源的内容是应用在他们的实际应用中，因此他们没有关注那些比 Facebook 小的工程需求。 现有的 React 指引水平参差不齐。 在本文中，我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础。
为什么要听我的？ 关于 React, 现在已经有大量的相互冲突的建议了，为什么要听我的？
因为我是在 Facebook 构建并开源 React 的最初成员之一。现在我离开了 Facebook 并加入了一家初创公司，所以我也不会站在 Facebook 的立场上来表态。
如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的，你需要对整个技术栈有足够深入的理解，才能建造你的应用。为什么 React 生态圈的工具似乎总让人感觉压力山大呢，因为它总是以错误的顺序被解释：
你应该按照以下的顺序进行学习，而不是跳着学或者同时学习:
React npm JavaScript“打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候，才进入下一步的学习。
另外，在 React 社区中，有一些前沿主题是经常被提及到的，以下的这些主题很有意思，但也很难弄懂，所以它们远没有上面的主题流行，大多数应用也不需要用到这些。
内联样式 服务器端渲染 Immutable.js Relay, Falcor 等 学习 React 本身 有一种常见的误解是：你需要花费大量时间在配置工具上，然后才开始学习 React. 在官方文档里，你可以找到 copy-paste HTML template. 只需要保存为 .html 文件，你就可以马上开始学习了。这个步骤不需要任何工具，你也无需额外学习工具使用，直到你能熟练掌握 React 基础。
我依然觉得，学习 React 最简单的方法是通过官方教程 the official tutorial.
学习 npm npm 是 Node.js 包管理工具，也是前端工程师和设计师分享 JavaScript 代码最流行的方式。它包含了名为 CommonJS 的模块系统，让你可以安装 JavaScript 写的命令行工具。作为背景知识，可以阅读 这篇文章 了解 CommonJS 对于浏览器的重要性，阅读 CommonJS Spec Wiki 了解关于 CommonJS API 的更多内容
在 React 生态圈中，大部分可重用的组件、库和工具遵循 CommonJS 模块规范，可通过 npm 来安装。
学习 JavaScript 打包工具 出于若干技术原因，CommonJS 模块 (也就是 npm 里的所有内容) 不能直接用到浏览器。你需要一个 JavaScript“打包工具 (bundler)”来把这些模块打包成 .js 文件，使你可以在网页中通过 &lt;script&gt; 标签引入它们。
JavaScript 打包工具包括 webpack 和 browserify. 它们都是好的选择，但我个人更喜欢 webpack , 因为它有许多功能简化大型应用开发。鉴于 webpack 文档可能令人感到困惑，我也写了两篇文章：plug-and-play template for getting started 和针对更复杂用例的 how-to guide for webpack.
要记住的一点：CommonJS 使用了 require() 函数来引入模块，因此许多人对此感到疑惑，并认为需要导入 require.js 到工程里。出于若干技术原因，我建议你避免使用 require.js. 它在 React 生态圈并不流行。
学习 ES6 在 JSX (你会在 React tutorial 中学习到) 以外，你可能会注意到 React 例子中一些有趣的语法。这被称为 ECMAScript6, 是 JavaScript 的最新版本。由于 ES6 很新，你可能还没学习到，浏览器也可能尚未兼容，但别担心，通过合适的配置，你的打包工具会为你自动转换成兼容代码。
如果你只想要使用 React 来把事情做完，你可以跳过 ES6 的学习， 或者留到以后再学习。
你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件。这并不是真的，大多数人 (包括 Facebook) 用的还是 React.createClass().
学习路由 (routing) “单页面应用”是时下的技术热点。当网页加载完成，用户点击链接或者按钮的时候，JavaScript 会更新页面和改变地址栏，但网页不会刷新。地址栏的管理就是通过 路由 (router) 来完成的。
目前 React 生态圈最受欢迎的路由解决方案是 react-router. 如果你正在创建一个单页面应用，有什么理由不去使用它呢？
如果你创建的并非单页面应用，请不要使用路由。 无论如何，大部分项目都是从大型应用中的小组件开始的。
学习内联样式 在 React 出现之前，很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表。鉴于 React 使开发可重用组件变得容易，你的样式表可以变得没那么复杂了。社区中许多人 (包括我) 正尝试完全抛弃样式表。
由于一些原因，其实这是个相当疯狂的主意。这让媒体查询 (media quries) 更加困难了，而且这种技术可能有性能上的局限性。当你开始用 React 的时候，只要用你平常使用的方法去写就好了。
一旦你找到了用 React 开发的感觉，你就可以关注那些可作为替代的技术了。其中一种流行技术是 BEM. 我建议你逐渐停用 CSS 预处理器，因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经在 OSCON 上发表过关于这个的演讲). 说了这么多，总之 React 就像其他 JavaScript 库一样，可以和 CSS 预处理器很好地配合工作。
另一种可选项是 CSS 模块, 更具体地说，是 react-css-modules. 虽然有了这些 CSS 模块，你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件。你也不需要担心用到 BEM 那样的方法学去管理类名，因为模块系统在底层已经帮你处理好了。
学习服务器端渲染 服务器端渲染经常被称为 &ldquo;通用应用&rdquo; 或 &ldquo;同构应用&rdquo;. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能，因为用户不用等到 JS 下载完才看到初始界面，并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成。
如果你发现首屏渲染速度过慢，或者想提高网站在搜索引擎的排行，你就需要服务器端渲染了。尽管 Google 现在也会索引客户端渲染的内容，但截至 2016 年 1 月，这样做仍被证实会对排行有负面影响，这可能是由于客户端渲染的性能问题所造成的。
服务器端渲染还需要许多工具的辅助，因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的，你应该先构建你的应用，之后再关心服务器端渲染的问题。不用担心，你不需要重写所有组件去支持它。
学习 Flux 你可能听过 Flux, 不过关于 Flux 有大量的错误资讯。
许多人一坐下来刚开始构建应用，就认为需要用 Flux 来定义他们的数据模型。这样采用 Flux 是不对的，Flux 应该在大量组件被建立完成以后才被引入。
React 组件之间存在层级关系。在很多时候，你的数据模型也跟随这种层级。这种情况下，Flux 不会给你很大帮助。但有些时候，你的数据模型没有层次，当你的 React 组件开始接受没有关联的 props 的时候，或者当小部分组件开始变得复杂的时候，你才可能需要看看 Flux.
你会知道什么时候需要用 Flux. 如果你不确定是否需要用它，你就不需要它。
如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 Redux. 当然也有许多其他选择，你或者会有兴趣尝试使用它们，但我的建议是只需要用最流行的 Redux 就足够了。
学习 Immutable.js Immutable.js 提供了一系列的数据结构，以帮助解决构造 React 应用时的某些性能问题。这是一个很棒的库，你可能会在应用发展的过程里大量用到它，但直到你在意识到性能问题以前，它是完全不必要的。
学习 Relay, Falcor 等 这些技术可以帮你减少 AJAX 请求数，它们仍然是非常前沿的，所以如果你没有遇到过多 AJAX 请求的问题，就不需要用到 Relay 或者 Falcor.
" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Catamaran:wght@100..900&display=swap" rel="stylesheet">

<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-BGB227HN9X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-BGB227HN9X');
</script>
</head>

<body>
  <div class="wrapper">
    <div class="main">
      <div class="aside">
  <div class="top">
    <div class="site-info">
       <a href="/"><svg width="104.597" height="39.369" viewBox="0 0 104.597 39.369" xmlns="http://www.w3.org/2000/svg"><g id="svgGroup" stroke-linecap="round" fill-rule="evenodd" font-size="9pt" stroke="#000000" stroke-width="0.1mm" fill="#000000" style="stroke:#000000;stroke-width:0.1mm;fill:#000000"><path d="M 67.659 29.801 L 68.763 19.635 Q 68.763 18.393 68.119 17.565 Q 67.475 16.737 66.049 16.737 Q 64.623 16.737 63.634 17.864 Q 62.645 18.991 62.185 20.831 Q 61.863 23.453 61.219 28.49 A 2866.126 2866.126 0 0 0 60.69 32.647 A 536.88 536.88 0 0 0 60.391 35.045 L 54.273 35.045 A 18068.443 18068.443 0 0 0 55.744 22.484 Q 57.283 9.299 57.949 3.362 A 627.499 627.499 0 0 0 58.275 0.407 Q 59.241 0.039 60.897 0.039 A 3.976 3.976 0 0 1 64.139 1.045 A 1.775 1.775 0 0 1 64.485 2.155 L 64.485 2.431 A 270.679 270.679 0 0 1 63.046 13.731 A 177.594 177.594 0 0 1 62.829 15.127 Q 65.267 12.919 68.349 12.919 Q 71.431 12.919 73.225 14.483 Q 75.019 16.047 75.019 18.439 Q 75.019 19.083 74.743 20.831 A 276.731 276.731 0 0 0 73.983 26.046 Q 73.685 28.292 73.685 28.927 Q 73.685 31.089 75.111 31.089 Q 76.307 31.089 77.664 29.502 A 11.951 11.951 0 0 0 77.825 29.282 A 18.722 18.722 0 0 1 78.055 27.041 Q 79.113 18.485 79.665 13.425 Q 81.091 12.919 82.287 12.919 Q 83.483 12.919 84.081 13.011 Q 84.679 13.103 85.231 13.701 Q 85.783 14.299 85.783 15.403 L 84.265 27.133 Q 84.173 27.685 84.173 28.145 Q 84.173 30.859 86.657 30.859 Q 88.957 30.859 90.475 28.605 Q 90.475 28.099 90.567 26.995 L 92.085 14.759 Q 92.407 13.977 93.465 13.448 Q 94.523 12.919 96.11 12.919 Q 97.697 12.919 98.479 13.379 Q 96.924 25.663 96.651 28.479 A 10.731 10.731 0 0 0 96.593 29.249 Q 96.593 31.089 97.927 31.089 Q 99.123 31.089 100.526 29.456 Q 101.929 27.823 102.757 24.557 Q 104.275 26.213 104.597 27.133 A 12.282 12.282 0 0 1 101.894 32.831 A 6.516 6.516 0 0 1 101.239 33.435 Q 98.939 35.275 96.501 35.275 Q 92.499 35.275 91.119 32.193 Q 88.727 35.275 84.725 35.275 Q 81.413 35.275 79.619 33.619 A 5.611 5.611 0 0 1 78.856 32.75 A 13.283 13.283 0 0 1 78.373 33.275 A 7.221 7.221 0 0 1 73.271 35.229 Q 70.419 35.229 69.039 33.481 Q 67.659 31.733 67.659 29.801 Z M 20.739 28.881 L 22.395 14.667 Q 22.855 13.839 24.143 13.402 Q 25.431 12.965 26.696 12.965 Q 27.961 12.965 28.927 13.287 Q 27.133 27.133 27.133 27.271 Q 26.903 28.191 26.903 28.812 Q 26.903 29.433 26.995 29.893 A 1.435 1.435 0 0 0 27.961 31.04 A 8.754 8.754 0 0 1 28.881 28.421 Q 30.752 24.861 37.604 18.675 A 123.618 123.618 0 0 1 37.713 18.577 Q 36.011 16.875 36.011 14.943 Q 36.011 13.011 37.46 11.677 Q 38.909 10.343 40.887 10.343 Q 42.681 10.343 44.015 11.769 Q 44.889 12.735 44.889 14.207 Q 44.889 15.679 43.923 17.519 A 72.971 72.971 0 0 1 48.835 19.902 A 18.079 18.079 0 0 1 50.593 20.969 Q 54.227 23.637 54.227 27.271 Q 54.227 30.905 51.375 33.113 Q 48.523 35.321 44.199 35.321 Q 41.393 35.321 39.53 33.918 Q 37.667 32.515 37.667 30.445 Q 37.667 28.375 39.047 27.156 Q 40.427 25.937 42.497 25.661 Q 41.531 27.041 41.531 28.306 Q 41.531 29.571 42.405 30.353 Q 43.279 31.135 44.613 31.135 Q 45.947 31.135 46.821 30.146 Q 47.695 29.157 47.695 27.869 Q 47.695 25.753 45.717 24.097 Q 44.521 23.131 43.141 22.28 A 104.019 104.019 0 0 0 41.712 21.407 A 0.982 0.982 0 0 0 41.669 21.383 Q 41.485 21.245 41.301 21.153 Q 40.473 22.119 38.909 23.798 Q 37.345 25.477 36.425 26.489 A 12.83 12.83 0 0 0 34.85 28.396 A 12.665 12.665 0 0 1 33.52 31.218 A 6.915 6.915 0 0 0 33.435 32.584 Q 33.435 33.619 34.056 34.723 Q 34.677 35.827 35.551 36.379 Q 36.425 36.931 37.276 37.276 Q 38.127 37.621 38.748 37.759 Q 39.369 37.897 39.369 37.943 Q 39.369 38.265 38.357 38.679 Q 36.471 39.369 34.424 39.369 Q 32.377 39.369 30.445 37.897 A 6.46 6.46 0 0 1 28.329 35.212 A 7.144 7.144 0 0 1 26.765 35.367 Q 23.683 35.367 22.188 33.849 Q 20.693 32.331 20.693 29.939 Q 20.693 29.433 20.739 28.881 Z M 13.471 35.459 L 0.683 35.183 A 1.327 1.327 0 0 1 0.085 33.556 A 8.453 8.453 0 0 1 0.085 33.55 Q 0.085 31.917 0.775 30.997 A 13.911 13.911 0 0 1 2.876 27.663 A 47.078 47.078 0 0 1 4.593 25.615 Q 5.605 24.465 8.365 21.475 A 141.512 141.512 0 0 0 11.268 18.255 A 27.559 27.559 0 0 0 11.999 17.381 L 9.561 17.243 Q 8.871 18.899 7.56 19.934 Q 6.249 20.969 4.639 20.969 Q 2.799 20.969 1.649 19.888 Q 0.499 18.807 0.499 16.875 Q 0.499 14.943 1.833 13.793 Q 3.167 12.643 5.513 12.643 L 18.301 12.919 Q 18.899 12.919 18.899 14.483 Q 18.899 16.093 18.301 16.967 Q 17.749 17.979 16.714 19.106 Q 15.679 20.233 13.701 22.096 A 175.609 175.609 0 0 0 11.155 24.529 A 38.997 38.997 0 0 0 10.941 24.741 Q 7.859 27.823 6.341 30.675 L 9.423 30.859 Q 10.113 29.203 11.424 28.168 Q 12.735 27.133 14.345 27.133 Q 16.185 27.133 17.335 28.214 Q 18.485 29.295 18.485 31.227 Q 18.485 33.159 17.151 34.309 Q 15.817 35.459 13.471 35.459 Z M 24.281 1.166 Q 25.339 0.085 26.857 0.085 Q 28.375 0.085 29.456 1.166 Q 30.537 2.247 30.537 3.765 Q 30.537 5.283 29.456 6.341 Q 28.375 7.399 26.857 7.399 Q 25.339 7.399 24.281 6.341 Q 23.223 5.283 23.223 3.765 Q 23.223 2.247 24.281 1.166 Z M 7.583 17.105 L 5.697 16.967 Q 5.421 16.921 5.145 16.921 Q 3.535 16.921 3.535 17.979 Q 3.535 19.037 4.731 19.037 Q 6.525 19.037 7.583 17.105 Z M 11.401 30.997 L 13.287 31.135 Q 13.563 31.181 13.839 31.181 Q 15.449 31.181 15.449 30.123 Q 15.449 29.065 14.253 29.065 Q 12.459 29.065 11.401 30.997 Z M 40.611 15.771 Q 41.715 14.621 41.715 14.115 Q 41.715 12.965 40.703 12.873 Q 39.553 12.873 39.553 14.161 Q 39.553 14.943 40.611 15.771 Z"/></g></svg></a>
      <div class="site-about">
        <p>一个热爱生活的前端开发工程师。</p>
      </div>
    </div>
  </div>
  
  <div class="nav-container">
    <div class="nav">
      
      <a href="/">
        <span>首页</span>
      </a>
      
      <a href="/tags/">
        <span>标签</span>
      </a>
      
      <a href="/message/">
        <span>留言</span>
      </a>
      
      <a href="/about/">
        <span>关于</span>
      </a>
      
      <a href="/search/">
        <span>搜索</span>
      </a>
      
      <a href="/index.xml">
        <span>订阅</span>
      </a>
      
    </div>
    
  </div>
</div>


      <h1>react 学习路径－－怎么学习 react？</h1>

      
      <div class="meta">
        <div class="date">2020 年 11 月 19 日</div>
        <div class="post-tags">
          
          
          <span class="namenode">分类：<a href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
          </span>
          
          
          <span class="tag-node">
            
            标签：<a href="/tags/react">#react</a>
            
            
          </span>
        </div>
      </div>
      
    
      
      <div class="toc">
        <details open>
          <summary accesskey="c" title="(Alt + C)"><span class="details">Table of Contents</span></summary>
          <div class="inner"> <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么要听我的">为什么要听我的？</a></li>
    <li><a href="#如何踏入-react-生态圈">如何踏入 React 生态圈</a></li>
    <li><a href="#学习-react-本身">学习 React 本身</a></li>
    <li><a href="#学习-npm">学习 <code>npm</code></a></li>
    <li><a href="#学习-javascript-打包工具">学习 JavaScript 打包工具</a></li>
    <li><a href="#学习-es6">学习 ES6</a></li>
    <li><a href="#学习路由-routing">学习路由 (routing)</a></li>
    <li><a href="#学习内联样式">学习内联样式</a></li>
    <li><a href="#学习服务器端渲染">学习服务器端渲染</a></li>
    <li><a href="#学习-flux">学习 Flux</a></li>
    <li><a href="#学习-immutablejs">学习 Immutable.js</a></li>
    <li><a href="#学习-relay-falcor-等">学习 Relay, Falcor 等</a></li>
  </ul>
</nav></div>
        </details>
      </div>
      

      <article class="content post-content">
        
        <p>转载于：<a href="https://github.com/petehunt/react-howto">https://github.com/petehunt/react-howto</a>，react 开源作者对于 react 框架的一个学习路径的建议，个人感觉还是相当不错的学习路线</p>
<hr>
<h1 id="如何学习-react">如何学习 React?</h1>
<p>如果你是一个 React (或者前端) 新手，出于以下的原因，你可能会对这个生态圈感到困惑：</p>
<ul>
<li>React 的目标群体历来是喜欢尝试新事物的开发者和前端专家。</li>
<li>Facebook 开源的内容是应用在他们的实际应用中，因此他们没有关注那些比 Facebook 小的工程需求。</li>
<li>现有的 React 指引水平参差不齐。</li>
</ul>
<p>在本文中，我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础。</p>
<h2 id="为什么要听我的">为什么要听我的？</h2>
<p>关于 React, 现在已经有大量的相互冲突的建议了，为什么要听我的？</p>
<p>因为我是在 Facebook 构建并开源 React 的最初成员之一。现在我离开了 Facebook 并加入了一家初创公司，所以我也不会站在 Facebook 的立场上来表态。</p>
<h2 id="如何踏入-react-生态圈">如何踏入 React 生态圈</h2>
<p>所有的软件都是建立在某个技术栈之上的，你需要对整个技术栈有足够深入的理解，才能建造你的应用。为什么 React 生态圈的工具似乎总让人感觉压力山大呢，因为它总是以错误的顺序被解释：</p>
<p>你应该按照以下的顺序进行学习，<strong>而不是跳着学或者同时学习</strong>:</p>
<ol>
<li><a href="#%E5%AD%A6%E4%B9%A0-React-%E6%9C%AC%E8%BA%AB">React</a></li>
<li><a href="#%E5%AD%A6%E4%B9%A0-npm">npm</a></li>
<li><a href="#%E5%AD%A6%E4%B9%A0-JavaScript-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7">JavaScript“打包工具”</a></li>
<li><a href="#%E5%AD%A6%E4%B9%A0-ES6">ES6</a></li>
<li><a href="#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%94%B1-routing">Routing</a></li>
<li><a href="#%E5%AD%A6%E4%B9%A0-Flux">Flux</a></li>
</ol>
<p><strong>你不需要把这些都学完才去使用 React.</strong> 只需要在你遇到问题需要解决的时候，才进入下一步的学习。</p>
<p>另外，在 React 社区中，有一些前沿主题是经常被提及到的，以下的这些主题很有意思，但也很难弄懂，所以它们远没有上面的主题流行，<strong>大多数应用也不需要用到这些。</strong></p>
<ul>
<li><a href="#user-content-%E5%AD%A6%E4%B9%A0%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F">内联样式</a></li>
<li><a href="#user-content-%E5%AD%A6%E4%B9%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93">服务器端渲染</a></li>
<li><a href="#user-content-%E5%AD%A6%E4%B9%A0-immutablejs">Immutable.js</a></li>
<li><a href="#user-content-%E5%AD%A6%E4%B9%A0-relay-falcor-%E7%AD%89">Relay, Falcor 等</a></li>
</ul>
<h2 id="学习-react-本身">学习 React 本身</h2>
<p>有一种常见的误解是：你需要花费大量时间在配置工具上，然后才开始学习 React. 在官方文档里，你可以找到 <a href="https://facebook.github.io/react/docs/getting-started.html#quick-start-without-npm">copy-paste HTML template</a>. 只需要保存为 <code>.html</code> 文件，你就可以马上开始学习了。<strong>这个步骤不需要任何工具，你也无需额外学习工具使用，直到你能熟练掌握 React 基础。</strong></p>
<p>我依然觉得，学习 React 最简单的方法是通过官方教程 <a href="https://facebook.github.io/react/docs/tutorial.html">the official tutorial</a>.</p>
<h2 id="学习-npm">学习 <code>npm</code></h2>
<p><code>npm</code> 是 Node.js 包管理工具，也是前端工程师和设计师分享 JavaScript 代码最流行的方式。它包含了名为 <code>CommonJS</code> 的模块系统，让你可以安装 JavaScript 写的命令行工具。作为背景知识，可以阅读 <a href="http://0fps.net/2013/01/22/commonjs-why-and-how/">这篇文章</a> 了解 <code>CommonJS</code> 对于浏览器的重要性，阅读  <a href="http://wiki.commonjs.org/wiki/Introduction">CommonJS Spec Wiki</a> 了解关于 <code>CommonJS</code> API 的更多内容</p>
<p>在 React 生态圈中，大部分可重用的组件、库和工具遵循 <code>CommonJS</code> 模块规范，可通过 <code>npm</code> 来安装。</p>
<h2 id="学习-javascript-打包工具">学习 JavaScript 打包工具</h2>
<p>出于若干技术原因，<code>CommonJS</code> 模块 (也就是 <code>npm</code> 里的所有内容) 不能直接用到浏览器。你需要一个 JavaScript“打包工具 (bundler)”来把这些模块打包成 <code>.js</code> 文件，使你可以在网页中通过 <code>&lt;script&gt;</code> 标签引入它们。</p>
<p>JavaScript 打包工具包括 <code>webpack</code> 和 <code>browserify</code>. 它们都是好的选择，但我个人更喜欢 <code>webpack</code> , 因为它有许多功能简化大型应用开发。鉴于 webpack 文档可能令人感到困惑，我也写了两篇文章：<a href="https://github.com/petehunt/react-webpack-template">plug-and-play template for getting started</a> 和针对更复杂用例的 <a href="https://github.com/petehunt/webpack-howto">how-to guide for webpack</a>.</p>
<p>要记住的一点：<code>CommonJS</code> 使用了 <code>require()</code> 函数来引入模块，因此许多人对此感到疑惑，并认为需要导入 <code>require.js</code> 到工程里。出于若干技术原因，我建议你避免使用 <code>require.js</code>. 它在 React 生态圈并不流行。</p>
<h2 id="学习-es6">学习 ES6</h2>
<p>在 JSX (你会在 React tutorial 中学习到) 以外，你可能会注意到 React 例子中一些有趣的语法。这被称为 ECMAScript6, 是 JavaScript 的最新版本。由于 ES6 很新，你可能还没学习到，浏览器也可能尚未兼容，但别担心，通过合适的配置，你的打包工具会为你自动转换成兼容代码。</p>
<p>如果你只想要使用 React 来把事情做完，<strong>你可以跳过 ES6 的学习，</strong> 或者留到以后再学习。</p>
<p>你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件。这并不是真的，大多数人 (包括 Facebook) 用的还是 <code>React.createClass()</code>.</p>
<h2 id="学习路由-routing">学习路由 (routing)</h2>
<p>“单页面应用”是时下的技术热点。当网页加载完成，用户点击链接或者按钮的时候，JavaScript 会更新页面和改变地址栏，但网页不会刷新。地址栏的管理就是通过 <strong>路由 (router)</strong> 来完成的。</p>
<p>目前 React 生态圈最受欢迎的路由解决方案是 <a href="https://github.com/rackt/react-router">react-router</a>. 如果你正在创建一个单页面应用，有什么理由不去使用它呢？</p>
<p><strong>如果你创建的并非单页面应用，请不要使用路由。</strong> 无论如何，大部分项目都是从大型应用中的小组件开始的。</p>
<h2 id="学习内联样式">学习内联样式</h2>
<p>在 React 出现之前，很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表。鉴于 React 使开发可重用组件变得容易，你的样式表可以变得没那么复杂了。社区中许多人 (包括我) 正尝试完全抛弃样式表。</p>
<p>由于一些原因，其实这是个相当疯狂的主意。这让媒体查询 (media quries) 更加困难了，而且这种技术可能有性能上的局限性。<strong>当你开始用 React 的时候，只要用你平常使用的方法去写就好了。</strong></p>
<p>一旦你找到了用 React 开发的感觉，你就可以关注那些可作为替代的技术了。其中一种流行技术是 <a href="https://en.bem.info/">BEM</a>. 我建议你逐渐停用 CSS 预处理器，因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经<a href="https://www.youtube.com/watch?v=VkTCL6Nqm6Y">在 OSCON 上发表过关于这个的演讲</a>). 说了这么多，总之 React 就像其他 JavaScript 库一样，可以和 CSS 预处理器很好地配合工作。</p>
<p>另一种可选项是 <a href="http://glenmaddern.com/articles/css-modules">CSS 模块</a>, 更具体地说，是 <a href="https://github.com/gajus/react-css-modules">react-css-modules</a>. 虽然有了这些 CSS 模块，你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件。你也不需要担心用到 BEM 那样的方法学去管理类名，因为模块系统在底层已经帮你处理好了。</p>
<h2 id="学习服务器端渲染">学习服务器端渲染</h2>
<p>服务器端渲染经常被称为 &ldquo;通用应用&rdquo; 或 &ldquo;同构应用&rdquo;. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能，因为用户不用等到 JS 下载完才看到初始界面，并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成。</p>
<p>如果你发现首屏渲染速度过慢，或者想提高网站在搜索引擎的排行，你就需要服务器端渲染了。尽管 Google 现在也会索引客户端渲染的内容，但截至 2016 年 1 月，这样做仍被证实会对排行有负面影响，这可能是由于客户端渲染的性能问题所造成的。</p>
<p>服务器端渲染还需要许多工具的辅助，因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的，你应该先构建你的应用，之后再关心服务器端渲染的问题。不用担心，你不需要重写所有组件去支持它。</p>
<h2 id="学习-flux">学习 Flux</h2>
<p>你可能听过 Flux, 不过关于 Flux 有大量的错误资讯。</p>
<p>许多人一坐下来刚开始构建应用，就认为需要用 Flux 来定义他们的数据模型。<strong>这样采用 Flux 是不对的，Flux 应该在大量组件被建立完成以后才被引入。</strong></p>
<p>React 组件之间存在层级关系。在很多时候，你的数据模型也跟随这种层级。这种情况下，Flux 不会给你很大帮助。但有些时候，你的数据模型没有层次，当你的 React 组件开始接受没有关联的 <code>props</code> 的时候，或者当小部分组件开始变得复杂的时候，你才可能需要看看 Flux.</p>
<p><strong>你会知道什么时候需要用 Flux. 如果你不确定是否需要用它，你就不需要它。</strong></p>
<p>如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 <a href="http://redux.js.org/">Redux</a>. 当然也有许多其他选择，你或者会有兴趣尝试使用它们，但我的建议是只需要用最流行的 Redux 就足够了。</p>
<h2 id="学习-immutablejs">学习 Immutable.js</h2>
<p><a href="https://facebook.github.io/immutable-js/">Immutable.js</a> 提供了一系列的数据结构，以帮助解决构造 React 应用时的某些性能问题。这是一个很棒的库，你可能会在应用发展的过程里大量用到它，但直到你在意识到性能问题以前，它是完全不必要的。</p>
<h2 id="学习-relay-falcor-等">学习 Relay, Falcor 等</h2>
<p>这些技术可以帮你减少 AJAX 请求数，它们仍然是非常前沿的，所以如果你没有遇到过多 AJAX 请求的问题，就不需要用到 Relay 或者 Falcor.</p>

        <div class="weekly-pagination"></div>
      </article>

      
      <ul class="comment-tabs">
  
  <li>LinuxDo</li>
  
  <li>Giscus</li>
  <li>Twikoo</li>
</ul>
<div class="comments">
  
  <div>
    <div id='discourse-comments'></div>
    <meta name='discourse-username' content='anghunk'>
    <script type="text/javascript">
      DiscourseEmbed = {
        discourseUrl: 'https://linux.do/',
        discourseEmbedUrl: 'https://zishu.me\/blog\/23.html\/',
        className: 'hugo-discourse',
      };

      (function() {
        var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
        d.src = DiscourseEmbed.discourseUrl + 'javascripts/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
      })();
    </script>
  </div>
  
  <div class="giscus"></div>
  <div id="tcomment"></div>
</div>
<script 
  src="https://giscus.app/client.js" 
  data-repo="dlzmoe/blog" 
  data-repo-id="R_kgDOJkJvtw"
  data-category="Announcements" 
  data-category-id="DIC_kwDOJkJvt84CX9d6" 
  data-mapping="pathname" 
  data-strict="0"
  data-reactions-enabled="1" 
  data-emit-metadata="1" 
  data-input-position="top" 
  data-theme="light_tritanopia"
  data-lang="zh-CN" 
  data-loading="lazy" 
  crossorigin="anonymous" 
  async>
</script>

<script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.42/dist/twikoo.min.js"></script>
<script>
twikoo.init({
  envId: 'https://twikoo.zishu.me/.netlify/functions/twikoo',
  el: '#tcomment',
  lang: 'zh-CN', 
})
</script>

<script>
  $('.comment-tabs li').each(function(){
    $('.comment-tabs li').eq(0).addClass('active');
    $('.comments > div').eq(0).addClass('active');
    $(this).click(function(){
      $(this).addClass('active').siblings().removeClass('active');
      $('.comments > div').eq($(this).index()).addClass('active').siblings().removeClass('active');
    })
  })
</script>
      

      <footer class="footer">
  <div class="l-wrap">
    © 2020 - 2025 Powered by
    <a href="https://github.com/dlzmoe" target="_blank">子舒</a>
  </div>
  <img src="https://profile-counter.glitch.me/zishu_me/count.svg" alt="counter">
  <div class="gotop"></div>
</footer>

<script src="/js/main.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//instant.page/5.2.0" type="module" integrity="sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z"></script>
    </div>
  </div>
</body>

</html>