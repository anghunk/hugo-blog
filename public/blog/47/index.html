<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>webpack 的核心概念和构建流程 | 子舒的博客</title>
<meta name=keywords content="js,webpack"><meta name=description content="1.webpack 的核心概念

entry（入口）：一个可执行模块或者库的入口。定义了打包后的入口文件。
output（出口）：指示 webpack 如何去输出，以及在哪里输出。
path: 打包文件存放的绝对路径
publicPath: 网站运行时的访问路径
filename: 打包后的文件名
module（模块）：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。
chunk（代码块）：一个 chunk 由多个 模块 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk，这就是打包。
loader（模块转换器）：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。
plugin（扩展）：扩展 webpack 功能的插件。在 webpack 构建的生命周期节点上加入扩展 hook，添加功能。

2.webpack 构建流程

初始化参数：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。
开始编译：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。
确定入口：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。
编译模块：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。
完成模块编译并输出：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk。
输出完成：输出所有的 chunk 到文件系统。

3.有哪些常见的 loader？

babel-loader：把 es6 转成 es5；
css-loader：加载 css，支持模块化，压缩，文件导入等特性；
style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css；
eslint-loader：通过 Eslint 检查 js 代码；
image-loader：加载并且压缩图片晚间；
file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件；
url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。
source-map-loader：加载额外的 source map 文件，方便调试。

4.业务场景和对应解决方案
1.单页应用
一个单页应用需要配置一个 entry 指明执行入口，web-webpack-plugin 里的 WebPlugin 可以自动的完成这些工作：webpack 会为 entry 生成一个包含这个入口的所有依赖文件的 chunk，但是还需要一个 html 来加载 chunk 生成的 js，如果还提取出 css 需要 HTML 文件中引入提取的 css。"><meta name=author content="map[email:anghunk#gmail.com name:子舒]"><link rel=canonical href=http://localhost:1313/blog/47/><link crossorigin=anonymous href=/assets/css/stylesheet.7b595bcce56eb9e0f101a41e3a3cc677e29ecd3da3f37fb1a4fcbd6d3b880a67.css integrity="sha256-e1lbzOVuueDxAaQeOjzGd+KezT2j83+xpPy9bTuICmc=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/47/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="webpack 的核心概念和构建流程"><meta property="og:description" content="1.webpack 的核心概念

entry（入口）：一个可执行模块或者库的入口。定义了打包后的入口文件。
output（出口）：指示 webpack 如何去输出，以及在哪里输出。
path: 打包文件存放的绝对路径
publicPath: 网站运行时的访问路径
filename: 打包后的文件名
module（模块）：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。
chunk（代码块）：一个 chunk 由多个 模块 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk，这就是打包。
loader（模块转换器）：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。
plugin（扩展）：扩展 webpack 功能的插件。在 webpack 构建的生命周期节点上加入扩展 hook，添加功能。

2.webpack 构建流程

初始化参数：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。
开始编译：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。
确定入口：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。
编译模块：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。
完成模块编译并输出：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk。
输出完成：输出所有的 chunk 到文件系统。

3.有哪些常见的 loader？

babel-loader：把 es6 转成 es5；
css-loader：加载 css，支持模块化，压缩，文件导入等特性；
style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css；
eslint-loader：通过 Eslint 检查 js 代码；
image-loader：加载并且压缩图片晚间；
file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件；
url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。
source-map-loader：加载额外的 source map 文件，方便调试。

4.业务场景和对应解决方案
1.单页应用
一个单页应用需要配置一个 entry 指明执行入口，web-webpack-plugin 里的 WebPlugin 可以自动的完成这些工作：webpack 会为 entry 生成一个包含这个入口的所有依赖文件的 chunk，但是还需要一个 html 来加载 chunk 生成的 js，如果还提取出 css 需要 HTML 文件中引入提取的 css。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/blog/47/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-01-18T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-18T00:00:00+00:00"><meta property="og:site_name" content="子舒的博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="webpack 的核心概念和构建流程"><meta name=twitter:description content="1.webpack 的核心概念

entry（入口）：一个可执行模块或者库的入口。定义了打包后的入口文件。
output（出口）：指示 webpack 如何去输出，以及在哪里输出。
path: 打包文件存放的绝对路径
publicPath: 网站运行时的访问路径
filename: 打包后的文件名
module（模块）：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。
chunk（代码块）：一个 chunk 由多个 模块 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk，这就是打包。
loader（模块转换器）：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。
plugin（扩展）：扩展 webpack 功能的插件。在 webpack 构建的生命周期节点上加入扩展 hook，添加功能。

2.webpack 构建流程

初始化参数：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。
开始编译：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。
确定入口：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。
编译模块：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。
完成模块编译并输出：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk。
输出完成：输出所有的 chunk 到文件系统。

3.有哪些常见的 loader？

babel-loader：把 es6 转成 es5；
css-loader：加载 css，支持模块化，压缩，文件导入等特性；
style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css；
eslint-loader：通过 Eslint 检查 js 代码；
image-loader：加载并且压缩图片晚间；
file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件；
url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。
source-map-loader：加载额外的 source map 文件，方便调试。

4.业务场景和对应解决方案
1.单页应用
一个单页应用需要配置一个 entry 指明执行入口，web-webpack-plugin 里的 WebPlugin 可以自动的完成这些工作：webpack 会为 entry 生成一个包含这个入口的所有依赖文件的 chunk，但是还需要一个 html 来加载 chunk 生成的 js，如果还提取出 css 需要 HTML 文件中引入提取的 css。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"http://localhost:1313/blog/"},{"@type":"ListItem","position":2,"name":"webpack 的核心概念和构建流程","item":"http://localhost:1313/blog/47/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"webpack 的核心概念和构建流程","name":"webpack 的核心概念和构建流程","description":"1.webpack 的核心概念 entry（入口）：一个可执行模块或者库的入口。定义了打包后的入口文件。 output（出口）：指示 webpack 如何去输出，以及在哪里输出。 path: 打包文件存放的绝对路径 publicPath: 网站运行时的访问路径 filename: 打包后的文件名 module（模块）：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。 chunk（代码块）：一个 chunk 由多个 模块 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk，这就是打包。 loader（模块转换器）：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。 plugin（扩展）：扩展 webpack 功能的插件。在 webpack 构建的生命周期节点上加入扩展 hook，添加功能。 2.webpack 构建流程 初始化参数：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。 开始编译：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。 确定入口：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。 编译模块：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。 完成模块编译并输出：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk。 输出完成：输出所有的 chunk 到文件系统。 3.有哪些常见的 loader？ babel-loader：把 es6 转成 es5； css-loader：加载 css，支持模块化，压缩，文件导入等特性； style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css； eslint-loader：通过 Eslint 检查 js 代码； image-loader：加载并且压缩图片晚间； file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件； url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。 source-map-loader：加载额外的 source map 文件，方便调试。 4.业务场景和对应解决方案 1.单页应用 一个单页应用需要配置一个 entry 指明执行入口，web-webpack-plugin 里的 WebPlugin 可以自动的完成这些工作：webpack 会为 entry 生成一个包含这个入口的所有依赖文件的 chunk，但是还需要一个 html 来加载 chunk 生成的 js，如果还提取出 css 需要 HTML 文件中引入提取的 css。\n","keywords":["js","webpack"],"articleBody":"1.webpack 的核心概念 entry（入口）：一个可执行模块或者库的入口。定义了打包后的入口文件。 output（出口）：指示 webpack 如何去输出，以及在哪里输出。 path: 打包文件存放的绝对路径 publicPath: 网站运行时的访问路径 filename: 打包后的文件名 module（模块）：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。 chunk（代码块）：一个 chunk 由多个 模块 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk，这就是打包。 loader（模块转换器）：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。 plugin（扩展）：扩展 webpack 功能的插件。在 webpack 构建的生命周期节点上加入扩展 hook，添加功能。 2.webpack 构建流程 初始化参数：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。 开始编译：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。 确定入口：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。 编译模块：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。 完成模块编译并输出：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk。 输出完成：输出所有的 chunk 到文件系统。 3.有哪些常见的 loader？ babel-loader：把 es6 转成 es5； css-loader：加载 css，支持模块化，压缩，文件导入等特性； style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css； eslint-loader：通过 Eslint 检查 js 代码； image-loader：加载并且压缩图片晚间； file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件； url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。 source-map-loader：加载额外的 source map 文件，方便调试。 4.业务场景和对应解决方案 1.单页应用 一个单页应用需要配置一个 entry 指明执行入口，web-webpack-plugin 里的 WebPlugin 可以自动的完成这些工作：webpack 会为 entry 生成一个包含这个入口的所有依赖文件的 chunk，但是还需要一个 html 来加载 chunk 生成的 js，如果还提取出 css 需要 HTML 文件中引入提取的 css。\n一个简单的 webpack 配置文件例子：\nconst { WebPlugin } = require('web-webpack-plugin'); module.exports = { entry: { app: './src/doc/index.js', home: './src/doc/home.js' }, plugins: [ // 一个 WebPlugin 对应生成一个 html 文件 new WebPlugin({ //输出的 html 文件名称 filename: 'index.html', //这个 html 依赖的`entry` requires: ['app','home'], }), ], }; 说明：require: [‘app’, ‘home’]指明这个 html 依赖哪些 entry，entry 生成的 js 和 css 会自动注入到 html 中。\n还支持配置这些资源注入方式，支持如下属性：\n_dist 只有在生产环境中才引入的资源； _dev 只有在开发环境中才引入的资源； _inline 把资源的内容潜入到 html 中； _ie 只有 IE 浏览器才需要引入的资源。 这些属性可以通过在 js 里配置，看个简单例子：\nnew WebPlugin({ filename: 'index.html', requires: { app:{ _dist:true, _inline:false, } }, }), 这些属性还可以在模板中设置，使用模板好处就是可以灵活的控制资源的注入点\nnew WebPlugin({ filename: 'index.html', template: './template.html', }), \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-cn\"\u003e \u003chead\u003e \u003clink rel=\"stylesheet\" href=\"app?_inline\"\u003e \u003cscript src=\"ie-polyfill?_ie\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"react-body\"\u003e\u003c/div\u003e \u003cscript src=\"app\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e WebPlugin 插件借鉴了 fis3 的思想，补足了 webpack 缺失的以 HTML 为入口的功能。想了解 WebPlugin 的更多功能，见文档。\n2.一个项目管理多个单页面 一个项目中会包含多个单页应用，虽然多个单页面应用可以合成一个，但是这样做会导致用户没有访问的部分也加载了，如果项目中有很多的单页应用。为每一个单页应用配置一个 entry 和 WebPlugin？如果又新增，又要新增 webpack 配置，这样做麻烦，这时候有一个插件 web-webpack-plugin 里的 AutoWebPlugin 方法可以解决这些问题。\nmodule.exports = { plugins: [ // 所有页面的入口目录 new AutoWebPlugin('./src/'), ] }; 分析：\nAutoWebPlugin会把./src/目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个 WebPlugin 输出对应的 html。 要新增一个页面就在 ./src/ 下新建一个文件夹包含这个单页应用所依赖的代码，AutoWebPlugin 自动生成一个名叫文件夹名称的 html 文件。 3.代码分隔优化 一个好的代码分割对浏览器首屏效果提升很大。\n最常见的 react 体系：\n先抽出基础库 react react-dom redux react-redux 到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件 hash 值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。所以把基础库打包成一个文件。 // vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新 // 所有页面都依赖的第三方库 // react 基础 import 'react'; import 'react-dom'; import 'react-redux'; // redux 基础 import 'redux'; import 'redux-thunk'; // webpack 配置 { entry: { vendor: './path/to/vendor.js', }, } 通过 CommonsChunkPlugin 可以提取出多个代码块都依赖的代码形成一个单独的 chunk。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。所以通过 CommonsChunkPlugin 可以提取出多个代码块都依赖的代码形成一个单独的 chunk。 4.构建服务端渲染 服务端渲染的代码要运行在 nodejs 环境，和浏览器不同的是，服务端渲染代码需要采用 commonjs 规范同时不应该包含除 js 之外的文件比如 css。\nwebpack 配置如下：\nmodule.exports = { target: 'node', entry: { 'server_render': './src/server_render', }, output: { filename: './dist/server/[name].js', libraryTarget: 'commonjs2', }, module: { rules: [ { test: /\\.js$/, loader: 'babel-loader', }, { test: /\\.(scss|css|pdf)$/, loader: 'ignore-loader', }, ] }, }; 分析一下：\ntarget: 'node' 指明构建出代码要运行在 node 环境中。 libraryTarget: 'commonjs2' 指明输出的代码要是 commonjs 规范。 {test: /\\.(scss|css|pdf)$/,loader: 'ignore-loader'} 是为了防止不能在 node 里执行服务端渲染也用不上的文件被打包进去。 5.fis3 迁移到 webpack fis3 和 webpack 有很多相似地方也有不同的地方，相似地方：都采用 commonjs 规范，不同地方：导入 css 这些非 js 资源的方式。\nfis3 通过@require ‘./index.scss’，而 webpack 是通过 require(’./index.scss’)。\n如果想把 fis3 平滑迁移到 webpack，可以使用 comment-require-loader。\n比如：你想在 webpack 构建是使用采用了 fis3 方式的 imui 模块\nloaders:[{ test: /\\.js$/, loaders: ['comment-require-loader'], include: [path.resolve(__dirname, 'node_modules/imui'),] }] 5.自定义 webpack 扩展 如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写 loader 或者 plugin 了。\n在你编写自定义 webpack 扩展前你需要想明白到底是要做一个 loader 还是 plugin 呢？可以这样判断：\n如果你的扩展是想对一个个单独的文件进行转换那么就编写 loader 剩下的都是 plugin。\n其中对文件进行转换可以是像：\nbabel-loader 把 es6 转为 es5； file-loader 把文件替换成对应的 url； raw-loader 注入文本文件内容到代码中。 1.编写 webpack loader 编写 loader 非常简单，以 comment-require-loader 为例：\nmodule.exports = function (content) { return replace(content); }; loader 的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。\n函数接收的参数 content 是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过 loader。从这里可以看出 loader 只能处理一个个单独的文件而不能处理代码块。可以参考官方文档。\n2. 编写 webpack plugin plugin 应用场景广泛，所以稍微复杂点。以 end-webpack-plugin 为例：\nclass EndWebpackPlugin { constructor(doneCallback, failCallback) { this.doneCallback = doneCallback; this.failCallback = failCallback; } apply(compiler) { // 监听 webpack 生命周期里的事件，做相应的处理 compiler.plugin('done', (stats) =\u003e { this.doneCallback(stats); }); compiler.plugin('failed', (err) =\u003e { this.failCallback(err); }); } } module.exports = EndWebpackPlugin; loader 的入口需要导出一个 class，在 new EndWebpackPlugin() 的时候通过构造函数传入这个插件需要的参数，在 webpack 启动的时候会先实例化 plugin，再调用 plugin 的 apply 方法，插件在 apply 函数里监听 webpack 生命周期里的事件，做相应的处理。\nwebpack plugin 的两个核心概念：\ncompiler：从 webpack 启动到退出只存在一个 Compiler，compiler 存放着 webpack 的配置。 compilation：由于 webpack 的监听文件变化自动编译机制，compilation 代表一次编译。 Compiler 和 Compilation 都会广播一系列事件。webpack 生命周期里有非常多的事件。\n以上只是一个最简单的 demo，更复杂的可以查看 how to write a plugin 或参考 web-webpack-plugin。\n参考文章：https://www.cnblogs.com/chengxs/p/11022842.html\n","wordCount":"3228","inLanguage":"en","datePublished":"2021-01-18T00:00:00Z","dateModified":"2021-01-18T00:00:00Z","author":{"@type":"Person","name":{"email":"anghunk#gmail.com","name":"子舒"}},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/47/"},"publisher":{"@type":"Organization","name":"子舒的博客","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="🧐zishu:~$ (Alt + H)">🧐zishu:~$</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/blog/ title=~/blog/><span>~/blog/</span></a></li><li><a href=http://localhost:1313/categories/ title=~/categories/><span>~/categories/</span></a></li><li><a href=http://localhost:1313/about title=~/about><span>~/about</span></a></li><li><a href=http://localhost:1313/now title=~/now><span>~/now</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">webpack 的核心概念和构建流程</h1><div class=post-meta><span title='2021-01-18 00:00:00 +0000 UTC'>January 18, 2021</span>&nbsp;·&nbsp;14 min</div></header><div class=post-content><h2 id=1webpack-的核心概念><a hidden class=anchor aria-hidden=true href=#1webpack-的核心概念>#</a>1.webpack 的核心概念</h2><ol><li><strong>entry（入口）</strong>：一个可执行模块或者库的入口。定义了打包后的入口文件。</li><li><strong>output（出口）</strong>：指示 webpack 如何去输出，以及在哪里输出。
path: 打包文件存放的绝对路径
publicPath: 网站运行时的访问路径
filename: 打包后的文件名</li><li><strong>module（模块）</strong>：在 webpack 里，一切皆模块，一个模块对应一个文件。webpack 会从配置的 entry 中开始递归找出所有依赖的模块。</li><li><strong>chunk（代码块）</strong>：一个 <code>chunk</code> 由多个 <code>模块</code> 组合而成。可以将可执行的模块和他所依赖的模块组合成一个 chunk，这就是打包。</li><li><strong>loader（模块转换器）</strong>：用于把一个模块原内容按照需求转换成新的内容。例如：es6 转换为 es5，scss 转换为 css 等。</li><li><strong>plugin（扩展）</strong>：扩展 webpack 功能的插件。在 webpack 构建的生命周期节点上加入扩展 hook，添加功能。</li></ol><h2 id=2webpack-构建流程><a hidden class=anchor aria-hidden=true href=#2webpack-构建流程>#</a>2.webpack 构建流程</h2><ol><li><strong>初始化参数</strong>：解析 webpack 的配置参数，合并 shell 传入和 webpack.config.js 文件配置的参数，形成最后的配置结果。</li><li><strong>开始编译</strong>：上一步得到的参数初始化 compiler 对象，注册所有配置的插件，插件监听 webpack 构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</li><li><strong>确定入口</strong>：其配置的 entry 入口，开始解析文件构建的 AST 语法树，找出依赖，递归下去。</li><li><strong>编译模块</strong>：根据文件类型和 loader 配置，调用所有配置的 loader 对文件进行转换，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理。</li><li><strong>完成模块编译并输出</strong>：递归完后，得到每个文件结果，包含了每个模块及她们之间的依赖关系，根据 entry 配置生成代码块 chunk。</li><li><strong>输出完成</strong>：输出所有的 chunk 到文件系统。</li></ol><h2 id=3有哪些常见的-loader><a hidden class=anchor aria-hidden=true href=#3有哪些常见的-loader>#</a>3.有哪些常见的 loader？</h2><ol><li>babel-loader：把 es6 转成 es5；</li><li>css-loader：加载 css，支持模块化，压缩，文件导入等特性；</li><li>style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css；</li><li>eslint-loader：通过 Eslint 检查 js 代码；</li><li>image-loader：加载并且压缩图片晚间；</li><li>file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件；</li><li>url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。</li><li>source-map-loader：加载额外的 source map 文件，方便调试。</li></ol><h2 id=4业务场景和对应解决方案><a hidden class=anchor aria-hidden=true href=#4业务场景和对应解决方案>#</a>4.业务场景和对应解决方案</h2><h3 id=1单页应用><a hidden class=anchor aria-hidden=true href=#1单页应用>#</a>1.单页应用</h3><p>一个单页应用需要配置一个 entry 指明执行入口，web-webpack-plugin 里的 WebPlugin 可以自动的完成这些工作：webpack 会为 entry 生成一个包含这个入口的所有依赖文件的 chunk，但是还需要一个 html 来加载 chunk 生成的 js，如果还提取出 css 需要 HTML 文件中引入提取的 css。</p><p>一个简单的 webpack 配置文件例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>WebPlugin</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;web-webpack-plugin&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>entry</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>app</span><span class=o>:</span> <span class=s1>&#39;./src/doc/index.js&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>home</span><span class=o>:</span> <span class=s1>&#39;./src/doc/home.js&#39;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nx>plugins</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 一个 WebPlugin 对应生成一个 html 文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>new</span> <span class=nx>WebPlugin</span><span class=p>({</span>
</span></span><span class=line><span class=cl>      <span class=c1>//输出的 html 文件名称
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>filename</span><span class=o>:</span> <span class=s1>&#39;index.html&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=c1>//这个 html 依赖的`entry`
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>requires</span><span class=o>:</span> <span class=p>[</span><span class=s1>&#39;app&#39;</span><span class=p>,</span><span class=s1>&#39;home&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>}),</span>
</span></span><span class=line><span class=cl>  <span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><blockquote><p>说明：require: [&lsquo;app&rsquo;, &lsquo;home&rsquo;]指明这个 html 依赖哪些 entry，entry 生成的 js 和 css 会自动注入到 html 中。</p></blockquote><p>还支持配置这些资源注入方式，支持如下属性：</p><ol><li>_dist 只有在生产环境中才引入的资源；</li><li>_dev 只有在开发环境中才引入的资源；</li><li>_inline 把资源的内容潜入到 html 中；</li><li>_ie 只有 IE 浏览器才需要引入的资源。</li></ol><p>这些属性可以通过在 js 里配置，看个简单例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=k>new</span> <span class=nx>WebPlugin</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>filename</span><span class=o>:</span> <span class=s1>&#39;index.html&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>requires</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>app</span><span class=o>:</span><span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nx>_dist</span><span class=o>:</span><span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nx>_inline</span><span class=o>:</span><span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}),</span>
</span></span></code></pre></div><p>这些属性还可以在模板中设置，使用模板好处就是可以灵活的控制资源的注入点</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=k>new</span> <span class=nx>WebPlugin</span><span class=p>({</span>
</span></span><span class=line><span class=cl>      <span class=nx>filename</span><span class=o>:</span> <span class=s1>&#39;index.html&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>template</span><span class=o>:</span> <span class=s1>&#39;./template.html&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}),</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=cp>&lt;!DOCTYPE html&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span> <span class=na>lang</span><span class=o>=</span><span class=s>&#34;zh-cn&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>link</span> <span class=na>rel</span><span class=o>=</span><span class=s>&#34;stylesheet&#34;</span> <span class=na>href</span><span class=o>=</span><span class=s>&#34;app?_inline&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>script</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;ie-polyfill?_ie&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>div</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;react-body&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>script</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;app&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>WebPlugin 插件借鉴了 fis3 的思想，补足了 webpack 缺失的以 HTML 为入口的功能。想了解 WebPlugin 的更多功能，见文档。</p><h3 id=2一个项目管理多个单页面><a hidden class=anchor aria-hidden=true href=#2一个项目管理多个单页面>#</a>2.一个项目管理多个单页面</h3><p>一个项目中会包含多个单页应用，虽然多个单页面应用可以合成一个，但是这样做会导致用户没有访问的部分也加载了，如果项目中有很多的单页应用。为每一个单页应用配置一个 entry 和 WebPlugin？如果又新增，又要新增 webpack 配置，这样做麻烦，这时候有一个插件 web-webpack-plugin 里的 AutoWebPlugin 方法可以解决这些问题。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>plugins</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 所有页面的入口目录
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>new</span> <span class=nx>AutoWebPlugin</span><span class=p>(</span><span class=s1>&#39;./src/&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>分析：</strong></p><ol><li><code>AutoWebPlugin</code>会把./src/目录下所有每个文件夹作为一个单页页面的入口，自动为所有的页面入口配置一个 <code>WebPlugin</code> 输出对应的 html。</li><li>要新增一个页面就在 <code>./src/</code> 下新建一个文件夹包含这个单页应用所依赖的代码，<code>AutoWebPlugin</code> 自动生成一个名叫文件夹名称的 html 文件。</li></ol><h3 id=3代码分隔优化><a hidden class=anchor aria-hidden=true href=#3代码分隔优化>#</a>3.代码分隔优化</h3><p>一个好的代码分割对浏览器首屏效果提升很大。</p><p><strong>最常见的 react 体系：</strong></p><ol><li>先抽出基础库 react react-dom redux react-redux 到一个单独的文件而不是和其它文件放在一起打包为一个文件，这样做的好处是只要你不升级他们的版本这个文件永远不会被刷新。如果你把这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件 hash 值变化从而导致缓存失效浏览器重复下载这些包含基础库的代码。所以把基础库打包成一个文件。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// vender.js 文件抽离基础库到单独的一个文件里防止跟随业务代码被刷新
</span></span></span><span class=line><span class=cl><span class=c1>// 所有页面都依赖的第三方库
</span></span></span><span class=line><span class=cl><span class=c1>// react 基础
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=s1>&#39;react&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=s1>&#39;react-dom&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=s1>&#39;react-redux&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// redux 基础
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=s1>&#39;redux&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=s1>&#39;redux-thunk&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// webpack 配置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>entry</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>vendor</span><span class=o>:</span> <span class=s1>&#39;./path/to/vendor.js&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li>通过 CommonsChunkPlugin 可以提取出多个代码块都依赖的代码形成一个单独的 chunk。在应用有多个页面的场景下提取出所有页面公共的代码减少单个页面的代码，在不同页面之间切换时所有页面公共的代码之前被加载过而不必重新加载。所以通过 CommonsChunkPlugin 可以提取出多个代码块都依赖的代码形成一个单独的 chunk。</li></ol><h3 id=4构建服务端渲染><a hidden class=anchor aria-hidden=true href=#4构建服务端渲染>#</a>4.构建服务端渲染</h3><p>服务端渲染的代码要运行在 nodejs 环境，和浏览器不同的是，服务端渲染代码需要采用 commonjs 规范同时不应该包含除 js 之外的文件比如 css。</p><p>webpack 配置如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>target</span><span class=o>:</span> <span class=s1>&#39;node&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>entry</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;server_render&#39;</span><span class=o>:</span> <span class=s1>&#39;./src/server_render&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nx>output</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>filename</span><span class=o>:</span> <span class=s1>&#39;./dist/server/[name].js&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>libraryTarget</span><span class=o>:</span> <span class=s1>&#39;commonjs2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nx>module</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rules</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>test</span><span class=o>:</span> <span class=sr>/\.js$/</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>loader</span><span class=o>:</span> <span class=s1>&#39;babel-loader&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>test</span><span class=o>:</span> <span class=sr>/\.(scss|css|pdf)$/</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>loader</span><span class=o>:</span> <span class=s1>&#39;ignore-loader&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>分析一下：</strong></p><ol><li><code>target: 'node'</code> 指明构建出代码要运行在 node 环境中。</li><li><code>libraryTarget: 'commonjs2'</code> 指明输出的代码要是 commonjs 规范。</li><li><code>{test: /\.(scss|css|pdf)$/,loader: 'ignore-loader'}</code> 是为了防止不能在 node 里执行服务端渲染也用不上的文件被打包进去。</li></ol><h3 id=5fis3-迁移到-webpack><a hidden class=anchor aria-hidden=true href=#5fis3-迁移到-webpack>#</a>5.fis3 迁移到 webpack</h3><p>fis3 和 webpack 有很多相似地方也有不同的地方，相似地方：都采用 commonjs 规范，不同地方：导入 css 这些非 js 资源的方式。</p><p>fis3 通过@require &lsquo;./index.scss&rsquo;，而 webpack 是通过 require(&rsquo;./index.scss&rsquo;)。</p><p>如果想把 fis3 平滑迁移到 webpack，可以使用 comment-require-loader。</p><p>比如：你想在 webpack 构建是使用采用了 fis3 方式的 imui 模块</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>loaders</span><span class=o>:</span><span class=p>[{</span>
</span></span><span class=line><span class=cl>     <span class=nx>test</span><span class=o>:</span> <span class=sr>/\.js$/</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nx>loaders</span><span class=o>:</span> <span class=p>[</span><span class=s1>&#39;comment-require-loader&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>     <span class=nx>include</span><span class=o>:</span> <span class=p>[</span><span class=nx>path</span><span class=p>.</span><span class=nx>resolve</span><span class=p>(</span><span class=nx>__dirname</span><span class=p>,</span> <span class=s1>&#39;node_modules/imui&#39;</span><span class=p>),]</span>
</span></span><span class=line><span class=cl><span class=p>}]</span>
</span></span></code></pre></div><h2 id=5自定义-webpack-扩展><a hidden class=anchor aria-hidden=true href=#5自定义-webpack-扩展>#</a>5.自定义 webpack 扩展</h2><p>如果你在社区找不到你的应用场景的解决方案，那就需要自己动手了写 loader 或者 plugin 了。</p><p>在你编写自定义 webpack 扩展前你需要想明白到底是要做一个 loader 还是 plugin 呢？可以这样判断：</p><p>如果你的扩展是想对一个个单独的文件进行转换那么就编写 loader 剩下的都是 plugin。</p><p>其中对文件进行转换可以是像：</p><ol><li>babel-loader 把 es6 转为 es5；</li><li>file-loader 把文件替换成对应的 url；</li><li>raw-loader 注入文本文件内容到代码中。</li></ol><h3 id=1编写-webpack-loader><a hidden class=anchor aria-hidden=true href=#1编写-webpack-loader>#</a>1.编写 webpack loader</h3><p>编写 loader 非常简单，以 comment-require-loader 为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>content</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>replace</span><span class=p>(</span><span class=nx>content</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>loader 的入口需要导出一个函数，这个函数要干的事情就是转换一个文件的内容。</p><p>函数接收的参数 content 是一个文件在转换前的字符串形式内容，需要返回一个新的字符串形式内容作为转换后的结果，所有通过模块化倒入的文件都会经过 loader。从这里可以看出 loader 只能处理一个个单独的文件而不能处理代码块。可以参考官方文档。</p><h3 id=2-编写-webpack-plugin><a hidden class=anchor aria-hidden=true href=#2-编写-webpack-plugin>#</a>2. 编写 webpack plugin</h3><p>plugin 应用场景广泛，所以稍微复杂点。以 end-webpack-plugin 为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>class</span> <span class=nx>EndWebpackPlugin</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>doneCallback</span><span class=p>,</span> <span class=nx>failCallback</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>doneCallback</span> <span class=o>=</span> <span class=nx>doneCallback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>failCallback</span> <span class=o>=</span> <span class=nx>failCallback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>apply</span><span class=p>(</span><span class=nx>compiler</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 监听 webpack 生命周期里的事件，做相应的处理
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>compiler</span><span class=p>.</span><span class=nx>plugin</span><span class=p>(</span><span class=s1>&#39;done&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>stats</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=p>.</span><span class=nx>doneCallback</span><span class=p>(</span><span class=nx>stats</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=nx>compiler</span><span class=p>.</span><span class=nx>plugin</span><span class=p>(</span><span class=s1>&#39;failed&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=p>.</span><span class=nx>failCallback</span><span class=p>(</span><span class=nx>err</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>module</span><span class=p>.</span><span class=nx>exports</span> <span class=o>=</span> <span class=nx>EndWebpackPlugin</span><span class=p>;</span>
</span></span></code></pre></div><p>loader 的入口需要导出一个 class，在 new EndWebpackPlugin() 的时候通过构造函数传入这个插件需要的参数，在 webpack 启动的时候会先实例化 plugin，再调用 plugin 的 apply 方法，插件在 apply 函数里监听 webpack 生命周期里的事件，做相应的处理。</p><p><strong>webpack plugin 的两个核心概念：</strong></p><ol><li>compiler：从 webpack 启动到退出只存在一个 Compiler，compiler 存放着 webpack 的配置。</li><li>compilation：由于 webpack 的监听文件变化自动编译机制，compilation 代表一次编译。</li></ol><p>Compiler 和 Compilation 都会广播一系列事件。webpack 生命周期里有非常多的事件。</p><p>以上只是一个最简单的 demo，更复杂的可以查看 how to write a plugin 或参考 web-webpack-plugin。</p><blockquote><p>参考文章：https://www.cnblogs.com/chengxs/p/11022842.html</p></blockquote></div><footer class=post-footer><ul class=post-tags></ul><div class=post-reactions><open-heart href="https://open-heart-worker.zhuzi.workers.dev/?id=http%3a%2f%2flocalhost%3a1313%2fblog%2f47%2f" emoji=💗>💗</open-heart></div><script src=https://unpkg.com/open-heart-element type=module></script><script>window.customElements.whenDefined("open-heart").then(()=>{for(const e of document.querySelectorAll("open-heart"))e.getCount()}),window.addEventListener("open-heart",e=>{e&&e.target&&e.target.getCount&&e.target.getCount()})</script><nav class=paginav><a class=prev href=http://localhost:1313/blog/48/><div class=title><span class=anchor-prev>«</span>ES5 和 ES6 的区别？</div></a><a class=next href=http://localhost:1313/blog/46/><div class=title>小张厨房日记（二）<span class=anchor-next>»</span></div></a></nav></footer><div class=post-comments><div class="post-comments-content giscus"></div></div><script>const group=document.querySelectorAll('input[name="comment-provider"]'),contents=document.querySelectorAll(".post-comments-content"),handleChange=()=>{let e=document.querySelector('input[name="comment-provider"]:checked+.tab');e&&(e=e.textContent.toLowerCase(),contents.forEach(t=>{t.classList.contains(e)?t.style.display="block":t.style.display="none"}))};group.forEach(e=>e.addEventListener("input",handleChange))</script></article></main><footer class=footer><div class=footer-inner><span>All those moments will be lost in time, like tears in rain...</span><div class=social-icons><a href=https://github.com/dlzmoe target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href target=_blank rel="noopener noreferrer me" title=Mastodon><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.58 13.913c-.29 1.469-2.592 3.121-5.238 3.396-1.379.184-2.737.368-4.185.276-2.368-.092-4.237-.551-4.237-.551.0.184.014.459.043.643.308 2.294 2.317 2.478 4.22 2.57 1.922.0 3.633-.46 3.633-.46l.079 1.653s-1.344.734-3.738.918c-1.32.091-2.96-.092-4.869-.551-4.14-1.102-4.853-5.507-4.961-10.005-.034-1.285-.013-2.57-.013-3.58.0-4.589 3-5.966 3-5.966 1.513-.734 4.11-1.01 6.808-1.01h.067c2.699.0 5.296.276 6.81 1.01.0.0 3 1.377 3 5.967.0.0.037 3.304-.419 5.69" stroke="currentcolor"/><path d="M17.832 8.633v5h-1.978V8.78c0-1.023-.43-1.542-1.29-1.542-.95.0-1.427.616-1.427 1.834v2.655H11.17V9.072c0-1.218-.476-1.834-1.427-1.834-.86.0-1.29.52-1.29 1.542v4.852H6.475V8.633c0-1.022.26-1.834.782-2.434.538-.6 1.243-.909 2.118-.909 1.012.0 1.779.39 2.286 1.169l.492.827.493-.827c.507-.78 1.274-1.169 2.286-1.169.875.0 1.58.308 2.118.909.522.6.782 1.412.782 2.434" fill="currentcolor" stroke="none"/></svg>
</a><a href target=_blank rel="noopener noreferrer me" title=X><svg viewBox="0 0 24 24" fill="currentcolor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
</a><a href target=_blank rel="noopener noreferrer me" title=Instagram><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg>
</a><a href target=_blank rel="noopener noreferrer me" title=Telegram><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.198 2.433a2.242 2.242.0 00-1.022.215l-8.609 3.33c-2.068.8-4.133 1.598-5.724 2.21a405.15 405.15.0 01-2.849 1.09c-.42.147-.99.332-1.473.901-.728.968.193 1.798.919 2.286 1.61.516 3.275 1.009 4.654 1.472.509 1.793.997 3.592 1.48 5.388.16.36.506.494.864.498l-.002.018s.281.028.555-.038a2.1 2.1.0 00.933-.517c.345-.324 1.28-1.244 1.811-1.764l3.999 2.952.032.018s.442.311 1.09.355c.324.022.75-.04 1.116-.308.37-.27.613-.702.728-1.196.342-1.492 2.61-12.285 2.997-14.072l-.01.042c.27-1.006.17-1.928-.455-2.474a1.654 1.654.0 00-1.034-.407z"/></svg>
</a><a href=mailto:anghunk@gmail.com target=_blank rel="noopener noreferrer me" title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</a><a href=/index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></div><div class=footer-copyright>&copy; 2025 <a href=http://localhost:1313/>子舒的博客</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>