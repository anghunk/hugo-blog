<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
	<title>Blogs - 子舒的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/blog/index.xml" title="子舒的博客">

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="topbar">
		<a class="topbar__link" href="/" title="子舒的博客" rel="sidebar">
			<div class="topbar__item topbar__text">
					<div class="topbar__title">子舒的博客</div>
					<div class="topbar__tagline">我的独立博客，记录了很多东西，随笔、周刊、笔记等，欢迎访问！</div>
				</div>
		</a>
	</div>
		
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Blogs</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/43.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">使用 React 与 Vue 创建同一款 App，差别究竟有多大？</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2021-01-06T00:00:00Z">2021-01-06</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 React 框架 和 Vue 框架 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？
转载于：https://blog.csdn.net/csdnnews/article/details/81880378 原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd 作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 译者：安翔，责编：屠敏
众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。
于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。
很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。
1.目标 我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面）构建，React 使用 create-react-app，Vue 使用 vue-cli。
两个应用程序的外观如下：
两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构：
你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。
两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。
在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观：
现在让我们正式开始，深入其中的细节！
2.如何修改数据 首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象：
vue 数据对象
React 状态对象
从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。
假设我们有一个名为 name: ‘Sunil’的数据元素。
在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name =&lsquo;John&rsquo; 来更新它。这样一来，名字就被成功改为了“Jhon”。
在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name =&lsquo;John&rsquo;，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：&lsquo;John&rsquo;})。
虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。那么为什么 React 没有进行简化，为什么需要 setState 呢？Revanth Kumar 对此做出了解释：
“这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。&quot;
3.添加新的待办事项 React 的实现方法 createNewToDoItem = () =&gt; { this.setState( ({ list, todo }) =&gt; ({ list: [ ...list, { todo } ], todo: &#39;&#39; }) ); }; 在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟：
&lt;input type=&#34;text&#34; value={this.state.todo} onChange={this.handleInput}/&gt; 只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下：
handleInput = e =&gt; { this.setState({ todo: e.target.value }); }; 现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的 todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加 todo。整个列表是通过使用扩展运算符添加的。
最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。
Vue 的实现方法 createNewToDoItem() { this.list.push( { &#39;todo&#39;: this.todo } ); this.todo = &#39;&#39;; } 在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下：
&lt;input type=&#34;text&#34; v-model=&#34;todo&#34;/&gt; V-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：&rsquo; &lsquo;。如果已经存在数据，例如 todo：&lsquo;添加文本处&rsquo;，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。
因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中，然后将 todo 改为空字符串。
4.删除待办事项 React 的实现方法 deleteItem = indexToDelete =&gt; { this.setState(({ list }) =&gt; ({ list: list.filter((toDo, index) =&gt; index !== indexToDelete) })); }; 尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递：
&lt;ToDoItem deleteItem={this.deleteItem.bind(this, key)}/&gt; 这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem。然后，在 ToDoItem 组件内部，我们执行以下操作：
&lt;div className=”ToDoItem-Delete” onClick={this.props.deleteItem}&gt;-&lt;/div&gt; 想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。
Vue 的实现方法 onDeleteItem(todo){ this.list = this.list.filter(item =&gt; item !== todo); } Vue 的实现方法稍有不同，我们需要做到以下三点：
首先，在元素上调用函数： &lt;div class=”ToDoItem-Delete” @click=”deleteItem(todo)”&gt;-&lt;/div&gt; 然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为 ToDoItem.vue），如下所示： deleteItem(todo) { this.$emit(&#39;delete&#39;, todo) } 之后，你会发现，当我们添加 ToDo.vue 的 ToDoItem.vue 时，实际上引用了一个函数： &lt;ToDoItem v-for=&#34;todo in list&#34; :todo=&#34;todo&#34; @delete=&#34;onDeleteItem&#34; // &lt;-- this :) :key=&#34;todo.id&#34; /&gt; 这就是所谓的自定义事件监听器。它会监听任何使用 &lsquo;delete&rsquo; 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组，以删除被点击的待办事项。
在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示：
&lt;div class=”ToDoItem-Delete” @click=”$emit(‘delete’, todo)”&gt;-&lt;/div&gt; 如果你喜欢，这样做可以把 3 步减少到 2 步。
React 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。
5.如何传递事件监听器 React 的实现方法 事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下：
&lt;div className=”ToDo-Add” onClick={this.createNewToDoItem}&gt;+&lt;/div&gt; 非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下：
&lt;input type=”text” onKeyPress={this.handleKeyPress}/&gt; 该函数只要识别到&rsquo;enter&rsquo;键被按下，它就会触发 createNewToDoItem 函数，代码如下所示：
handleKeyPress = (e) =&gt; { if (e.key === ‘Enter’) { this.createNewToDoItem(); } }; Vue 的实现方法 Vue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码：
&lt;div class=”ToDo-Add” @click=”createNewToDoItem()”&gt;+&lt;/div&gt; 注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下：
&lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&gt; 6.如何将数据传递给子组件 React 的实现方法 在 React 中，我们将 props 传递到子组件的创建处。比如：
&lt;ToDoItem key={key} item={todo} /&gt; 此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用 this.props.item。
Vue 的实现方法 在 Vue 中，我们将 props 传递到子组件创建处的方式如下：
&lt;ToDoItem v-for=&#34;todo in list&#34; :todo=&#34;todo&#34; :key=&#34;todo.id&#34; @delete=&#34;onDeleteItem&#34; /&gt; 我们将它们传递给子组件中的 props 数组，如：props：[&lsquo;id&rsquo;，&rsquo;todo&rsquo;]。然后可以在子组件中通过名字引用它们。
7.如何将数据发送回父组件 React 的实现方法 我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。
Vue 的实现方法 在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。
8.总结 我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。
两个应用程序的 GitHub 地址：
**Vue ToDo:**https://github.com/sunil-sandhu/vue-todo
**React ToDo:**https://github.com/sunil-sandhu/react-todo
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/42.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">React 脚手架项目打包时的路径问题</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2021-01-05T00:00:00Z">2021-01-05</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		create-react-app 脚手架指令可以生成 React 项目，在项目完成之后执行打包命令 npm run build，文件夹内生成 build文件夹，就是打包后的文件，在浏览器运行 index.html 发现页面空白，打开控制台有报错，css 和 js 文件的引用路径有问题。
浏览 index.html 代码可以发现：
&lt;!-- index.html --&gt; &lt;!doctype html&gt; &lt;html lang=&#34;zh&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34; /&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width,initial-scale=1&#34; /&gt; &lt;meta name=&#34;theme-color&#34; content=&#34;#000000&#34; /&gt; &lt;meta name=&#34;description&#34; content=&#34;Web site created using create-react-app&#34; /&gt; &lt;title&gt;React App&lt;/title&gt; &lt;link href=&#34;/static/css/main.3394d54e.chunk.css&#34; rel=&#34;stylesheet&#34;&gt; &lt;/head&gt; &lt;body&gt;&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id=&#34;root&#34;&gt;&lt;/div&gt; &lt;script&gt;!function (e) { function r(r) { for (var n, l, f = r[0], i = r[1], a = r[2], c = 0, s = []; c &lt; f.length; c++)l = f[c], Object.prototype.hasOwnProperty.call(o, l) &amp;&amp; o[l] &amp;&amp; s.push(o[l][0]), o[l] = 0; for (n in i) Object.prototype.hasOwnProperty.call(i, n) &amp;&amp; (e[n] = i[n]); for (p &amp;&amp; p(r); s.length;)s.shift()(); return u.push.apply(u, a || []), t() } function t() { for (var e, r = 0; r &lt; u.length; r++) { for (var t = u[r], n = !0, f = 1; f &lt; t.length; f++) { var i = t[f]; 0 !== o[i] &amp;&amp; (n = !1) } n &amp;&amp; (u.splice(r--, 1), e = l(l.s = t[0])) } return e } var n = {}, o = { 1: 0 }, u = []; function l(r) { if (n[r]) return n[r].exports; var t = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(t.exports, t, t.exports, l), t.l = !0, t.exports } l.m = e, l.c = n, l.d = function (e, r, t) { l.o(e, r) || Object.defineProperty(e, r, { enumerable: !0, get: t }) }, l.r = function (e) { &#34;undefined&#34; != typeof Symbol &amp;&amp; Symbol.toStringTag &amp;&amp; Object.defineProperty(e, Symbol.toStringTag, { value: &#34;Module&#34; }), Object.defineProperty(e, &#34;__esModule&#34;, { value: !0 }) }, l.t = function (e, r) { if (1 &amp; r &amp;&amp; (e = l(e)), 8 &amp; r) return e; if (4 &amp; r &amp;&amp; &#34;object&#34; == typeof e &amp;&amp; e &amp;&amp; e.__esModule) return e; var t = Object.create(null); if (l.r(t), Object.defineProperty(t, &#34;default&#34;, { enumerable: !0, value: e }), 2 &amp; r &amp;&amp; &#34;string&#34; != typeof e) for (var n in e) l.d(t, n, function (r) { return e[r] }.bind(null, n)); return t }, l.n = function (e) { var r = e &amp;&amp; e.__esModule ? function () { return e.default } : function () { return e }; return l.d(r, &#34;a&#34;, r), r }, l.o = function (e, r) { return Object.prototype.hasOwnProperty.call(e, r) }, l.p = &#34;./&#34;; var f = this.webpackJsonpdemo = this.webpackJsonpdemo || [], i = f.push.bind(f); f.push = r, f = f.slice(); for (var a = 0; a &lt; f.length; a++)r(f[a]); var p = i; t() }([])&lt;/script&gt; &lt;script src=&#34;/static/js/2.1902eda2.chunk.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;/static/js/main.cbf35db7.chunk.js&#34;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 发现 css 和 js 文件都是用绝对路径引用的，这是 webpack 打包一贯拥有的问题，将 /static 改成 ./static ，再运行，页面没有问题成功显示。
但是在写实际项目的时候手动修改相对路径，不但麻烦，而且容易引起其他问题。因此直接在项目的 package.json 配置文件进行修改，添加 &quot;homepage&quot;: &quot;.&quot;
// package.json { &#34;name&#34;: &#34;demo&#34;, &#34;version&#34;: &#34;0.1.0&#34;, &#34;private&#34;: true, &#34;homepage&#34;: &#34;.&#34;, // 添加这一行 &#34;dependencies&#34;: { &#34;@babel/core&#34;: &#34;7.12.3&#34;, ... 然后再执行 npm run build ，运行打包后的文件，没有任何问题。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/41.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">如何在 React 中引入 less？</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2021-01-04T00:00:00Z">2021-01-04</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要写如何在 React 中引入 less。因为 less 和 css 非常像，因此很容易学习。而且 less 仅对 css 语言增加了少许方便的扩展，这就是 less 如此易学的原因之一。
1.安装 less npm install less less-loader --save-dev 2.暴露 webpack 文件 利用 npx create-react-app 搭建的 React 项目，默认隐藏 webpack 配置文件，引入 less 需要修改 webpack 配置文件，因此我们需要执行命令暴露 webpack 配置文件。
这里需要注意，一旦暴露，无法回退。
npm run eject 如果这一步失败，执行下列命令：
git add . git commit -m &#34;init&#34; 然后再执行 npm run eject
注意：暴露 webpack 文件只能在 create-react-app 之初，一旦项目结构发生改变，再进行暴露操作就会失败。所以尽量在项目建立时就进行 npm run eject 操作。
3.修改 wenpack.config.js 配置 在合适的位置添加：
// 放在 // const sassRegex = /\.(scss|sass)$/; // const sassModuleRegex = /\.module\.(scss|sass)$/; // 后面 const lessRegex = /\.less$/; const lessModuleRegex = /\.module\.less$/; // 放在 oneof 数组下 { test: lessRegex, exclude: lessModuleRegex, use: getStyleLoaders( { importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, }, &#39;less-loader&#39; ), // Don&#39;t consider CSS imports dead code even if the // containing package claims to have no side effects. // Remove this when webpack adds a warning or an error for this. // See https://github.com/webpack/webpack/issues/6571 sideEffects: true, }, // Adds support for CSS Modules, but using SASS // using the extension .module.scss or .module.sass { test: lessModuleRegex, use: getStyleLoaders( { importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: true, getLocalIdent: getCSSModuleLocalIdent, }, &#39;less-loader&#39; ), }, 4.如何使用 less 新建一个 App.less 文件，然后在 App.js 中引入：
import &#39;./Map.less&#39; less 语法手册
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/39.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">React 学习笔记（三）</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-29T00:00:00Z">2020-12-29</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源于：https://react.docschina.org/docs/forms.html
一、表单 在 React 中，html 表单元素的工作方式和其他的 DOM 元素不太一样，因为表单内部通常会保持一些内部的 state，比如下面这个纯 html 表单只接受一个名称：
&lt;form&gt; &lt;label&gt; 名字： &lt;input type=&#34;text&#34; name=&#34;name&#34; /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; 这个表单具有默认的 html 表单行为，即在用户提交表单之后自动刷新页面。如果你在 React 中执行相同的代码，它仍然有效。
但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交，同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。
受控组件 在 html 中，表单元素比如&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;，这些表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。
我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。
例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：
class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;提交的名字：&#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 名字: &lt;input type=&#34;text&#34; value={this.state.value} onChange={this.handleChange} /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。
对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。
textarea 标签 在 html 中，&lt;textarea&gt; 元素通过其子元素定义其文本：
&lt;textarea&gt; 测试！ &lt;/textarea&gt; 而在 React 中，&lt;textarea&gt; 使用 value 属性代替。这样，可以使得使用 &lt;textarea&gt; 的表单和使用单行 input 的表单非常类似：
class EssayForm extends React.Component { constructor(props) { super(props); this.state = { value: &#39;请撰写一篇关于你喜欢的 DOM 元素的文章。&#39; }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;提交的文章：&#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 文章: &lt;textarea value={this.state.value} onChange={this.handleChange} /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。
select 标签 在 HTML 中，&lt;select&gt; 创建下拉列表标签。例如，如下 html 创建了水果相关的下拉列表：
&lt;select&gt; &lt;option value=&#34;grapefruit&#34;&gt;葡萄柚&lt;/option&gt; &lt;option value=&#34;lime&#34;&gt;酸橙&lt;/option&gt; &lt;option selected value=&#34;coconut&#34;&gt;椰子&lt;/option&gt; &lt;option value=&#34;mango&#34;&gt;芒果&lt;/option&gt; &lt;/select&gt; 请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：
class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;coconut&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;你喜欢的风味是：&#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 选择你喜欢的风味： &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;option value=&#34;grapefruit&#34;&gt;葡萄柚&lt;/option&gt; &lt;option value=&#34;lime&#34;&gt;酸橙&lt;/option&gt; &lt;option value=&#34;coconut&#34;&gt;椰子&lt;/option&gt; &lt;option value=&#34;mango&#34;&gt;芒果&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 总的来说，这使得 &lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; 和 &lt;select&gt; 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。
注意：你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：
&lt;select multiple={true} value={[&#39;B&#39;, &#39;C&#39;]}&gt; 文件 input 标签 在 HTML 中，&lt;input type=&quot;file&quot;&gt; 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。
&lt;input type=&#34;file&#34; /&gt; 因为它的 value 只读，所以它是 React 中的一个非受控组件。
处理多个输入 当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。
class Reservation extends React.Component { constructor(props) { super(props); this.state = { isGoing: true, numberOfGuests: 2 }; this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(event) { const target = event.target; const value = target.name === &#39;isGoing&#39; ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } render() { return ( &lt;form&gt; &lt;label&gt; 参与: &lt;input name=&#34;isGoing&#34; type=&#34;checkbox&#34; checked={this.state.isGoing} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; 来宾人数： &lt;input name=&#34;numberOfGuests&#34; type=&#34;number&#34; value={this.state.numberOfGuests} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;/form&gt; ); } } 这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值：
例如：
this.setState({ [name]: value }); 等同于 es5：
var partialState = {}; partialState[name] = value; this.setState(partialState); 另外，由于 setState() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。
受控输入空值 在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。
下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）
ReactDOM.render(&lt;input value=&#34;hi&#34; /&gt;, mountNode); setTimeout(function() { ReactDOM.render(&lt;input value={null} /&gt;, mountNode); }, 1000); 受控组件的替代品 有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件，这是实现输入表单的另一种方式。
成熟的解决方案 如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 Formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/38.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">2020 年度总结</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-25T00:00:00Z">2020-12-25</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		年度总结这个东西很有意思（我觉得），可以静下心来好好回顾一下这一年做了些什么事情，希望我能养成这个好习惯，多总结。
这个博客是我在年中搭建起来了，到现在也将近半年了，没怎么做过 seo 优化，也没怎么想过推广，就简简单单的写一些自己的东西。更大的原因是我的文笔太拙劣，不敢让人发现，哈哈哈。
大学四年过的还算充实，学到了自己感兴趣的东西，培养的业余兴趣爱好，旅游爬山等，但有名的大山目前只爬了嵩山（河南境内），因为在郑州读的大学。更远的山也没怎么去过，我给自己定个计划，在两年内爬一次泰山，因为工作太忙咯，不敢说短期内一定有时间。想体会一下&quot;会当凌绝顶，一览众山小&quot;的感觉。
但是吧，我的大学结束的有些虎头蛇尾的感觉，因为疫情的原因，学校禁止进入，一直到毕业前夕才允许分批次返校，很多同学都没有看到就草草结束大学生活。所以心心念念的毕业照也没有了，本来和朋友商量好一起拍一组有意思的毕业照，真的是今年最大的遗憾了。
离开校园，见面的机会真的就少了很多，基本都是打打电话，视频什么的，各奔东西，为生活开始忙碌。
2020 年，是让人印象深刻的一年，从一月份爆发的疫情开始，胆战心惊，一直到现在，依旧在全球蔓延，就在前两天看新闻，说英国要严重了，病毒变异，又封城了。真的希望这场疫情赶快过去。
为什么国外对这方面对管控好像没那么严？真的不理解，或许这就是&quot;向往自由&quot;吧。希望地球每个人都能重视起来，共同对抗病毒，早日结束这一场。
今年从郑州来到了杭州，换了一个新的环境，在工作中和大家有着共同的目标，学到了很多东西，但是也有一些遗憾，本来打算读两本书的的，下半年读了余果的《全栈工程师的自我修养》和《css 世界》，前段时间还写了读书笔记《对全栈的一些思考》，然后十一月份在某宝买了《javascript 高级程序设计》，结果因为时间不充足，最后也没读完。
在这里定一个小目标，2021 年一定要读完四本书。
在技术栈这一块，由 Vue 转向了 React，这里实在想吐槽一句。React 是 Facebook 开发的，Vue 是尤大大开发出来的，感觉写起来思维逻辑不太一样，Vue 的写法更偏向中国程序员的思维方式，React 更偏向外国人，因为我也不是外国人，所以也说不好是一种什么样的思维方式，只是感觉理解起来比 Vue 更难一些。但是因为公司的原因，开始着手 React 开发项目。
希望在新的一年继续延续下去，在学习更多的技术栈的同时，把自己要做的事情做的更好。
在杭州待了也有一段时间，这个城市看起来很年轻，很有朝气，可能因为年轻人的占比比较大吧。偶尔出去玩玩，能发现一些以前发现不了的东西，开阔一下自己的眼界。这里夸一下，西湖的风景确实不错，走在苏堤，吹吹风，整个人都放松了。平时压力大了，都会出来走走，但是好像一个人旅游好像缺了点乐趣。
这两天是圣诞节，虽说是洋节，但是自己也可以乐呵一下，在这里祝愿大家都能在 2020 年有一个好的结束，画上圆满的句号，迎接新的 2021 年。
抽出空闲的时间简单的写了一下总结，就好像跟看电影一样，又回顾了一遍剧情，又得到了不一样的感受。
你好，自己，明年见。
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/37.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">React －－万物皆可组件</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-21T00:00:00Z">2020-12-21</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、React 组件是什么？ 组件，从概念上类似于 javascript 函数，他接受任意入参（props），并返回作用于描述页面展示内容的 React 元素。
组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。
1.创建一个组件 // 函数组件 function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } // class 组件 class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } 2.渲染组件 class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } ReactDOM.render( &lt;Welcome /&gt;, document.getElementById(&#39;root&#39;) ); 3.组件 React 的基础原则有三条，分别是：
React 界面完全由数据驱动 React 中一切都是组件 props 是 React 组件之间通讯的基本方式 给组件输入一个参数，最终返回一个 React Element,React Element 就是在页面上展示的内容，相当于一个 DOM 节点
React 一大核心就是－－万物皆可组件
用户界面就是组件 组件可以嵌套包装组成复杂功能 组件可以用来实现副作用 一个复杂的界面可以分割很很多简单的组件，每个简单的组件又可以分割成很多小组件
有些类似于类和对象的概念
二、组件的划分 **无状态组件：**无状态组件 (Stateless Component) 是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。基本组成结构就是属性（props）加上一个渲染函数（render）。由于不涉及到状态的更新，所以这种组件的复用性也最强。例如在各 UI 库中开发的按钮、输入框、图标等等。
**有状态组件：**组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期 (lifecycle)，用以在不同的时刻触发状态的更新。在写业务逻辑时常用到，不同场景所用的状态和生命周期也会不同。
**容器组件：**为使组件的职责更加单一，耦合性进一步地降低，引入了容器组件 (Container Component) 的概念。重要负责对数据获取以及处理的逻辑。下文的设计模式也会提到。
高阶组件：“高阶组件（HoC）”也算是种组件设计模式。做为一个高阶组件，可以在原有组件的基础上，对其增加新的功能和行为。如打印日志，获取数据和校验数据等和展示无关的逻辑的时候，抽象出一个高阶组件，用以给基础的组件增加这些功能，减少公共的代码。
**Render Callback 组件：**组件模式是在组件中使用渲染回调的方式，将组件中的渲染逻辑委托给其子组件。也是种重用组件逻辑的方式，也叫 render props 模式。
三、设计原则 React 的组件其实是软件设计中的模块，其设计原则也需遵从通用的组件设计原则，简单说来，就是要减少组件之间的耦合性（Coupling)，让组件简单，这样才能让整体系统易于理解、易于维护。
即，设计原则：
接口小，props 数量少； 划分组件，充分利用组合（composition）； 把 state 往上层组件提取，让下层组件只需要实现为纯函数。 就像搭积木，复杂的应用和组件都是由简单的界面和组件组成的。划分组件也没有绝对的方法，选择在当下场景合适的方式划分，充分利用组合即可。实际编写代码也是逐步精进的过程，努力做到：
功能正常； 代码整洁； 高性能。 
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/36.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">javascript 进阶问题</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-19T00:00:00Z">2020-12-19</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		Github: https://github.com/lydiahallie/javascript-questions
相当不错的一个 Github 仓库，javascript questions ，作者每周都会发布一些有关 javascript 的题目，虽然不难但是考察细节，刷了一会，其实一些很简单的问题，结果因为细节思考不到位直接出错。
引用作者的话：我在我的 Instagram 上每天都会发布 JavaScript 的多选问题，并且同时也会在这个仓库中发布。
从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/35.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">React 学习笔记（二）</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-16T00:00:00Z">2020-12-16</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同
React 事件的命名采用小驼峰式（camelCase），而不是纯小写
使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串
一、事件处理 1.事件绑定 React 元素的事件处理和 DOM 元素类似，但是在语法上有些区别，比如：
传统的 html：用双引号包裹，后面必须跟参数
&lt;button onclick=&#34;myfun()&#34;&gt;点击&lt;/button&gt; React：用大括号包裹，后面不跟参数
&lt;button onclick={myfun}&gt;点击&lt;/button&gt; 一个完整的事件函数代码如下
class Demo extends React.Component { render() { // 事件函数 function myfun() { alert(&#39;helo,world&#39;) } return ( // 绑定事件 &lt;button onClick={this.myfun}&gt; Activate Lasers &lt;/button&gt; ) } } ReactDOM.render( &lt;Demo /&gt;, document.getElementById(&#39;root&#39;) ) 如果方法后面没有()，则需要为这个方法绑定 this
2.阻止默认行为 在 React 中还有一个不同的点，不能通过返回 fasle 阻止默认行为，React 提供了一个属性－－preventDefault，可以通过 preventDefault 阻止脚本执行
看一下传统的 html 和 React 的对比
&lt;a href=&#34;#&#34; onclick=&#34;alert(&#39;是否弹窗？&#39;);return false&#34;&gt; Click me &lt;/a&gt; 直接在写上 false 就可以阻止脚本执行
React 通过 preventDefault 属性阻止脚本执行：
function ActionLink() { function handleClick(e) { e.preventDefault(); console.log(&#39;The link was clicked.&#39;); } return ( &lt;a href=&#34;#&#34; onClick={handleClick}&gt; Click me &lt;/a&gt; ); } 二、条件渲染 在 React 中，可以创建不同的组件来封装各种你需要的行为，然后，根据应用不同的状态，你可以只渲染对应状态下的部分内容。
React 中的条件渲染和 javascript 中的一样，使用 if 运算符来表示元素当前的状态，然后让 React 根据他们来更新 UI。
使用 if..else 语句进行条件渲染 先写一个条件渲染的例子，定义了两个组件，然后通过判断组件 Greeting 中的变量 isLoggedIn 的真伪，让浏览器渲染组件 UserGreeting 或者 GuestGreeting。
// App.js import React, { Component } from &#39;react&#39; export default class App extends Component { render() { function UserGreeting(props) { return &lt;h3&gt;Welcome back!&lt;/h3&gt;; } function GuestGreeting(props) { return &lt;h3&gt;Please sign up.&lt;/h3&gt;; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return &lt;UserGreeting /&gt;; } return &lt;GuestGreeting /&gt;; } return ( &lt;div&gt; &lt;Greeting isLoggedIn={false} /&gt; &lt;/div&gt; ) } } 最后变量 isLoggedIn 定义了 false，因此，浏览器渲染 `GuestGreeting。
怎么阻止条件渲染？ 在有些情况下，我们希望能隐藏组件，即使他已经被其他组件渲染。我们可以通过 render 方法返回 null 让组件不渲染。
下面的示例中， 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染：
function WarningBanner(props) { if (!props.warn) { return null; } return ( &lt;div className=&#34;warning&#34;&gt; Warning! &lt;/div&gt; ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true}; this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(state =&gt; ({ showWarning: !state.showWarning })); } render() { return ( &lt;div&gt; &lt;WarningBanner warn={this.state.showWarning} /&gt; &lt;button onClick={this.handleToggleClick}&gt; {this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;} &lt;/button&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Page /&gt;, document.getElementById(&#39;root&#39;) ); 三、渲染列表 先看一段代码，我们使用 map() 函数让数组中的每一项变双倍，然后得到一个新的数组 doubled 并打印出来。
const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) =&gt; number * 2); console.log(doubled); // [2,4,6,8,10] 而在 React 中，把数组转换为元素列表的过程是相似的。
先通过 map() 方法遍历 numbers 数组，将数组中的每个元素变成 &lt;li&gt; 标签，最后将得到的数组赋值给 listItems 。
然后返回 {listItem} 。
// Map.js const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); ReactDOM.render( &lt;ul&gt;{listItems}&lt;/ul&gt;, document.getElementById(&#39;root&#39;) ); 运行之后浏览器出现 1-5 的无序列表
1.分离组件 上面就是一个基本的列表渲染的例子，但是数据写死了。接下来我们将数组重构成一个组件，以后再进行数组渲染时，可以轻松调用。
// Map.js export default class Map extends Component { render() { // 分离出组件 NumberList 作为转换数组的组件 function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入需要的数据 const numbers = [1, 2, 3, 4, 5, 6, 7]; return ( &lt;div&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/div&gt; ) } } 2.key 运行代码之后，页面会正常显示，但是控制台会报一个错误。Each child in a list should have a unique &quot;key&quot; prop.，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。
现在给每个列表元素分配一个 key：
function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 3.使用 id 作为 key key 帮助 React 识别了哪些元素被改变，比如删除和添加，所以应当给每个元素确定一个标识，也就是 key。
一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：
// Map.js export default class Map extends Component { render() { function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.id}&gt; // 赋值 key {number.text} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入数据 const numbers = [ {id: 1,text: 1}, {id: 2,text: 2}, {id: 3,text: 3}, {id: 4,text: 4}, {id: 5,text: 5} ]; return ( &lt;Fragment&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/Fragment&gt; ) } } 4.索引 index 可以作为 key 吗？ 当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：
const todoItems = todos.map((todo, index) =&gt; // 仅仅当没有确定 id 的时候使用索引 index 作为 key &lt;li key={index}&gt; {todo.text} &lt;/li&gt; ); 如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。
5.用 key 提取组件 比方说，如果你提取出一个 ListItem 组件，你应该把 key 保留在数组中的这个 &lt;ListItem /&gt; 元素上，而不是放在 ListItem 组件中的 &lt;li&gt; 元素上。
错误的使用方法：
function ListItem(props) { const value = props.value; return ( // 错误！你不需要在这里指定 key： &lt;li key={value.toString()}&gt; {value} &lt;/li&gt; ); } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！元素的 key 应该在这里指定： &lt;ListItem value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 正确的使用方法：
function ListItem(props) { // 正确！这里不需要指定 key： return &lt;li&gt;{props.value}&lt;/li&gt;; } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key={number.toString()} value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); React：一个好的经验法则是：在 map( ) 方法中的元素需要设置 key 属性。
6.key 只是在兄弟节点之间必须唯一 数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：
function Blog(props) { const sidebar = ( &lt;ul&gt; {props.posts.map((post) =&gt; &lt;li key={post.id}&gt; {post.title} &lt;/li&gt; )} &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key={post.id}&gt; &lt;h3&gt;{post.title}&lt;/h3&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; {sidebar} &lt;hr /&gt; {content} &lt;/div&gt; ); } const posts = [ {id: 1, title: &#39;Hello World&#39;, content: &#39;Welcome to learning React!&#39;}, {id: 2, title: &#39;Installation&#39;, content: &#39;You can install React from npm.&#39;} ]; ReactDOM.render( &lt;Blog posts={posts} /&gt;, document.getElementById(&#39;root&#39;) ); 7.vue 中渲染列表 Vue 中渲染列表使用的是特殊指令 v-for，其中也有 key 的相关用法
React 中采用的是 map() 方法遍历数组，然后渲染列表
title: React 学习笔记（二） date: 2020-12-16 13:15:00 updated: 2021-11-09 15:19:31 categories:
技术 tags: react React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同
React 事件的命名采用小驼峰式（camelCase），而不是纯小写
使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串
一、事件处理 1.事件绑定 React 元素的事件处理和 DOM 元素类似，但是在语法上有些区别，比如：
传统的 html：用双引号包裹，后面必须跟参数
&lt;button onclick=&#34;myfun()&#34;&gt;点击&lt;/button&gt; React：用大括号包裹，后面不跟参数
&lt;button onclick={myfun}&gt;点击&lt;/button&gt; 一个完整的事件函数代码如下
class Demo extends React.Component { render() { // 事件函数 function myfun() { alert(&#39;helo,world&#39;) } return ( // 绑定事件 &lt;button onClick={this.myfun}&gt; Activate Lasers &lt;/button&gt; ) } } ReactDOM.render( &lt;Demo /&gt;, document.getElementById(&#39;root&#39;) ) 如果方法后面没有()，则需要为这个方法绑定 this
2.阻止默认行为 在 React 中还有一个不同的点，不能通过返回 fasle 阻止默认行为，React 提供了一个属性－－preventDefault，可以通过 preventDefault 阻止脚本执行
看一下传统的 html 和 React 的对比
&lt;a href=&#34;#&#34; onclick=&#34;alert(&#39;是否弹窗？&#39;);return false&#34;&gt; Click me &lt;/a&gt; 直接在写上 false 就可以阻止脚本执行
React 通过 preventDefault 属性阻止脚本执行：
function ActionLink() { function handleClick(e) { e.preventDefault(); console.log(&#39;The link was clicked.&#39;); } return ( &lt;a href=&#34;#&#34; onClick={handleClick}&gt; Click me &lt;/a&gt; ); } 二、条件渲染 在 React 中，可以创建不同的组件来封装各种你需要的行为，然后，根据应用不同的状态，你可以只渲染对应状态下的部分内容。
React 中的条件渲染和 javascript 中的一样，使用 if 运算符来表示元素当前的状态，然后让 React 根据他们来更新 UI。
使用 if..else 语句进行条件渲染 先写一个条件渲染的例子，定义了两个组件，然后通过判断组件 Greeting 中的变量 isLoggedIn 的真伪，让浏览器渲染组件 UserGreeting 或者 GuestGreeting。
// App.js import React, { Component } from &#39;react&#39; export default class App extends Component { render() { function UserGreeting(props) { return &lt;h3&gt;Welcome back!&lt;/h3&gt;; } function GuestGreeting(props) { return &lt;h3&gt;Please sign up.&lt;/h3&gt;; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return &lt;UserGreeting /&gt;; } return &lt;GuestGreeting /&gt;; } return ( &lt;div&gt; &lt;Greeting isLoggedIn={false} /&gt; &lt;/div&gt; ) } } 最后变量 isLoggedIn 定义了 false，因此，浏览器渲染 `GuestGreeting。
怎么阻止条件渲染？ 在有些情况下，我们希望能隐藏组件，即使他已经被其他组件渲染。我们可以通过 render 方法返回 null 让组件不渲染。
下面的示例中， 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染：
function WarningBanner(props) { if (!props.warn) { return null; } return ( &lt;div className=&#34;warning&#34;&gt; Warning! &lt;/div&gt; ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true}; this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(state =&gt; ({ showWarning: !state.showWarning })); } render() { return ( &lt;div&gt; &lt;WarningBanner warn={this.state.showWarning} /&gt; &lt;button onClick={this.handleToggleClick}&gt; {this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;} &lt;/button&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Page /&gt;, document.getElementById(&#39;root&#39;) ); 三、渲染列表 先看一段代码，我们使用 map() 函数让数组中的每一项变双倍，然后得到一个新的数组 doubled 并打印出来。
const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) =&gt; number * 2); console.log(doubled); // [2,4,6,8,10] 而在 React 中，把数组转换为元素列表的过程是相似的。
先通过 map() 方法遍历 numbers 数组，将数组中的每个元素变成 &lt;li&gt; 标签，最后将得到的数组赋值给 listItems 。
然后返回 {listItem} 。
// Map.js const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); ReactDOM.render( &lt;ul&gt;{listItems}&lt;/ul&gt;, document.getElementById(&#39;root&#39;) ); 运行之后浏览器出现 1-5 的无序列表
1.分离组件 上面就是一个基本的列表渲染的例子，但是数据写死了。接下来我们将数组重构成一个组件，以后再进行数组渲染时，可以轻松调用。
// Map.js export default class Map extends Component { render() { // 分离出组件 NumberList 作为转换数组的组件 function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入需要的数据 const numbers = [1, 2, 3, 4, 5, 6, 7]; return ( &lt;div&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/div&gt; ) } } 2.key 运行代码之后，页面会正常显示，但是控制台会报一个错误。Each child in a list should have a unique &quot;key&quot; prop.，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。
现在给每个列表元素分配一个 key：
function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 3.使用 id 作为 key key 帮助 React 识别了哪些元素被改变，比如删除和添加，所以应当给每个元素确定一个标识，也就是 key。
一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：
// Map.js export default class Map extends Component { render() { function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.id}&gt; // 赋值 key {number.text} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入数据 const numbers = [ {id: 1,text: 1}, {id: 2,text: 2}, {id: 3,text: 3}, {id: 4,text: 4}, {id: 5,text: 5} ]; return ( &lt;Fragment&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/Fragment&gt; ) } } 4.索引 index 可以作为 key 吗？ 当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：
const todoItems = todos.map((todo, index) =&gt; // 仅仅当没有确定 id 的时候使用索引 index 作为 key &lt;li key={index}&gt; {todo.text} &lt;/li&gt; ); 如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。
5.用 key 提取组件 比方说，如果你提取出一个 ListItem 组件，你应该把 key 保留在数组中的这个 &lt;ListItem /&gt; 元素上，而不是放在 ListItem 组件中的 &lt;li&gt; 元素上。
错误的使用方法：
function ListItem(props) { const value = props.value; return ( // 错误！你不需要在这里指定 key： &lt;li key={value.toString()}&gt; {value} &lt;/li&gt; ); } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！元素的 key 应该在这里指定： &lt;ListItem value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 正确的使用方法：
function ListItem(props) { // 正确！这里不需要指定 key： return &lt;li&gt;{props.value}&lt;/li&gt;; } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key={number.toString()} value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); React：一个好的经验法则是：在 map( ) 方法中的元素需要设置 key 属性。
6.key 只是在兄弟节点之间必须唯一 数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：
function Blog(props) { const sidebar = ( &lt;ul&gt; {props.posts.map((post) =&gt; &lt;li key={post.id}&gt; {post.title} &lt;/li&gt; )} &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key={post.id}&gt; &lt;h3&gt;{post.title}&lt;/h3&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; {sidebar} &lt;hr /&gt; {content} &lt;/div&gt; ); } const posts = [ {id: 1, title: &#39;Hello World&#39;, content: &#39;Welcome to learning React!&#39;}, {id: 2, title: &#39;Installation&#39;, content: &#39;You can install React from npm.&#39;} ]; ReactDOM.render( &lt;Blog posts={posts} /&gt;, document.getElementById(&#39;root&#39;) ); 7.vue 中渲染列表 Vue 中渲染列表使用的是特殊指令 v-for，其中也有 key 的相关用法
React 中采用的是 map() 方法遍历数组，然后渲染列表
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/34.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">吐槽－－控制好自己的情绪</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-13T00:00:00Z">2020-12-13</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘于一些小事，本想发在朋友圈里，但是熟人挺多，不方便发，就在博客里吐槽一下
一个正常的人际交往应该是互相传递出好的情绪，开心的事情，这样不但有利于两个人之间的交往，而且对个人对身心健康也是有帮助的
正面的情绪绝对有助于自己的身体和心理健康，反观整体郁郁寡欢，跟别人说自己多不顺，和别人吵架，不好的情绪就传达给另一个人了
并不是说不能找人倾述自己生活的不痛快和不开心，但是作为一个成年人了，应该要把握好那个感觉，不要真把别人当垃圾桶了，什么都往里倒，宣泄
情侣之间亦是如此，再好的关系，如果每天散发着各种压抑的情绪，爆发是迟早的事
家家有本难念的经
每个人都会有自己的烦心事，都能理解，毕竟生活确实很苦闷，但要学会自己调节自己。
我也会经常烦闷，但是我选择做一些爱好的事情来排遣掉自己的不好的情绪，并不会将这些传递给别人，所以我也算过的很开心吧
成年人，不就是要学会自己克制自己的缺点，希望每个人都能生活的很愉快！
	</div>
</article>
<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/blog/33.html/" style="color: #000000; text-decoration: none;" onmouseover="this.style.color='#4d4e4e';" onmouseout="this.style.color='#000000';">React 中的占位符 Fragment</a>
		</h2>
		<div class="list__meta meta">
<div class="meta__item-datetime meta__item">
	<time class="meta__text" datetime="2020-12-12T00:00:00Z">2020-12-12</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 React 项目中，render 方法只能有一个根元素，一般都是 &lt;div&gt; &lt;div/&gt; ，然后在里面写上我们的组件，渲染到浏览器一看，除了我们想要显示的组件，外面还套着一层 div，如果在写项目的时候，套了很多曾组件，那么每一层都会多出来一个父级元素 div，不美观，而且在调整样式的时候会有些麻烦
因此，React 提供了一个占位符 Fragment，写法是：
// index.js import React, { Component,Fragment } from &#39;react&#39; export default class index extends Component { render() { return ( &lt;Fragment&gt; &lt;h2&gt;hello,wolrd&lt;/h2&gt; &lt;/Fragment&gt; ) } } 在引入 React 的时候，增加一个属性 Fragment，然后 render()方法下唯一的根元素我们用 &lt;Fragment&gt; &lt;/Fragment&gt; 来代替，这时候再看浏览器，就不会显示多余的标签了，直接显示 &lt;h2&gt;标签
	</div>
</article>

</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/blog/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/27</span>
	<a class="pagination__item pagination__item--next btn" href="/blog/page/25/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		<div class="footer__copyright">
			&copy; 2024 子舒的博客, 
			使用 hugo 构建
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>

</body>
</html>