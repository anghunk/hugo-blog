<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.136.5">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/blog/247.html/" />
<link rel="canonical" href="https://zishu.me/blog/247.html/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "blog",
"name" : "Lobechat 使用 Webdav 同步数据的研究",
"headline" : "Lobechat 使用 Webdav 同步数据的研究",
"description" : "Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。\n今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。\n因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费，因此我想到了利用 Webdav 技术自己解决同步问题。\nWebdav\n大多数网盘都支持通过 Webdav 技术进行同步，网盘提供一套账号密码以及服务器地址，在前端调用，可以实现增删改查。\n油猴管理器（Tampermonkey）\n油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。\n所以我打算使用 Tampermonkey 来构建这个脚本文件。\nLobechat 数据\n我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。\n然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。\n操作数据库\n于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据。\nconst dbName = \u0026#34;LOBE_CHAT_DB\u0026#34;; const storeNames = [\u0026#34;messages\u0026#34;, \u0026#34;sessionGroups\u0026#34;, \u0026#34;sessions\u0026#34;, \u0026#34;topics\u0026#34;, \u0026#34;users\u0026#34;]; let request = indexedDB.open(dbName); request.onsuccess = (event) =\u0026gt; { const db = event.target.result; let state = { messages: [], sessionGroups: [], sessions: [], topics: [], users: [], }; let pendingStores = 0; storeNames.forEach((storeName) =\u0026gt; { if (db.objectStoreNames.contains(storeName)) { pendingStores\u002b\u002b; const transaction = db.transaction([storeName], \u0026#34;readonly\u0026#34;); const objectStore = transaction.objectStore(storeName); const allRecords = objectStore.getAll(); allRecords.onsuccess = (event) =\u0026gt; { const result = event.target.result; state[storeName] = result; pendingStores--; if (pendingStores === 0) { \/\/ 整个数据库的数据都可以导出 this.exportData = JSON.stringify({ exportType: \u0026#34;all\u0026#34;, state: state, version: 7, }); } }; } }); }; 既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。\n大致原型如下：\n只要输入账号密码后，可以随时保存本地数据到云端，下载数据到本地，同步就很方便。\n最终我把它做成了油猴脚本发布到 Greasyfork，可供大家直接使用，代码也已开源\n安装：https:\/\/greasyfork.org\/scripts\/516358 Github：https:\/\/github.com\/dlzmoe\/UserScript ",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2024",
"datePublished": "2024-11-12 00:00:00 \u002b0000 UTC",
"dateModified" : "2024-11-12 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/blog\/247.html\/",
"keywords" : [ "Lobechat","Webdav", ]
}
</script><title>Lobechat 使用 Webdav 同步数据的研究 - 子舒的博客</title>
<meta property="og:title" content="Lobechat 使用 Webdav 同步数据的研究" />
<meta property="og:type" content="article" />
<meta property="og:description" content="Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。
今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。
因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费，因此我想到了利用 Webdav 技术自己解决同步问题。
Webdav
大多数网盘都支持通过 Webdav 技术进行同步，网盘提供一套账号密码以及服务器地址，在前端调用，可以实现增删改查。
油猴管理器（Tampermonkey）
油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。
所以我打算使用 Tampermonkey 来构建这个脚本文件。
Lobechat 数据
我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。
然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。
操作数据库
于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据。
const dbName = &#34;LOBE_CHAT_DB&#34;; const storeNames = [&#34;messages&#34;, &#34;sessionGroups&#34;, &#34;sessions&#34;, &#34;topics&#34;, &#34;users&#34;]; let request = indexedDB.open(dbName); request.onsuccess = (event) =&gt; { const db = event.target.result; let state = { messages: [], sessionGroups: [], sessions: [], topics: [], users: [], }; let pendingStores = 0; storeNames.forEach((storeName) =&gt; { if (db.objectStoreNames.contains(storeName)) { pendingStores&#43;&#43;; const transaction = db.transaction([storeName], &#34;readonly&#34;); const objectStore = transaction.objectStore(storeName); const allRecords = objectStore.getAll(); allRecords.onsuccess = (event) =&gt; { const result = event.target.result; state[storeName] = result; pendingStores--; if (pendingStores === 0) { // 整个数据库的数据都可以导出 this.exportData = JSON.stringify({ exportType: &#34;all&#34;, state: state, version: 7, }); } }; } }); }; 既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。
大致原型如下：
只要输入账号密码后，可以随时保存本地数据到云端，下载数据到本地，同步就很方便。
最终我把它做成了油猴脚本发布到 Greasyfork，可供大家直接使用，代码也已开源
安装：https://greasyfork.org/scripts/516358 Github：https://github.com/dlzmoe/UserScript " />
<meta name="description" content="Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。
今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。
因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费，因此我想到了利用 Webdav 技术自己解决同步问题。
Webdav
大多数网盘都支持通过 Webdav 技术进行同步，网盘提供一套账号密码以及服务器地址，在前端调用，可以实现增删改查。
油猴管理器（Tampermonkey）
油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。
所以我打算使用 Tampermonkey 来构建这个脚本文件。
Lobechat 数据
我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。
然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。
操作数据库
于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据。
const dbName = &#34;LOBE_CHAT_DB&#34;; const storeNames = [&#34;messages&#34;, &#34;sessionGroups&#34;, &#34;sessions&#34;, &#34;topics&#34;, &#34;users&#34;]; let request = indexedDB.open(dbName); request.onsuccess = (event) =&gt; { const db = event.target.result; let state = { messages: [], sessionGroups: [], sessions: [], topics: [], users: [], }; let pendingStores = 0; storeNames.forEach((storeName) =&gt; { if (db.objectStoreNames.contains(storeName)) { pendingStores&#43;&#43;; const transaction = db.transaction([storeName], &#34;readonly&#34;); const objectStore = transaction.objectStore(storeName); const allRecords = objectStore.getAll(); allRecords.onsuccess = (event) =&gt; { const result = event.target.result; state[storeName] = result; pendingStores--; if (pendingStores === 0) { // 整个数据库的数据都可以导出 this.exportData = JSON.stringify({ exportType: &#34;all&#34;, state: state, version: 7, }); } }; } }); }; 既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。
大致原型如下：
只要输入账号密码后，可以随时保存本地数据到云端，下载数据到本地，同步就很方便。
最终我把它做成了油猴脚本发布到 Greasyfork，可供大家直接使用，代码也已开源
安装：https://greasyfork.org/scripts/516358 Github：https://github.com/dlzmoe/UserScript " />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />

<link href="https://fonts.googleapis.com" rel="preconnect">
<link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>

<body>
  <nav class="headnav">
  <a href="/" class="logo">ZISHU.ME</a>
  <ul id="menu">
    
    <li><a href="/tags/">标签</a></li>
    
    <li><a href="/blog/">博客</a></li>
    
    <li><a href="/categories/weekly/">周刊</a></li>
    
    <li><a href="/message/">留言</a></li>
    
    <li><a href="/links">友链</a></li>
    
    <li><a href="/search">搜索</a></li>
    
    <li><a href="/index.xml" target="_blank">RSS</a></li>
  </ul>
</nav>
  <section>
    
    <div class="body-title">Lobechat 使用 Webdav 同步数据的研究</div>

    
    <div class="post-meta">
      <time> 2024-11-12</time>
      
      
      <span class="namenode">分类：
        <a href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
      </span>
      
      

      <span class="tag-node">
        
        标签：
        
        <a href="/tags/lobechat">#Lobechat</a>
        
        <a href="/tags/webdav">#Webdav</a>
        
        
      </span>

    </div>
    

    
    <div class="toc">
      <nav id="TableOfContents"></nav>
    </div>
    

    <article class="post-content">
      
      <p>Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。</p>
<p>今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。</p>
<p>因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费，因此我想到了利用 Webdav 技术自己解决同步问题。</p>
<p><strong>Webdav</strong></p>
<p>大多数网盘都支持通过 Webdav 技术进行同步，网盘提供一套账号密码以及服务器地址，在前端调用，可以实现增删改查。</p>
<p><strong>油猴管理器（Tampermonkey）</strong></p>
<p>油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。</p>
<p>所以我打算使用 Tampermonkey 来构建这个脚本文件。</p>
<p><strong>Lobechat 数据</strong></p>
<p>我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。</p>
<p><img src="https://imgurl.zishu.me/2024/11/1731404378265.webp" alt="1731404378265"></p>
<p>然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。</p>
<p><strong>操作数据库</strong></p>
<p>于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">dbName</span> <span class="o">=</span> <span class="s2">&#34;LOBE_CHAT_DB&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">storeNames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;messages&#34;</span><span class="p">,</span> <span class="s2">&#34;sessionGroups&#34;</span><span class="p">,</span> <span class="s2">&#34;sessions&#34;</span><span class="p">,</span> <span class="s2">&#34;topics&#34;</span><span class="p">,</span> <span class="s2">&#34;users&#34;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">indexedDB</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">dbName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">messages</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sessionGroups</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sessions</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">topics</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">users</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">pendingStores</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">storeNames</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">storeName</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">objectStoreNames</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">storeName</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">pendingStores</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">transaction</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="nx">storeName</span><span class="p">],</span> <span class="s2">&#34;readonly&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">transaction</span><span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="nx">storeName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">allRecords</span> <span class="o">=</span> <span class="nx">objectStore</span><span class="p">.</span><span class="nx">getAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">allRecords</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">state</span><span class="p">[</span><span class="nx">storeName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pendingStores</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">pendingStores</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 整个数据库的数据都可以导出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">this</span><span class="p">.</span><span class="nx">exportData</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">            <span class="nx">exportType</span><span class="o">:</span> <span class="s2">&#34;all&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">state</span><span class="o">:</span> <span class="nx">state</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">version</span><span class="o">:</span> <span class="mi">7</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。</p>
<p>大致原型如下：</p>
<p><img src="https://imgurl.zishu.me/2024/11/1731404855162.webp" alt="1731404855162"></p>
<p>只要输入账号密码后，可以随时保存本地数据到云端，下载数据到本地，同步就很方便。</p>
<p>最终我把它做成了油猴脚本发布到 Greasyfork，可供大家直接使用，代码也已开源</p>
<ul>
<li>安装：<a href="https://greasyfork.org/scripts/516358">https://greasyfork.org/scripts/516358</a></li>
<li>Github：<a href="https://github.com/dlzmoe/UserScript">https://github.com/dlzmoe/UserScript</a></li>
</ul>

      <div class="weekly-pagination"></div>
    </article>

    
    <div class="comments">
  <div class="giscus"></div>
</div>
<script 
  src="https://giscus.app/client.js" 
  data-repo="dlzmoe/blog" 
  data-repo-id="R_kgDOJkJvtw"
  data-category="Announcements" 
  data-category-id="DIC_kwDOJkJvt84CX9d6" 
  data-mapping="url" 
  data-strict="0"
  data-reactions-enabled="1" 
  data-emit-metadata="1" 
  data-input-position="top" 
  data-theme="light_protanopia"
  data-lang="zh-CN" 
  data-loading="lazy" 
  crossorigin="anonymous" 
  async>
</script>

    
    
  </section>
  <footer class="footer">
  <p>© 2020 - 2024 Powered by
    <a href="https://github.com/dlzmoe" target="_blank">Github</a>
    / <a href="/index.xml" target="_blank">RSS</a>
  </p>
</footer>

<script src="/js/main.js"></script>

</body>

</html>