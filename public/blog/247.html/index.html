<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.143.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/blog/247.html/" />
<link rel="canonical" href="https://zishu.me/blog/247.html/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "blog",
"name" : "Lobechat 使用 Webdav 同步数据的研究",
"headline" : "Lobechat 使用 Webdav 同步数据的研究",
"description" : "1. 前言 Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。\n今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费。\n官方之前有通过 WebRTC 同步数据的方案，但在某个版本被废弃了，其实我也能理解，WebRTC 同步方案太过麻烦，且具有不稳定性，必须保证同时两台设备在线，而且实现原理让我感觉有一丝不安全性。\n对 WebRTC 概念感兴趣的话可以看下官方的一篇文章：\nhttps:\/\/github.com\/lobehub\/lobe-chat\/discussions\/368\n其实除了正式版之外，还有服务器自建数据库等同步方法，但都需要一定的成本和技术壁垒。\n因此我在社区版的基础上构思了一个脚本，通过 Webdav 技术实现对话记录、设置等同步。此方案成本基本为零，坚果云免费额度都绰绰有余。\n2. Webdav \/ Tampermonkey 但研究开始之前，有两个概念需要先了解一下。\nWebdav 大多数网盘都支持通过 Webdav 技术进行同步，网盘会提供一套账号密码以及服务器地址，在前端调用 API，能够实现增删改查等操作。\n油猴管理器（Tampermonkey） 油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。\n3. 那么如何获取 Lobechat 数据呢？ 我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。\n然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。\n于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据，下面是我的一些思路。\n先声明我想要拿到的数据，这些都在上面的截图中存在。\nconst dbName = \u0026#34;LOBE_CHAT_DB\u0026#34;; const storeNames = [\u0026#34;messages\u0026#34;, \u0026#34;sessionGroups\u0026#34;, \u0026#34;sessions\u0026#34;, \u0026#34;topics\u0026#34;, \u0026#34;users\u0026#34;]; let request = indexedDB.open(dbName); request.onsuccess = (event) =\u0026gt; { const db = event.target.result; let state = { messages: [], sessionGroups: [], sessions: [], topics: [], users: [], }; let pendingStores = 0; storeNames.forEach((storeName) =\u0026gt; { if (db.objectStoreNames.contains(storeName)) { pendingStores\u002b\u002b; const transaction = db.transaction([storeName], \u0026#34;readonly\u0026#34;); const objectStore = transaction.objectStore(storeName); const allRecords = objectStore.getAll(); allRecords.onsuccess = (event) =\u0026gt; { const result = event.target.result; state[storeName] = result; pendingStores--; if (pendingStores === 0) { \/* * 整个数据库的数据都可以导出 * 在此回调执行操作 *\/ } }; } }); }; 4. 操作流程原型 既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思了一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。\n大致原型如下：\n点击同步到云端，会通过 Webdav API 在网盘创建一个指定的文件夹 lobechat-webdav-backup(我自己随意命名的)，在本地程序中生成一个 json 文件，IndexedDB 数据会被放入该文件中，然后通过 Webdav API 传输到网盘中。\n点击下载到本地，会先通过 Webdav API 获取lobechat-webdav-backup下的 json 文件内容，利用 IndexedDB API 覆盖在浏览器 IndexedDB 数据库中。\n在实际体验中，可以随时保存本地数据到云端，下载数据到本地，同步就很方便，使用了三天，没有出现同步出错的问题，脚本很稳定。\n最终我把该脚本发布到 Greasyfork，可供大家直接使用，代码也已开源。\n安装：https:\/\/greasyfork.org\/scripts\/516358 Github：https:\/\/github.com\/dlzmoe\/UserScript ",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2024",
"datePublished": "2024-11-12 00:00:00 \u002b0000 UTC",
"dateModified" : "2024-11-12 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/blog\/247.html\/",
"keywords" : [ "Lobechat","Webdav", ]
}
</script><title>Lobechat 使用 Webdav 同步数据的研究 - 子舒的博客</title>
<meta property="og:title" content="Lobechat 使用 Webdav 同步数据的研究" />
<meta property="og:type" content="article" />
<meta property="og:description" content="1. 前言 Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。
今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费。
官方之前有通过 WebRTC 同步数据的方案，但在某个版本被废弃了，其实我也能理解，WebRTC 同步方案太过麻烦，且具有不稳定性，必须保证同时两台设备在线，而且实现原理让我感觉有一丝不安全性。
对 WebRTC 概念感兴趣的话可以看下官方的一篇文章：
https://github.com/lobehub/lobe-chat/discussions/368
其实除了正式版之外，还有服务器自建数据库等同步方法，但都需要一定的成本和技术壁垒。
因此我在社区版的基础上构思了一个脚本，通过 Webdav 技术实现对话记录、设置等同步。此方案成本基本为零，坚果云免费额度都绰绰有余。
2. Webdav / Tampermonkey 但研究开始之前，有两个概念需要先了解一下。
Webdav 大多数网盘都支持通过 Webdav 技术进行同步，网盘会提供一套账号密码以及服务器地址，在前端调用 API，能够实现增删改查等操作。
油猴管理器（Tampermonkey） 油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。
3. 那么如何获取 Lobechat 数据呢？ 我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。
然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。
于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据，下面是我的一些思路。
先声明我想要拿到的数据，这些都在上面的截图中存在。
const dbName = &#34;LOBE_CHAT_DB&#34;; const storeNames = [&#34;messages&#34;, &#34;sessionGroups&#34;, &#34;sessions&#34;, &#34;topics&#34;, &#34;users&#34;]; let request = indexedDB.open(dbName); request.onsuccess = (event) =&gt; { const db = event.target.result; let state = { messages: [], sessionGroups: [], sessions: [], topics: [], users: [], }; let pendingStores = 0; storeNames.forEach((storeName) =&gt; { if (db.objectStoreNames.contains(storeName)) { pendingStores&#43;&#43;; const transaction = db.transaction([storeName], &#34;readonly&#34;); const objectStore = transaction.objectStore(storeName); const allRecords = objectStore.getAll(); allRecords.onsuccess = (event) =&gt; { const result = event.target.result; state[storeName] = result; pendingStores--; if (pendingStores === 0) { /* * 整个数据库的数据都可以导出 * 在此回调执行操作 */ } }; } }); }; 4. 操作流程原型 既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思了一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。
大致原型如下：
点击同步到云端，会通过 Webdav API 在网盘创建一个指定的文件夹 lobechat-webdav-backup(我自己随意命名的)，在本地程序中生成一个 json 文件，IndexedDB 数据会被放入该文件中，然后通过 Webdav API 传输到网盘中。
点击下载到本地，会先通过 Webdav API 获取lobechat-webdav-backup下的 json 文件内容，利用 IndexedDB API 覆盖在浏览器 IndexedDB 数据库中。
在实际体验中，可以随时保存本地数据到云端，下载数据到本地，同步就很方便，使用了三天，没有出现同步出错的问题，脚本很稳定。
最终我把该脚本发布到 Greasyfork，可供大家直接使用，代码也已开源。
安装：https://greasyfork.org/scripts/516358 Github：https://github.com/dlzmoe/UserScript " />
<meta name="description" content="1. 前言 Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。
今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费。
官方之前有通过 WebRTC 同步数据的方案，但在某个版本被废弃了，其实我也能理解，WebRTC 同步方案太过麻烦，且具有不稳定性，必须保证同时两台设备在线，而且实现原理让我感觉有一丝不安全性。
对 WebRTC 概念感兴趣的话可以看下官方的一篇文章：
https://github.com/lobehub/lobe-chat/discussions/368
其实除了正式版之外，还有服务器自建数据库等同步方法，但都需要一定的成本和技术壁垒。
因此我在社区版的基础上构思了一个脚本，通过 Webdav 技术实现对话记录、设置等同步。此方案成本基本为零，坚果云免费额度都绰绰有余。
2. Webdav / Tampermonkey 但研究开始之前，有两个概念需要先了解一下。
Webdav 大多数网盘都支持通过 Webdav 技术进行同步，网盘会提供一套账号密码以及服务器地址，在前端调用 API，能够实现增删改查等操作。
油猴管理器（Tampermonkey） 油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。
3. 那么如何获取 Lobechat 数据呢？ 我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。
然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。
于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据，下面是我的一些思路。
先声明我想要拿到的数据，这些都在上面的截图中存在。
const dbName = &#34;LOBE_CHAT_DB&#34;; const storeNames = [&#34;messages&#34;, &#34;sessionGroups&#34;, &#34;sessions&#34;, &#34;topics&#34;, &#34;users&#34;]; let request = indexedDB.open(dbName); request.onsuccess = (event) =&gt; { const db = event.target.result; let state = { messages: [], sessionGroups: [], sessions: [], topics: [], users: [], }; let pendingStores = 0; storeNames.forEach((storeName) =&gt; { if (db.objectStoreNames.contains(storeName)) { pendingStores&#43;&#43;; const transaction = db.transaction([storeName], &#34;readonly&#34;); const objectStore = transaction.objectStore(storeName); const allRecords = objectStore.getAll(); allRecords.onsuccess = (event) =&gt; { const result = event.target.result; state[storeName] = result; pendingStores--; if (pendingStores === 0) { /* * 整个数据库的数据都可以导出 * 在此回调执行操作 */ } }; } }); }; 4. 操作流程原型 既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思了一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。
大致原型如下：
点击同步到云端，会通过 Webdav API 在网盘创建一个指定的文件夹 lobechat-webdav-backup(我自己随意命名的)，在本地程序中生成一个 json 文件，IndexedDB 数据会被放入该文件中，然后通过 Webdav API 传输到网盘中。
点击下载到本地，会先通过 Webdav API 获取lobechat-webdav-backup下的 json 文件内容，利用 IndexedDB API 覆盖在浏览器 IndexedDB 数据库中。
在实际体验中，可以随时保存本地数据到云端，下载数据到本地，同步就很方便，使用了三天，没有出现同步出错的问题，脚本很稳定。
最终我把该脚本发布到 Greasyfork，可供大家直接使用，代码也已开源。
安装：https://greasyfork.org/scripts/516358 Github：https://github.com/dlzmoe/UserScript " />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />

<link href="https://fonts.googleapis.com" rel="preconnect">
<link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="/css/primer.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>

<body>
  <header class="header">
  <div class="l-wrap">
    <a href="/" class="logo">子舒（zishu.me）</a>
    <ul class="nav">
      
      <li>
        <a href="/blog/">
          <button class="btn" type="button">
            文章
          </button>
        </a>
      </li>
      
      <li>
        <a href="/categories/weekly/">
          <button class="btn" type="button">
            周刊
          </button>
        </a>
      </li>
      
      <li>
        <a href="/message/">
          <button class="btn" type="button">
            留言
          </button>
        </a>
      </li>
      
      <li><a href="/index.xml" target="_blank">
        <button class="btn" type="button">RSS</button>
      </a></li>
    </ul>
  </div>
</header>
  <section>
    <div class="l-wrap">
      <h1 class="body-title">Lobechat 使用 Webdav 同步数据的研究</h1>

      
      <div class="post-meta">
        <time> 2024/11/12</time>
      </div>
      


      
      <div class="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#1-前言">1. 前言</a></li>
    <li><a href="#2-webdav--tampermonkey">2. Webdav / Tampermonkey</a></li>
    <li><a href="#3-那么如何获取-lobechat-数据呢">3. 那么如何获取 Lobechat 数据呢？</a></li>
    <li><a href="#4-操作流程原型">4. 操作流程原型</a></li>
  </ul>
</nav>
      </div>
      

      <article class="post-content">
        
        <h2 id="1-前言">1. 前言</h2>
<p>Lobechat 就不做过多介绍了，一个开源、现代设计的人工智能聊天框架。</p>
<p>今天就来聊聊同步的问题，Lobechat 分为社区版和正式版，正式版需要付费订阅套餐，支持全局云同步，但是最便宜的套餐都要 4.9 刀，这让我 API 用户感觉有点难以接受。因为我需要的功能社区版都已经满足了，并不打算单独对云同步付费。</p>
<p>官方之前有通过 WebRTC 同步数据的方案，但在某个版本被废弃了，其实我也能理解，WebRTC 同步方案太过麻烦，且具有不稳定性，必须保证同时两台设备在线，而且实现原理让我感觉有一丝不安全性。</p>
<p>对 WebRTC 概念感兴趣的话可以看下官方的一篇文章：<br>
<a href="https://github.com/lobehub/lobe-chat/discussions/368">https://github.com/lobehub/lobe-chat/discussions/368</a></p>
<hr>
<p>其实除了正式版之外，还有服务器自建数据库等同步方法，但都需要一定的成本和技术壁垒。</p>
<p>因此我在社区版的基础上构思了一个脚本，通过 Webdav 技术实现对话记录、设置等同步。此方案成本基本为零，坚果云免费额度都绰绰有余。</p>
<h2 id="2-webdav--tampermonkey">2. Webdav / Tampermonkey</h2>
<p>但研究开始之前，有两个概念需要先了解一下。</p>
<ol>
<li>Webdav</li>
</ol>
<p>大多数网盘都支持通过 Webdav 技术进行同步，网盘会提供一套账号密码以及服务器地址，在前端调用 API，能够实现增删改查等操作。</p>
<ol start="2">
<li>油猴管理器（Tampermonkey）</li>
</ol>
<p>油猴管理器（Tampermonkey）无疑是浏览器插件的伟大创作之一，可以对网页注入 js 脚本来实现一些功能。</p>
<h2 id="3-那么如何获取-lobechat-数据呢">3. 那么如何获取 Lobechat 数据呢？</h2>
<p>我研究过 Lobechat 源码，它数据都存放在本地的 IndexedDB 数据库中，这是浏览器的一个存储机制，可以存放大量的数据，显示则是以数据库的格式。</p>
<p><img src="https://imgurl.zishu.me/2024/11/1731404378265.webp" alt="1731404378265"></p>
<p>然后我先手动导出一份 json 格式的全局数据（社区版只支持手动导入导出文件），拿这份文件跟 IndexedDB 数据库 做对比，发现字段基本保持一致，数据格式也不用转，全部都在其中。</p>
<p>于是我翻阅了一下官方文档，有可以利用的 API，操作查询这些数据，下面是我的一些思路。</p>
<p>先声明我想要拿到的数据，这些都在上面的截图中存在。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">dbName</span> <span class="o">=</span> <span class="s2">&#34;LOBE_CHAT_DB&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">storeNames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;messages&#34;</span><span class="p">,</span> <span class="s2">&#34;sessionGroups&#34;</span><span class="p">,</span> <span class="s2">&#34;sessions&#34;</span><span class="p">,</span> <span class="s2">&#34;topics&#34;</span><span class="p">,</span> <span class="s2">&#34;users&#34;</span><span class="p">];</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">indexedDB</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">dbName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">request</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">messages</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sessionGroups</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sessions</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">topics</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">users</span><span class="o">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">pendingStores</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">storeNames</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">storeName</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">objectStoreNames</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">storeName</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">pendingStores</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">transaction</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">transaction</span><span class="p">([</span><span class="nx">storeName</span><span class="p">],</span> <span class="s2">&#34;readonly&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">objectStore</span> <span class="o">=</span> <span class="nx">transaction</span><span class="p">.</span><span class="nx">objectStore</span><span class="p">(</span><span class="nx">storeName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">allRecords</span> <span class="o">=</span> <span class="nx">objectStore</span><span class="p">.</span><span class="nx">getAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">allRecords</span><span class="p">.</span><span class="nx">onsuccess</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">state</span><span class="p">[</span><span class="nx">storeName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pendingStores</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">pendingStores</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">          * 整个数据库的数据都可以导出
</span></span></span><span class="line"><span class="cl"><span class="cm">          * 在此回调执行操作
</span></span></span><span class="line"><span class="cl"><span class="cm">          */</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="4-操作流程原型">4. 操作流程原型</h2>
<p>既然可以查询，就可以覆盖，同样也有 API 支持，所以我就构思了一下流程，利用 Webdav 的增删改查，把这些数据传到网盘中，然后在另一台设备拉取，最后优化一下整个流程，让它更加可视化。</p>
<p>大致原型如下：</p>
<p><img src="https://imgurl.zishu.me/2024/11/1731404855162.webp" alt="1731404855162"></p>
<p>点击同步到云端，会通过 Webdav API 在网盘创建一个指定的文件夹 <code>lobechat-webdav-backup</code>(我自己随意命名的)，在本地程序中生成一个 json 文件，IndexedDB 数据会被放入该文件中，然后通过 Webdav API 传输到网盘中。</p>
<p>点击下载到本地，会先通过 Webdav API 获取<code>lobechat-webdav-backup</code>下的 json 文件内容，利用 IndexedDB API 覆盖在浏览器 IndexedDB 数据库中。</p>
<hr>
<p>在实际体验中，可以随时保存本地数据到云端，下载数据到本地，同步就很方便，使用了三天，没有出现同步出错的问题，脚本很稳定。</p>
<p>最终我把该脚本发布到 Greasyfork，可供大家直接使用，代码也已开源。</p>
<ul>
<li>安装：<a href="https://greasyfork.org/scripts/516358">https://greasyfork.org/scripts/516358</a></li>
<li>Github：<a href="https://github.com/dlzmoe/UserScript">https://github.com/dlzmoe/UserScript</a></li>
</ul>

        <div class="weekly-pagination"></div>
      </article>

      
      <div class="post-tags">
        
        
        <span class="namenode">分类：<a href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
        </span>
        
        
        <span class="tag-node">
          
          标签：<a href="/tags/lobechat">#Lobechat</a>
          <a href="/tags/webdav">#Webdav</a>
          
          
        </span>
        
      </div>

      
      <div class="comments">
  <div class="giscus"></div>
</div>
<script 
  src="https://giscus.app/client.js" 
  data-repo="dlzmoe/blog" 
  data-repo-id="R_kgDOJkJvtw"
  data-category="Announcements" 
  data-category-id="DIC_kwDOJkJvt84CX9d6" 
  data-mapping="url" 
  data-strict="0"
  data-reactions-enabled="1" 
  data-emit-metadata="1" 
  data-input-position="top" 
  data-theme="fro"
  data-lang="zh-CN" 
  data-loading="lazy" 
  crossorigin="anonymous" 
  async>
</script>

      
    </div>
  </section>
  <footer class="footer">
  <div class="l-wrap">
    <p>© 2020 - 2025 Powered by
      <a href="https://github.com/dlzmoe" target="_blank">Github</a>
      / <a href="/index.xml" target="_blank">RSS</a>
    </p>
  </div>
  <div class="gotop"></div>
</footer>

<script src="/js/main.js"></script>
</body>

</html>