<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.123.6">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/" />
<link rel="canonical" href="https://zishu.me/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "",
"name" : "子舒的博客",
"headline" : "子舒的博客",
"description" : "",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2024",
"datePublished": "2024-09-12 00:00:00 \u002b0000 UTC",
"dateModified" : "2024-09-12 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/",
"keywords" : [  ]
}
</script><title>子舒的博客</title>
<meta property="og:title" content="子舒的博客" />
<meta property="og:type" content="website" />
<meta property="og:description" content="" />
<meta name="description" content="" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />


<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>

































































































































































































































































































































































































































































































































































































































































































































































































<body id="container">
  <meter id="isread" max="100" value="0"></meter>
<script>
  window.addEventListener('scroll', function () {
    var scrolled = window.scrollY;
    var totalHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percentage = (scrolled / totalHeight) * 100;
    $('#isread').attr('value', percentage)
  });
</script>


<div id="head" class="site-index">
  <a id="logo" href="/">
    <img src="https://imgurl.zishu.me/author.webp">
  </a>
  <div id="site-title">
    <a href="/">子舒的博客</a>
  </div>
  <ul id="menu">
    
    <li><a href="/categories/%e6%8a%80%e6%9c%af/">技术</a></li>
    
    <li><a href="/categories/%e9%9a%8f%e7%ac%94/">随笔</a></li>
    
    <li><a href="/categories/weekly/">周刊</a></li>
    
    <li><a href="/projects/">项目</a></li>
    
    <li><a href="/message/">留言</a></li>
    
    <li><a href="/about/">关于</a></li>
    
    <li><a href="/index.xml" target="_blank">订阅</a></li>
  </ul>
</div>

  <section id="body">
    <h2 id="body-title">📓 Articles</h2>

    <div id="body-in">

      <div class="index-post index-post-content-long">
        <p class="text">欢迎来到我的博客，已经运行了 <span id="days"></span> 天，有 <span id="busuanzi_value_site_pv">...</span>
          位小伙伴逛过，写了 274 篇文章，共 180337 字。</p>
      </div>

      
      
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/4.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/4.html/">
            <h2>关于人际交往的礼节感触</h2>
          </a>
          <div class="text">因为一件小事有感而发，在人际交往的过程中，我们通常都会关注一些细节，从而影响对一个人印象。这是一个作为人很正常的行为。 打个比方，两个人聊天，其中一个人不停拿起手机查看，就很给人一种很没有礼貌的印象。假如说有工作要忙，或者其他要处理的事项，这当然另当别论。换个思维，如果真的有那么忙，也不会发生此次社会交互行为活动。所以这是一个悖论了。基本上不存在忙的要命的情况。 我们在社会交往中，大多抱着一种善意的目的，希望从别人那里获得一些“利益”，这里的利益更多指代一中虚拟的情绪，比如开心，愉快，满足等。所以我在平时跟朋友社交，包括并不限于聚餐，出行游玩等，都是将重心放在此次活动中，如果有其他的事情，我都会提前处理安排好，不会影响活动进行。 我想，这是一个正常的人的社交应该有的，一个必需的态度，是一种比较充满正能量，积极向上的态度，如果双方都是如此，我想此次社交行为都将会有一些愉快的体验。 但有句古话说的挺好， “林子大了什么鸟都有”。你不能保证每个人的社交态度和行为都是一个积极的方向，将其转化为日常说法就是一个人的礼节，你不能确定他 (她) 真的有礼貌，或者在某些方面冒犯到你。 所以在你感觉到情绪不适，或者对他 (她) 有什么看法，最佳的做法就是旁敲侧击，看看他 (她) 是什么有什么重要原因，做出了一些失去礼节的行为，如果真的有原因的话，我都会表示理解。 但是如果真的是性格的方面的问题，导致他 (她) 一直都是这个样子，我一般也是表示理解，但是往后我会重新审视这个人，是否真的可以有成为好朋友的机会。 个人觉得最基本的礼节还是要有的。 另外说，手机真的没有那么好玩，没必要走路，吃饭都在看手机。如果真的想玩，可以独处时尽情的玩耍，多人在一起时，最好还是以社交为主，不然社交不就失去了它的意义吗？</div>
          <div class="index-post-meta">
            <a href="/blog/4.html/"> # 2021-11-24</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/84.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/84.html/">
            <h2>网易云摸鱼，测测你的听歌流量</h2>
          </a>
          <div class="text">格局刚好。</div>
          <div class="index-post-meta">
            <a href="/blog/84.html/"> # 2021-11-18</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/83.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/83.html/">
            <h2>这两天的碎碎念</h2>
          </a>
          <div class="text">这段时间双十一，发现没有了往年那种囤货淘宝的欲望了，翻来翻去不知道买什么，包括那些活动，有好多朋友给我发链接助力我都没怎么弄，可能是生活的打磨让我对它没兴趣了吧~~ 唯一的消费活动就是买了一台服务器，腾讯云正在做双十一特惠活动，一台 2h4g6m 的服务器，三年才一百多，个人感觉还是比较划算的，以后可以放一些脚本，跑跑服务啥的，还可以把我的博客挂在上面。 并且购买了一个新的域名 xiabanlo.cn，不过最近正在备案，通过之后就会使用了。坚持，不忘初心！ 然后就是突入起来的降温寒潮，虽然提前有了预报，却还是不小心中招了，昨天早上起来喉咙一直痛，想咳嗽。赶紧喝了两杯热水，发现作用不大，依旧是感冒流鼻涕了，不过还好是轻微的。 晚上回到家，把床垫子加厚了，并且换了加绒的被子。像什么毛衣手套啊，也都安排上了，喝两袋 999 感冒灵，今天感觉舒服多了，看了一眼天气预报，温度貌似还有回升，这就很棒了。 不过早上骑车去地铁的时候，还是有些冷，手套带好，裹得紧紧的。 生活不易，注意身体，防寒保暖~~ 中午，吃了一碗雪菜黄鱼面，味道很不错，点个赞！！（唯一的缺点就是有点小贵~~）</div>
          <div class="index-post-meta">
            <a href="/blog/83.html/"> # 2021-11-11</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/82.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/82.html/">
            <h2>揭秘箭头函数</h2>
          </a>
          <div class="text">英文地址：https://javascript.plainenglish.io/demystifying-javascript-arrow-functions-7b2a0908a2b3 通过掘金翻译计划活动进行翻译 箭头函数是函数表达式的替代方法，但在语法上有所不同，不能在所有情况下使用。如果您还没有阅读 JavaScript 中的函数表达式，我建议您在继续阅读之前先阅读这篇文章。 现在，让我们试着从语法、执行、作用域和提升以及代码示例方面来理解箭头函数。 1. 语法 const arrowFunctionSyntax = () =&gt; { console.log(&#39;Hi, I am an arrow function&#39;); }; arrowFunctionSyntax(); 在上面的代码示例中，我们可以看到箭头函数类似于函数表达式，因为它们被赋值为变量。主要区别在于函数的编写方式。以下是我们可以根据其语法从上述代码中得出的观察结果： 它不包含 function 关键字。 它没有 函数名 ，这意味着这些是匿名函数。 引入了箭头 =&gt; 符号。 const arrowFunctionWithOneParam = (number) =&gt; number + 1; const arrowFunctionWithMultipleParams = (numberOne, numberTwo) =&gt; { let sum = numberOne + numberTwo; return sum; }; console.log(arrowFunctionWithOneParam(5)); console.log(arrowFunctionWithMultipleParams(5, 6)); 如果我们同时观察 arrowFunctionWithOneParam 和 arrowFunctionWithMultipleParams，我们可以发现三者的不同&mdash;括号 ()、块 {} 和 return 关键字的使用。根据箭头函数的语法，如果函数只接受一个参数，可以忽略括号()。如果函数只包含一条语句，则可以忽略块{}，最后其实也可以忽略return ，如果函数只包含一个语句。 2. 执行 const arrowFunctionExecution = () =&gt; { console.log(&#39;Hi, my execution is similar to normal function&#39;); }; arrowFunctionExecution(); 在执行箭头函数时，它们的执行方式与其他普通函数的执行方式相似。当 JS 引擎执行 arrowFunctionExecution() 时，它会创建一个函数，执行上下文并被推送到调用堆栈。一旦创建了执行上下文，它就会启动创建阶段。在这个阶段，它将创建参数对象并在其本地内存堆中声明所有变量。 与普通函数相比，主要区别在于 this 的声明。箭头函数没有自己的 this 变量； this 在箭头函数中使用时会得到词法解析。在创建阶段之后不久，执行阶段开始。这时它开始执行语句 console.log() ，并将 &quot;Hi, my execution is similar to normal function&quot; 打印到控制台。 3. 作用域 const arrowFunctionScope = () =&gt; { console.log(&#39;Hi, my scoping rules works similar to function expression&#39;); }; 这些函数遵循与其他函数表达式相同的作用域规则。这些函数有自己的作用域，函数内部声明的任何变量都不能在函数外部访问。这些函数也不适用于 call、apply 和 bind 方法，这些方法通常依赖于作用域。如果您还没有阅读过 JavaScript 中的作用域，我建议您阅读 这篇文章。 4. 提升 amIGoingToBeHoisted(); var amIGoingToBeHoisted = () =&gt; { console.log(&#39;The answer is NO&#39;); }; 箭头函数没有被提升，因为它们也是函数表达式，其中函数被分配为变量的值。当 JavaScript 引擎执行上述代码时，在创建阶段，声明语句 var amIGoingToBeHoisted 将被移到顶部并使用值 undefined 进行初始化，而将初始值留在后面。在执行阶段，遇到语句amIGoingToBeHoisted 时会抛出类型错误，因为它的值是 undefined，这不是提升后的函数类型。要了解有关 JavaScript 提升的更多信息，我建议您阅读 文章。</div>
          <div class="index-post-meta">
            <a href="/blog/82.html/"> # 2021-11-05</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/81.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/81.html/">
            <h2>js 奇怪的知识--console.table</h2>
          </a>
          <div class="text">这个属性对我来说还真有些陌生，无意中发现的，查询过 MDN 之后听得挺有意思的，就记录一下。 根据字面意思就是“将数据以表格的形式显示”。这个方法需要一个必须参数 data，data 必须是一个数组或者是一个对象；还可以使用一个可选参数 columns。 表格的第一列是 index。如果数据 data 是一个数组，那么这一列的单元格的值就是数组的索引。如果数据是一个对象，那么它们的值就是各对象的属性名称。注意（在 FireFox 中）console.table 被限制为只显示 1000 行（第一行是被标记的索引）。 1.直接输出 直接进行尝试，在控制台输出 console.table console.table([&#34;双十一&#34;, &#34;双十二&#34;, &#34;双十三&#34;]); PS E:\demo&gt; node 1.js ┌─────────┬──────────┐ │ (index) │ Values │ ├─────────┼──────────┤ │ 1 │ &#39;双十二&#39; │ │ 2 │ &#39;双十三&#39; │ └─────────┴──────────┘ 复制下来怪怪的，直接上个图，就是下面这个样子。 2.定义对象进行输出 同样也可以定义一个对象然后输出 function Fun(title, date) { this.title = title this.date = date } const one = new Fun(&#34;双十一&#34;, &#34;11.11&#34;) const two = new Fun(&#34;双十二&#34;, &#34;12.12&#34;) const three = new Fun(&#34;双十三&#34;, &#34;你是傻子吗，没有 13 月&#34;) console.table([one, two, three], [&#34;title&#34;, &#34;date&#34;]) 打印出来，就是下面这个样子。 3.console.table() 的应用场景 前面是在通过在编辑器中使用 node.js 输出数据，看看在浏览器中输出会不会不一样的效果。 可以看到成功输出数据，并且点击表头时，可以按照不同顺序进行排序，这么一看&hellip;.嗯，还挺有用的（假笑） 应用场景大概就是可以对打印的数据进行更直观的观看，在某些情况下有利于调试代码，以后看看是否能用得上这种方法。</div>
          <div class="index-post-meta">
            <a href="/blog/81.html/"> # 2021-11-04</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/80.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/80.html/">
            <h2>通过 getTimezoneOffset() 方法判断当前时区是否为夏令时</h2>
          </a>
          <div class="text">getTimezoneOffset() 方法 方法返回 UTC 时间和本地时间之间的时差，以分钟为单位。 世界协调时间 (UTC) 是世界时间标准设定的时间，UTC 时间与 GMT 时间（格林威治时间）相同。 测一下我所在时区和标准时区的时间差 function myDate () { var d = new Date(); var n = d.getTimezoneOffset(); console.log(n) } myDate(); // PS E:\demo&gt; node 1.js // -480 也就是 480 分钟（8 个小时），北京时间是东八区，刚好与格林威治时间相差 8 个小时，这说明 getTimezoneOffset() 方法是很有效的。 接下来利用这个方法，判断一下当前时区是否为夏令时。 const time1 = new Date(2021, 0, 1); const time2 = new Date(2021, 6, 1); if (time1.getTimezoneOffset() != time2.getTimezoneOffset()) { console.log(&#39;夏令时&#39;); } else { console.log(&#39;非夏令时&#39;); } // PS E:\demo&gt; node 1.js // 非夏令时</div>
          <div class="index-post-meta">
            <a href="/blog/80.html/"> # 2021-10-22</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/79.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/79.html/">
            <h2>有关国庆出行的感想</h2>
          </a>
          <div class="text">好长时间没回老家了，这次本想借着国庆七天回家一趟，顺便处理一些其他的事情。所以我从 9 月 30 日晚，与家人一同驾车回家。 艰难的回家之路 刚上高速跑得很快，原以为已经错开出行高峰期，结果发现是我想多了，不出意外的堵在高速上。 导航呢，这时候也是推荐不走高速，直接从国道走（真的是后悔），然后我们就下了高速，结果这个导航给我整的有点蒙，在临安绕来绕去，11 点从杭州出发，凌晨 3 点还在临安出不去，国道都在堵车，然后没办法只能就地休息，困得实在不行了，其实睡也睡不舒服，跑夜车都是这个样子。 睡到 5 点多，这时候已经是 10 月 1 日了，继续出发，按照导航走，结果走到了一个盘山公路，不知道叫什么山，没注意看。 大概走了 3 个小时，盘山公路弯弯曲曲的，九转十八弯。不过风景还行，权当安慰自己出来旅游了。 中午才从山里出来，这时候在安徽境内，接近六安。 大家随便弄点泡面吃了吃，继续出发，已经是 1 号下午了。跑到下午 5 点多的时候，距离老家还有 100 公里左右，再来两个小时差不多就到了。结果发生了一些小意外，导致轮胎爆了，然后处理事故到后半夜，修好车也不能走了，身心疲惫，就地开了个宾馆休息，一夜的深度睡眠真的很爽，以后再也不熬夜了，难受死。 早上睡到 9 点半起，简单收拾一下，10 点出发，也没有吃饭，不太饿，打算一口气开回家，也是不负众望，午饭前就赶到县城了。 好久没回家，发现物价真的低，四个人吃的撑死，最后没吃完，把剩下的菜打包带回去，结账也才 150 左右。不过工资水平也和物价水平差不多，然后就引发了我的一个新的思考，以后是否可以回县城养老。 回家碎碎念&hellip;照片 (无) 6 号踏上返程的道路，7 号回到杭州，真的身心疲惫。又是一路的夜车，在服务区休息了两个小时也顶不了多大的用。 到杭州之后就开始胃疼了，大致算了一下，7 天，有 4 天都在路上奔波，吃的都是饼干泡面，实在是扛不住，到这边之后吃完饭洗了个澡直接睡到下午六点，起来还是精神有些萎靡，我估计至少得三天才能缓成正常。毕竟年纪大了，真的痛苦。 关于开车出行的反思 长了个记性，以后再也不开学出行跑长途了，特别节假日，火车七八个小时，睡一觉就能解决的问题搞得那么复杂，不过也是因为带了一些行李的缘故。下次就打算行李直接寄回去，随身背个包，然后坐火车轻装上阵，岂不是美滋滋。 吐槽高速的一些事情 安徽段高速真的不行，管理不到位，救援迟缓，在安徽境内高速上堵车的时候，应急车道基本没闲着，私家车直接跑，路过别的省份基本很少有这种现象，而且出现事故的时候，救援迟缓，交管不到位，直接导致堵车堵了很长时间，我在河南段，浙江段跑的时候，看到事故都是处理的很快，基本没有太长的堵车现象。</div>
          <div class="index-post-meta">
            <a href="/blog/79.html/"> # 2021-10-07</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/78.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/78.html/">
            <h2>使用 js 随机生成背景颜色</h2>
          </a>
          <div class="text">先写一个简单的 html 页面出来 &lt;style&gt; /* ... */ &lt;/style&gt; &lt;ul&gt; &lt;li&gt;html&lt;/li&gt; &lt;li&gt;css&lt;/li&gt; &lt;li&gt;js&lt;/li&gt; &lt;/ul&gt; 通过 Math.random() 属性可以随机生成一个数字，然后通过转化为十六进制的方法进行处理，下面就是随机生成 6 位数字的代码，并进行转化的代码。 const randomHex = () =&gt; `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &#34;0&#34;)}`; 可以在控制台输出看一下结果，随机生成了一个结果 #62113b。 接下来就需要将这个颜色传给上面的 li 标签，首先需要将所有的 li 遍历然后生成一个数组，可以使用 for 循环进行遍历。 var arr = document.getElementsByTagName(&#39;li&#39;), temp = []; for (var i = 0; i &lt; arr.length; i++) { temp.push(arr[i].innerHTML); } 然后再对数组进行循环处理，每个 li 标签要要运行一遍随机生成颜色，并且传给自身。同样也是通过 for 循环进行操作。 var li = document.getElementsByTagName(&#34;li&#34;); for (var i = 0; i &lt; li.length; i++) { for (var num = 0; num &lt; li.length; num++) { li[num].style.background = randomHex(); } } 这些事件都是在页面加载完成之后运行的，所以需要通过 window.onload 写入事件，然后把所有的代码合在一起。 看看效果如果。 把这些复制下来放到本地运行一下就可以看到效果了。 &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; &lt;title&gt;随机生成颜色&lt;/title&gt; &lt;style&gt; body { display: flex; justify-content: center; padding-top: 100px; } ul { list-style: none; padding: 0; display: flex; } li { width: 100px; height: 40px; color: #333; display: flex; justify-content: center; align-items: center; margin-right: 30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;html&lt;/li&gt; &lt;li&gt;css&lt;/li&gt; &lt;li&gt;js&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const randomHex = () =&gt; `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &#34;0&#34;)}`; console.log(randomHex()); var arr = document.getElementsByTagName(&#39;li&#39;), temp = []; for (var i = 0; i &lt; arr.length; i++) { temp.push(arr[i].innerHTML); } window.onload = function () { var li = document.getElementsByTagName(&#34;li&#34;); for (var i = 0; i &lt; li.length; i++) { for (var num = 0; num &lt; li.length; num++) { li[num].style.background = randomHex(); } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 如果有更好的写法，欢迎评论！</div>
          <div class="index-post-meta">
            <a href="/blog/78.html/"> # 2021-09-29</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/77.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/77.html/">
            <h2>hugo 如何使用 Cusdis ?</h2>
          </a>
          <div class="text">Cusdis 是一个界面清爽、注重隐私的轻量级 (~5kb gzip) 评论系统，可以很方便地与 React、Vue 或其他博客系统结合，并且还提供了一个后台来管理所有的评论。 由于 Cusdis 自称是 Disqus 的替代方案，因此它还支持一键从 Disqus 导入、支持邮件通知等功能。 官方地址：https://cusdis.com/ 他通常是用于静态博客的一个第三方评论系统，但是官方文档没有提供如何在 hugo 中使用的参数，我也是报错了多次才琢磨出来。 1. 本地部署 根据提示，注册账号，然后 Add website ，建立一个仓库。 进入它，然后点击 setting。 Embed Code 会提供几行代码以及一些 api，复制他们。 data-app-id 是注册时自动生成的，注意保密，每个人都不一样。 &lt;div id=&#34;cusdis_thread&#34; data-host=&#34;https://cusdis.com&#34; data-app-id=&#34;xxxxxxxxx&#34; data-page-id=&#34;{{ PAGE_ID }}&#34; data-page-url=&#34;{{ PAGE_URL }}&#34; data-page-title=&#34;{{ PAGE_TITLE }}&#34; &gt;&lt;/div&gt; &lt;script async defer src=&#34;https://cusdis.com/js/cusdis.es.js&#34;&gt;&lt;/script&gt; 将这些代码复制到本地主题的 comments.html 文件内（就是评论的那个模块，每个主题或许都不一样，注意分辨）。 这个时候如果你 hugo server 基本都会报错，因为没有修改 {{ PAGE_ID }} 等内容，这不是 hugo 官方提供的参数，按照我下面的格式，将 id, url, title 重写一下即可。 &lt;div id=&#34;cusdis_thread&#34; data-host=&#34;https://cusdis.com&#34; data-app-id=&#34;c1d43485-e8a7-4895-972e-247eddaf242d&#34; data-page-id=&#34;{{ .RelPermalink }}&#34; data-page-url=&#34;{{ .RelPermalink }}&#34; data-page-title=&#34;{{ .Title }}&#34; &gt;&lt;/div&gt; &lt;script async defer src=&#34;https://cusdis.com/js/cusdis.es.js&#34;&gt;&lt;/script&gt; 保存重新 hugo server 即可。 这样做的好处是当你接受一条评论信息后，审核列表可以清楚地标明来自哪一篇文章。通常大多数博客都提供了这么一个功能。 2. 邮箱提醒 除了必备的评论功能，Cusdis 还提供了一个非常快速的邮箱提醒功能，不需要绑定密匙，直接输入自己的邮箱即可。 先勾选这个 Email Notification，然后点击下方的 Advanced Notification Settings (高级通知设置) 就可以进入设置，输入自己的邮箱。 3. 中文化 默认的评论和提示文字均为英文，对我们很不友好，这里提供一个不错的解决方案，在引入 Cusdis 之后，顺便复制引入下面这段代码。 &lt;script&gt; window.CUSDIS_LOCALE = { &#34;powered_by&#34;: &#34;评论由 Cusdis 提供&#34;, &#34;post_comment&#34;: &#34;发送&#34;, &#34;loading&#34;: &#34;加载中&#34;, &#34;email&#34;: &#34;邮箱地址 (可选)&#34;, &#34;nickname&#34;: &#34;昵称&#34;, &#34;reply_placeholder&#34;: &#34;回复内容...&#34;, &#34;reply_btn&#34;: &#34;回复&#34;, &#34;sending&#34;: &#34;发送中...&#34;, &#34;mod_badge&#34;: &#34;管理员&#34;, &#34;content_is_required&#34;: &#34;内容不能为空&#34;, &#34;nickname_is_required&#34;: &#34;昵称不能为空&#34;, &#34;comment_has_been_sent&#34;: &#34;评论已发送，管理员审核通过后会展示&#34; } &lt;/script&gt; 。。。</div>
          <div class="index-post-meta">
            <a href="/blog/77.html/"> # 2021-09-16</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      

      



















<div class="page">
  
  <a href="/page/21/" class="prev">上一页</a>
  

  
  <a href="/page/23/" class="next">下一页</a>
  


</div>



    </div>

    <footer id="foot">
  <p>© 2020 - 2024 Powered by
    <a href="https://github.com/dlzmoe/blog" target="_blank">Github</a>
    / <a href="/index.xml" target="_blank">RSS</a>
  </p>
</footer>

<script src="/js/main.js"></script>
<script defer src="https://cn.vercount.one/js"></script>
  </section>

  <script>
    const time = "2020-06-14";
    var now = new Date();
    var end = new Date(time);
    var diff = Math.abs(now - end);
    var days = Math.ceil(diff / (1000 * 60 * 60 * 24));
    $('#days').html(days);
  </script>
</body>

</html>