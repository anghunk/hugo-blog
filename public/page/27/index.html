<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.123.6">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/" />
<link rel="canonical" href="https://zishu.me/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "",
"name" : "子舒的博客",
"headline" : "子舒的博客",
"description" : "",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2024",
"datePublished": "2024-09-05 00:00:00 \u002b0000 UTC",
"dateModified" : "2024-09-05 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/",
"keywords" : [  ]
}
</script><title>子舒的博客</title>
<meta property="og:title" content="子舒的博客" />
<meta property="og:type" content="website" />
<meta property="og:description" content="" />
<meta name="description" content="" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />


<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>

























































































































































































































































































































































































































































































































































































































































































































































































<body id="container">
  <meter id="isread" max="100" value="0"></meter>
<script>
  window.addEventListener('scroll', function () {
    var scrolled = window.scrollY;
    var totalHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percentage = (scrolled / totalHeight) * 100;
    $('#isread').attr('value', percentage)
  });
</script>


<div id="head" class="site-index">
  <a id="logo" href="/">
    <img src="https://imgurl.zishu.me/author.webp">
  </a>
  <div id="site-title">
    <a href="/">子舒的博客</a>
  </div>
  <ul id="menu">
    
    <li><a href="/categories/%e6%8a%80%e6%9c%af/">技术</a></li>
    
    <li><a href="/categories/%e9%9a%8f%e7%ac%94/">随笔</a></li>
    
    <li><a href="/categories/weekly/">周刊</a></li>
    
    <li><a href="/message/">留言</a></li>
    
    <li><a href="/about/">关于</a></li>
    
    <li><a href="/index.xml" target="_blank">订阅</a></li>
  </ul>
</div>

  <section id="body">
    <h2 id="body-title">📓 Articles</h2>

    <div id="body-in">

      <div class="index-post index-post-content-long">
        <p class="text">欢迎来到我的博客，已经运行了 <span id="days"></span> 天，有 <span id="busuanzi_value_site_pv">...</span>
          位小伙伴逛过，写了 271 篇文章，共 179985 字。</p>
      </div>

      
      
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/38.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/38.html/">
            <h2>2020 年度总结</h2>
          </a>
          <div class="text">年度总结这个东西很有意思（我觉得），可以静下心来好好回顾一下这一年做了些什么事情，希望我能养成这个好习惯，多总结。 这个博客是我在年中搭建起来了，到现在也将近半年了，没怎么做过 seo 优化，也没怎么想过推广，就简简单单的写一些自己的东西。更大的原因是我的文笔太拙劣，不敢让人发现，哈哈哈。 大学四年过的还算充实，学到了自己感兴趣的东西，培养的业余兴趣爱好，旅游爬山等，但有名的大山目前只爬了嵩山（河南境内），因为在郑州读的大学。更远的山也没怎么去过，我给自己定个计划，在两年内爬一次泰山，因为工作太忙咯，不敢说短期内一定有时间。想体会一下&quot;会当凌绝顶，一览众山小&quot;的感觉。 但是吧，我的大学结束的有些虎头蛇尾的感觉，因为疫情的原因，学校禁止进入，一直到毕业前夕才允许分批次返校，很多同学都没有看到就草草结束大学生活。所以心心念念的毕业照也没有了，本来和朋友商量好一起拍一组有意思的毕业照，真的是今年最大的遗憾了。 离开校园，见面的机会真的就少了很多，基本都是打打电话，视频什么的，各奔东西，为生活开始忙碌。 2020 年，是让人印象深刻的一年，从一月份爆发的疫情开始，胆战心惊，一直到现在，依旧在全球蔓延，就在前两天看新闻，说英国要严重了，病毒变异，又封城了。真的希望这场疫情赶快过去。 为什么国外对这方面对管控好像没那么严？真的不理解，或许这就是&quot;向往自由&quot;吧。希望地球每个人都能重视起来，共同对抗病毒，早日结束这一场。 今年从郑州来到了杭州，换了一个新的环境，在工作中和大家有着共同的目标，学到了很多东西，但是也有一些遗憾，本来打算读两本书的的，下半年读了余果的《全栈工程师的自我修养》和《css 世界》，前段时间还写了读书笔记《对全栈的一些思考》，然后十一月份在某宝买了《javascript 高级程序设计》，结果因为时间不充足，最后也没读完。 在这里定一个小目标，2021 年一定要读完四本书。 在技术栈这一块，由 Vue 转向了 React，这里实在想吐槽一句。React 是 Facebook 开发的，Vue 是尤大大开发出来的，感觉写起来思维逻辑不太一样，Vue 的写法更偏向中国程序员的思维方式，React 更偏向外国人，因为我也不是外国人，所以也说不好是一种什么样的思维方式，只是感觉理解起来比 Vue 更难一些。但是因为公司的原因，开始着手 React 开发项目。 希望在新的一年继续延续下去，在学习更多的技术栈的同时，把自己要做的事情做的更好。 在杭州待了也有一段时间，这个城市看起来很年轻，很有朝气，可能因为年轻人的占比比较大吧。偶尔出去玩玩，能发现一些以前发现不了的东西，开阔一下自己的眼界。这里夸一下，西湖的风景确实不错，走在苏堤，吹吹风，整个人都放松了。平时压力大了，都会出来走走，但是好像一个人旅游好像缺了点乐趣。 这两天是圣诞节，虽说是洋节，但是自己也可以乐呵一下，在这里祝愿大家都能在 2020 年有一个好的结束，画上圆满的句号，迎接新的 2021 年。 抽出空闲的时间简单的写了一下总结，就好像跟看电影一样，又回顾了一遍剧情，又得到了不一样的感受。 你好，自己，明年见。</div>
          <div class="index-post-meta">
            <a href="/blog/38.html/"> # 2020-12-25</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/37.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/37.html/">
            <h2>React －－万物皆可组件</h2>
          </a>
          <div class="text">一、React 组件是什么？ 组件，从概念上类似于 javascript 函数，他接受任意入参（props），并返回作用于描述页面展示内容的 React 元素。 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。 1.创建一个组件 // 函数组件 function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } // class 组件 class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } 2.渲染组件 class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } ReactDOM.render( &lt;Welcome /&gt;, document.getElementById(&#39;root&#39;) ); 3.组件 React 的基础原则有三条，分别是： React 界面完全由数据驱动 React 中一切都是组件 props 是 React 组件之间通讯的基本方式 给组件输入一个参数，最终返回一个 React Element,React Element 就是在页面上展示的内容，相当于一个 DOM 节点 React 一大核心就是－－万物皆可组件 用户界面就是组件 组件可以嵌套包装组成复杂功能 组件可以用来实现副作用 一个复杂的界面可以分割很很多简单的组件，每个简单的组件又可以分割成很多小组件 有些类似于类和对象的概念 二、组件的划分 **无状态组件：**无状态组件 (Stateless Component) 是最基础的组件形式，由于没有状态的影响所以就是纯静态展示的作用。基本组成结构就是属性（props）加上一个渲染函数（render）。由于不涉及到状态的更新，所以这种组件的复用性也最强。例如在各 UI 库中开发的按钮、输入框、图标等等。 **有状态组件：**组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。有状态组件通常会带有生命周期 (lifecycle)，用以在不同的时刻触发状态的更新。在写业务逻辑时常用到，不同场景所用的状态和生命周期也会不同。 **容器组件：**为使组件的职责更加单一，耦合性进一步地降低，引入了容器组件 (Container Component) 的概念。重要负责对数据获取以及处理的逻辑。下文的设计模式也会提到。 高阶组件：“高阶组件（HoC）”也算是种组件设计模式。做为一个高阶组件，可以在原有组件的基础上，对其增加新的功能和行为。如打印日志，获取数据和校验数据等和展示无关的逻辑的时候，抽象出一个高阶组件，用以给基础的组件增加这些功能，减少公共的代码。 **Render Callback 组件：**组件模式是在组件中使用渲染回调的方式，将组件中的渲染逻辑委托给其子组件。也是种重用组件逻辑的方式，也叫 render props 模式。 三、设计原则 React 的组件其实是软件设计中的模块，其设计原则也需遵从通用的组件设计原则，简单说来，就是要减少组件之间的耦合性（Coupling)，让组件简单，这样才能让整体系统易于理解、易于维护。 即，设计原则： 接口小，props 数量少； 划分组件，充分利用组合（composition）； 把 state 往上层组件提取，让下层组件只需要实现为纯函数。 就像搭积木，复杂的应用和组件都是由简单的界面和组件组成的。划分组件也没有绝对的方法，选择在当下场景合适的方式划分，充分利用组合即可。实际编写代码也是逐步精进的过程，努力做到： 功能正常； 代码整洁； 高性能。</div>
          <div class="index-post-meta">
            <a href="/blog/37.html/"> # 2020-12-21</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/36.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/36.html/">
            <h2>javascript 进阶问题</h2>
          </a>
          <div class="text">Github: https://github.com/lydiahallie/javascript-questions 相当不错的一个 Github 仓库，javascript questions ，作者每周都会发布一些有关 javascript 的题目，虽然不难但是考察细节，刷了一会，其实一些很简单的问题，结果因为细节思考不到位直接出错。 引用作者的话：我在我的 Instagram 上每天都会发布 JavaScript 的多选问题，并且同时也会在这个仓库中发布。 从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！</div>
          <div class="index-post-meta">
            <a href="/blog/36.html/"> # 2020-12-19</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/35.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/35.html/">
            <h2>React 学习笔记（二）</h2>
          </a>
          <div class="text">React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同 React 事件的命名采用小驼峰式（camelCase），而不是纯小写 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串 一、事件处理 1.事件绑定 React 元素的事件处理和 DOM 元素类似，但是在语法上有些区别，比如： 传统的 html：用双引号包裹，后面必须跟参数 &lt;button onclick=&#34;myfun()&#34;&gt;点击&lt;/button&gt; React：用大括号包裹，后面不跟参数 &lt;button onclick={myfun}&gt;点击&lt;/button&gt; 一个完整的事件函数代码如下 class Demo extends React.Component { render() { // 事件函数 function myfun() { alert(&#39;helo,world&#39;) } return ( // 绑定事件 &lt;button onClick={this.myfun}&gt; Activate Lasers &lt;/button&gt; ) } } ReactDOM.render( &lt;Demo /&gt;, document.getElementById(&#39;root&#39;) ) 如果方法后面没有()，则需要为这个方法绑定 this 2.阻止默认行为 在 React 中还有一个不同的点，不能通过返回 fasle 阻止默认行为，React 提供了一个属性－－preventDefault，可以通过 preventDefault 阻止脚本执行 看一下传统的 html 和 React 的对比 &lt;a href=&#34;#&#34; onclick=&#34;alert(&#39;是否弹窗？&#39;);return false&#34;&gt; Click me &lt;/a&gt; 直接在写上 false 就可以阻止脚本执行 React 通过 preventDefault 属性阻止脚本执行： function ActionLink() { function handleClick(e) { e.preventDefault(); console.log(&#39;The link was clicked.&#39;); } return ( &lt;a href=&#34;#&#34; onClick={handleClick}&gt; Click me &lt;/a&gt; ); } 二、条件渲染 在 React 中，可以创建不同的组件来封装各种你需要的行为，然后，根据应用不同的状态，你可以只渲染对应状态下的部分内容。 React 中的条件渲染和 javascript 中的一样，使用 if 运算符来表示元素当前的状态，然后让 React 根据他们来更新 UI。 使用 if..else 语句进行条件渲染 先写一个条件渲染的例子，定义了两个组件，然后通过判断组件 Greeting 中的变量 isLoggedIn 的真伪，让浏览器渲染组件 UserGreeting 或者 GuestGreeting。 // App.js import React, { Component } from &#39;react&#39; export default class App extends Component { render() { function UserGreeting(props) { return &lt;h3&gt;Welcome back!&lt;/h3&gt;; } function GuestGreeting(props) { return &lt;h3&gt;Please sign up.&lt;/h3&gt;; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return &lt;UserGreeting /&gt;; } return &lt;GuestGreeting /&gt;; } return ( &lt;div&gt; &lt;Greeting isLoggedIn={false} /&gt; &lt;/div&gt; ) } } 最后变量 isLoggedIn 定义了 false，因此，浏览器渲染 `GuestGreeting。 怎么阻止条件渲染？ 在有些情况下，我们希望能隐藏组件，即使他已经被其他组件渲染。我们可以通过 render 方法返回 null 让组件不渲染。 下面的示例中， 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染： function WarningBanner(props) { if (!props.warn) { return null; } return ( &lt;div className=&#34;warning&#34;&gt; Warning! &lt;/div&gt; ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true}; this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(state =&gt; ({ showWarning: !state.showWarning })); } render() { return ( &lt;div&gt; &lt;WarningBanner warn={this.state.showWarning} /&gt; &lt;button onClick={this.handleToggleClick}&gt; {this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;} &lt;/button&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Page /&gt;, document.getElementById(&#39;root&#39;) ); 三、渲染列表 先看一段代码，我们使用 map() 函数让数组中的每一项变双倍，然后得到一个新的数组 doubled 并打印出来。 const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) =&gt; number * 2); console.log(doubled); // [2,4,6,8,10] 而在 React 中，把数组转换为元素列表的过程是相似的。 先通过 map() 方法遍历 numbers 数组，将数组中的每个元素变成 &lt;li&gt; 标签，最后将得到的数组赋值给 listItems 。 然后返回 {listItem} 。 // Map.js const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); ReactDOM.render( &lt;ul&gt;{listItems}&lt;/ul&gt;, document.getElementById(&#39;root&#39;) ); 运行之后浏览器出现 1-5 的无序列表 1.分离组件 上面就是一个基本的列表渲染的例子，但是数据写死了。接下来我们将数组重构成一个组件，以后再进行数组渲染时，可以轻松调用。 // Map.js export default class Map extends Component { render() { // 分离出组件 NumberList 作为转换数组的组件 function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入需要的数据 const numbers = [1, 2, 3, 4, 5, 6, 7]; return ( &lt;div&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/div&gt; ) } } 2.key 运行代码之后，页面会正常显示，但是控制台会报一个错误。Each child in a list should have a unique &quot;key&quot; prop.，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。 现在给每个列表元素分配一个 key： function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 3.使用 id 作为 key key 帮助 React 识别了哪些元素被改变，比如删除和添加，所以应当给每个元素确定一个标识，也就是 key。 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key： // Map.js export default class Map extends Component { render() { function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.id}&gt; // 赋值 key {number.text} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入数据 const numbers = [ {id: 1,text: 1}, {id: 2,text: 2}, {id: 3,text: 3}, {id: 4,text: 4}, {id: 5,text: 5} ]; return ( &lt;Fragment&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/Fragment&gt; ) } } 4.索引 index 可以作为 key 吗？ 当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key： const todoItems = todos.map((todo, index) =&gt; // 仅仅当没有确定 id 的时候使用索引 index 作为 key &lt;li key={index}&gt; {todo.text} &lt;/li&gt; ); 如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。 5.用 key 提取组件 比方说，如果你提取出一个 ListItem 组件，你应该把 key 保留在数组中的这个 &lt;ListItem /&gt; 元素上，而不是放在 ListItem 组件中的 &lt;li&gt; 元素上。 错误的使用方法： function ListItem(props) { const value = props.value; return ( // 错误！你不需要在这里指定 key： &lt;li key={value.toString()}&gt; {value} &lt;/li&gt; ); } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！元素的 key 应该在这里指定： &lt;ListItem value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 正确的使用方法： function ListItem(props) { // 正确！这里不需要指定 key： return &lt;li&gt;{props.value}&lt;/li&gt;; } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key={number.toString()} value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); React：一个好的经验法则是：在 map( ) 方法中的元素需要设置 key 属性。 6.key 只是在兄弟节点之间必须唯一 数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值： function Blog(props) { const sidebar = ( &lt;ul&gt; {props.posts.map((post) =&gt; &lt;li key={post.id}&gt; {post.title} &lt;/li&gt; )} &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key={post.id}&gt; &lt;h3&gt;{post.title}&lt;/h3&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; {sidebar} &lt;hr /&gt; {content} &lt;/div&gt; ); } const posts = [ {id: 1, title: &#39;Hello World&#39;, content: &#39;Welcome to learning React!&#39;}, {id: 2, title: &#39;Installation&#39;, content: &#39;You can install React from npm.&#39;} ]; ReactDOM.render( &lt;Blog posts={posts} /&gt;, document.getElementById(&#39;root&#39;) ); 7.vue 中渲染列表 Vue 中渲染列表使用的是特殊指令 v-for，其中也有 key 的相关用法 React 中采用的是 map() 方法遍历数组，然后渲染列表 title: React 学习笔记（二） date: 2020-12-16 13:15:00 updated: 2021-11-09 15:19:31 categories: 技术 tags: react React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同 React 事件的命名采用小驼峰式（camelCase），而不是纯小写 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串 一、事件处理 1.事件绑定 React 元素的事件处理和 DOM 元素类似，但是在语法上有些区别，比如： 传统的 html：用双引号包裹，后面必须跟参数 &lt;button onclick=&#34;myfun()&#34;&gt;点击&lt;/button&gt; React：用大括号包裹，后面不跟参数 &lt;button onclick={myfun}&gt;点击&lt;/button&gt; 一个完整的事件函数代码如下 class Demo extends React.Component { render() { // 事件函数 function myfun() { alert(&#39;helo,world&#39;) } return ( // 绑定事件 &lt;button onClick={this.myfun}&gt; Activate Lasers &lt;/button&gt; ) } } ReactDOM.render( &lt;Demo /&gt;, document.getElementById(&#39;root&#39;) ) 如果方法后面没有()，则需要为这个方法绑定 this 2.阻止默认行为 在 React 中还有一个不同的点，不能通过返回 fasle 阻止默认行为，React 提供了一个属性－－preventDefault，可以通过 preventDefault 阻止脚本执行 看一下传统的 html 和 React 的对比 &lt;a href=&#34;#&#34; onclick=&#34;alert(&#39;是否弹窗？&#39;);return false&#34;&gt; Click me &lt;/a&gt; 直接在写上 false 就可以阻止脚本执行 React 通过 preventDefault 属性阻止脚本执行： function ActionLink() { function handleClick(e) { e.preventDefault(); console.log(&#39;The link was clicked.&#39;); } return ( &lt;a href=&#34;#&#34; onClick={handleClick}&gt; Click me &lt;/a&gt; ); } 二、条件渲染 在 React 中，可以创建不同的组件来封装各种你需要的行为，然后，根据应用不同的状态，你可以只渲染对应状态下的部分内容。 React 中的条件渲染和 javascript 中的一样，使用 if 运算符来表示元素当前的状态，然后让 React 根据他们来更新 UI。 使用 if..else 语句进行条件渲染 先写一个条件渲染的例子，定义了两个组件，然后通过判断组件 Greeting 中的变量 isLoggedIn 的真伪，让浏览器渲染组件 UserGreeting 或者 GuestGreeting。 // App.js import React, { Component } from &#39;react&#39; export default class App extends Component { render() { function UserGreeting(props) { return &lt;h3&gt;Welcome back!&lt;/h3&gt;; } function GuestGreeting(props) { return &lt;h3&gt;Please sign up.&lt;/h3&gt;; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return &lt;UserGreeting /&gt;; } return &lt;GuestGreeting /&gt;; } return ( &lt;div&gt; &lt;Greeting isLoggedIn={false} /&gt; &lt;/div&gt; ) } } 最后变量 isLoggedIn 定义了 false，因此，浏览器渲染 `GuestGreeting。 怎么阻止条件渲染？ 在有些情况下，我们希望能隐藏组件，即使他已经被其他组件渲染。我们可以通过 render 方法返回 null 让组件不渲染。 下面的示例中， 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染： function WarningBanner(props) { if (!props.warn) { return null; } return ( &lt;div className=&#34;warning&#34;&gt; Warning! &lt;/div&gt; ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true}; this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(state =&gt; ({ showWarning: !state.showWarning })); } render() { return ( &lt;div&gt; &lt;WarningBanner warn={this.state.showWarning} /&gt; &lt;button onClick={this.handleToggleClick}&gt; {this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;} &lt;/button&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Page /&gt;, document.getElementById(&#39;root&#39;) ); 三、渲染列表 先看一段代码，我们使用 map() 函数让数组中的每一项变双倍，然后得到一个新的数组 doubled 并打印出来。 const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) =&gt; number * 2); console.log(doubled); // [2,4,6,8,10] 而在 React 中，把数组转换为元素列表的过程是相似的。 先通过 map() 方法遍历 numbers 数组，将数组中的每个元素变成 &lt;li&gt; 标签，最后将得到的数组赋值给 listItems 。 然后返回 {listItem} 。 // Map.js const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); ReactDOM.render( &lt;ul&gt;{listItems}&lt;/ul&gt;, document.getElementById(&#39;root&#39;) ); 运行之后浏览器出现 1-5 的无序列表 1.分离组件 上面就是一个基本的列表渲染的例子，但是数据写死了。接下来我们将数组重构成一个组件，以后再进行数组渲染时，可以轻松调用。 // Map.js export default class Map extends Component { render() { // 分离出组件 NumberList 作为转换数组的组件 function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入需要的数据 const numbers = [1, 2, 3, 4, 5, 6, 7]; return ( &lt;div&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/div&gt; ) } } 2.key 运行代码之后，页面会正常显示，但是控制台会报一个错误。Each child in a list should have a unique &quot;key&quot; prop.，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。 现在给每个列表元素分配一个 key： function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 3.使用 id 作为 key key 帮助 React 识别了哪些元素被改变，比如删除和添加，所以应当给每个元素确定一个标识，也就是 key。 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key： // Map.js export default class Map extends Component { render() { function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key={number.id}&gt; // 赋值 key {number.text} &lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } // 传入数据 const numbers = [ {id: 1,text: 1}, {id: 2,text: 2}, {id: 3,text: 3}, {id: 4,text: 4}, {id: 5,text: 5} ]; return ( &lt;Fragment&gt; &lt;NumberList numbers={numbers} /&gt; &lt;/Fragment&gt; ) } } 4.索引 index 可以作为 key 吗？ 当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key： const todoItems = todos.map((todo, index) =&gt; // 仅仅当没有确定 id 的时候使用索引 index 作为 key &lt;li key={index}&gt; {todo.text} &lt;/li&gt; ); 如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。 5.用 key 提取组件 比方说，如果你提取出一个 ListItem 组件，你应该把 key 保留在数组中的这个 &lt;ListItem /&gt; 元素上，而不是放在 ListItem 组件中的 &lt;li&gt; 元素上。 错误的使用方法： function ListItem(props) { const value = props.value; return ( // 错误！你不需要在这里指定 key： &lt;li key={value.toString()}&gt; {value} &lt;/li&gt; ); } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！元素的 key 应该在这里指定： &lt;ListItem value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 正确的使用方法： function ListItem(props) { // 正确！这里不需要指定 key： return &lt;li&gt;{props.value}&lt;/li&gt;; } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key={number.toString()} value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); React：一个好的经验法则是：在 map( ) 方法中的元素需要设置 key 属性。 6.key 只是在兄弟节点之间必须唯一 数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值： function Blog(props) { const sidebar = ( &lt;ul&gt; {props.posts.map((post) =&gt; &lt;li key={post.id}&gt; {post.title} &lt;/li&gt; )} &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key={post.id}&gt; &lt;h3&gt;{post.title}&lt;/h3&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; {sidebar} &lt;hr /&gt; {content} &lt;/div&gt; ); } const posts = [ {id: 1, title: &#39;Hello World&#39;, content: &#39;Welcome to learning React!&#39;}, {id: 2, title: &#39;Installation&#39;, content: &#39;You can install React from npm.&#39;} ]; ReactDOM.render( &lt;Blog posts={posts} /&gt;, document.getElementById(&#39;root&#39;) ); 7.vue 中渲染列表 Vue 中渲染列表使用的是特殊指令 v-for，其中也有 key 的相关用法 React 中采用的是 map() 方法遍历数组，然后渲染列表</div>
          <div class="index-post-meta">
            <a href="/blog/35.html/"> # 2020-12-16</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/34.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/34.html/">
            <h2>吐槽－－控制好自己的情绪</h2>
          </a>
          <div class="text">缘于一些小事，本想发在朋友圈里，但是熟人挺多，不方便发，就在博客里吐槽一下 一个正常的人际交往应该是互相传递出好的情绪，开心的事情，这样不但有利于两个人之间的交往，而且对个人对身心健康也是有帮助的 正面的情绪绝对有助于自己的身体和心理健康，反观整体郁郁寡欢，跟别人说自己多不顺，和别人吵架，不好的情绪就传达给另一个人了 并不是说不能找人倾述自己生活的不痛快和不开心，但是作为一个成年人了，应该要把握好那个感觉，不要真把别人当垃圾桶了，什么都往里倒，宣泄 情侣之间亦是如此，再好的关系，如果每天散发着各种压抑的情绪，爆发是迟早的事 家家有本难念的经 每个人都会有自己的烦心事，都能理解，毕竟生活确实很苦闷，但要学会自己调节自己。 我也会经常烦闷，但是我选择做一些爱好的事情来排遣掉自己的不好的情绪，并不会将这些传递给别人，所以我也算过的很开心吧 成年人，不就是要学会自己克制自己的缺点，希望每个人都能生活的很愉快！</div>
          <div class="index-post-meta">
            <a href="/blog/34.html/"> # 2020-12-13</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/33.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/33.html/">
            <h2>React 中的占位符 Fragment</h2>
          </a>
          <div class="text">在 React 项目中，render 方法只能有一个根元素，一般都是 &lt;div&gt; &lt;div/&gt; ，然后在里面写上我们的组件，渲染到浏览器一看，除了我们想要显示的组件，外面还套着一层 div，如果在写项目的时候，套了很多曾组件，那么每一层都会多出来一个父级元素 div，不美观，而且在调整样式的时候会有些麻烦 因此，React 提供了一个占位符 Fragment，写法是： // index.js import React, { Component,Fragment } from &#39;react&#39; export default class index extends Component { render() { return ( &lt;Fragment&gt; &lt;h2&gt;hello,wolrd&lt;/h2&gt; &lt;/Fragment&gt; ) } } 在引入 React 的时候，增加一个属性 Fragment，然后 render()方法下唯一的根元素我们用 &lt;Fragment&gt; &lt;/Fragment&gt; 来代替，这时候再看浏览器，就不会显示多余的标签了，直接显示 &lt;h2&gt;标签</div>
          <div class="index-post-meta">
            <a href="/blog/33.html/"> # 2020-12-12</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/32.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/32.html/">
            <h2>为什么不可变性在 React 中那么重要？</h2>
          </a>
          <div class="text">根据官网文档来解释，为什么不可变性的概念在 React 中非常重要的原因，一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据 React 文档 一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据 直接修改数据 var player = {score: 1, name: &#39;Jeff&#39;}; player.score = 2; // player 修改后的值为 {score: 2, name: &#39;Jeff&#39;} 新数据替换旧数据 var player = {score: 1, name: &#39;Jeff&#39;}; var newPlayer = Object.assign({}, player, {score: 2}); // player 的值没有改变，但是 newPlayer 的值是 {score: 2, name: &#39;Jeff&#39;} // 使用对象展开语法，就可以写成： // var newPlayer = {...player, score: 2}; 不直接修改（或改变底层数据）这种方式和前一种方式的结果是一样的，这种方式有以下几点好处： 简化复杂的功能 不可变性使得复杂的特性更容易实现。在后面的章节里，我们会实现一种叫做“时间旅行”的功能。“时间旅行”可以使我们回顾井字棋的历史步骤，并且可以“跳回”之前的步骤。这个功能并不是只有游戏才会用到——撤销和恢复功能在开发中是一个很常见的需求。不直接在数据上修改可以让我们追溯并复用游戏的历史记录 跟踪数据的改变 如果直接修改数据，那么就很难跟踪到数据的改变。跟踪数据的改变需要可变对象可以与改变之前的版本进行对比，这样整个对象树都需要被遍历一次 确定在 React 中何时重新渲染 不可变性最主要的优势在于它可以帮助我们在 React 中创建 pure components。我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染</div>
          <div class="index-post-meta">
            <a href="/blog/32.html/"> # 2020-12-02</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/31.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/31.html/">
            <h2>关于 react 的一份学习计划</h2>
          </a>
          <div class="text">有关 react 框架的学习计划，除了之前推荐的 react 开源作者写的学习建议，我还参考了阮一峰的 react 实例教程，写的通俗易懂，又难易并进，可以很快的掌握 react 的核心要点 之前说了，为了公司的项目决定学习 react 框架，看了一份 react.js 开源作者的一份学习计划，react 学习路径－－怎么学习 react？个人感觉还是不错，但是需要看的文档比较多且官方文档没有那么详细的讲解，只说个原理，有些难以参透。 在网络上浏览很久，发现大家对阮一峰的 react 教程风评不错，就去看了一下。 很适合刚接触 react 的人，可以很快的上手，再参照一下官方文档，理解上来就很深入且进一步了。 react 官方文档 阮一峰的网络日志－react 入门实例教程 阮一峰：我学习 React 时，就很苦恼。有的教程讨论一些细节问题，对入门没帮助；有的教程写得不错，但比较短，无助于看清全貌。我断断续续学了几个月，看过二十几篇教程，在这个过程中，将对自己有帮助的 Demo 都收集下来，做成了一个库React Demos。 下面，我就根据这个库，写一篇全面又易懂的 React 入门教程。你只需要跟着每一个 Demo 做一遍，就能初步掌握 React。当然，前提是你必须拥有基本 JavaScript 和 DOM 知识，但是你读完就会发现，React 所要求的预备知识真的很少。 github &raquo;&gt; ruanyf/react-demos 把这个库 clone 下来，然后跟着练习。 只要有一定的 javascript 基本，我觉得学习 react 并不困难，当然这只是入门，想要更深入的了解他，我觉得还有一段路程去经历，以后也会慢慢记录在 react 使用中遇到的问题，以及一些知识点的笔记。</div>
          <div class="index-post-meta">
            <a href="/blog/31.html/"> # 2020-11-27</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/30.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/30.html/">
            <h2>webpack 安装配置指令</h2>
          </a>
          <div class="text">进行重新加载编译。实际就是将浏览器不认识的语法编译成浏览器认识的语法。比如 less 编译成 css，ES6 语法 转成 ES5 等等。 减少 io 请求，通常我们在请求后，会返回一个 html 到浏览器。这时，我们如果打开控制台，就会发现在 html 页面通过 script,link 等标签引用的静态资源，浏览器会再次发出请求去获取这些资源。但是 webpack 的打包，将所有的静态资源都合并好了，减少了 io 请求。 # 安装webpack npm install --save-dev webpack # 安装webpack-cli依赖 npm install --save-dev webpack-cli # 创建新项目 mkdir demo # cd项目 cd demo # 初始化 npm init -y # 安装开发版本cli npm install webpack webpack-cli --save-dev 新建一个 html 文件和一个 js 文件，工程目录如下 demo |- package.json + |- index.html + |- /src + |- index.js src/index.js: function component() { var element = document.createElement(&#39;div&#39;); // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;); return element; } document.body.appendChild(component()); index.html: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;起步&lt;/title&gt; &lt;script src=&#34;https://unpkg.com/lodash@4.16.6&#34;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&#34;./src/index.js&#34;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在 package.json 中： 删除&quot;main&quot;: &quot;index.js&quot;,添加&quot;private&quot;: true 调整工程目录： demo |- package.json + |- /dist + |- index.html - |- index.html |- /src |- index.js 要在index.js中打包lodash依赖，我们需要在本地安装 library，终端输入指令： npm install --save lodash 然后调整index.js内容 // 添加一行代码 import _ from &#39;lodash&#39;; 在dist/index.html中可以把引入的外部文件lodash删去 删去&lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt; 添加&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; 执行终端： npx webpack 即可在dist中打包生成需要的main.js文件 还可以手动配置文件，在根目录下新建一个webpack.config.js文件 const path = require(&#39;path&#39;); module.exports = { // 这里放着需要打包的文件，如果多个文件，用数组形式写 entry: &#39;./src/index.js&#39;, output: { // 这里是打包生成的文件名，还可以手动修改 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } }; 考虑到用 CLI 这种方式来运行本地的 webpack 不是特别方便，我们可以设置一个快捷方式， 在package.json中的&quot;scripts&quot;新增 &#34;build&#34;: &#34;webpack&#34; 这样就可以使用npm run build指令代替之前的npx了 把之前dist文件夹里面的js文件删去，然后重新打包 npm run build 看一下工程目录 demo |- package.json |- webpack.config.js |- /dist |- bundle.js |- index.html |- /src |- index.js |- /node_modules 没问题，成功打包，浏览器也正常显示 在 js 文件中import了一个 css 文件，需要在配置中安装并添加style-loaader和css-loader npm install --save-dev style-loader css-loader webpack.config.js: const path = require(&#39;path&#39;); module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, // 添加的内容 module: { rules: [ { test: /\.css$/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] } ] } }; 然后在 js 模块中： import &#39;./style.css&#39; npm run build就可以自动解析打包啦 加载图片 下载安装file-loader npm install --save-dev file-loader webpack.config.js: module: { rules: [ { test: /\.css$/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] },{ test: /\.(png|svg|jpg|gif)$/, use: [ &#39;file-loader&#39; ] } ] } 加载字体 webpack 加载字体资源 记载数据资源 此外，可加载的有用资源还有数据，json文件，CSV，TSV，XML等，实际上，json是内置的，可以直接import data from './data.json'引入 但是CSV，TSV，XML不可以，需要配置一下依赖 终端下载安装： npm install --save-dev csv-loader xml-loader webpack.config.js: { test: /\.(csv|tsv)$/, use: [ &#39;csv-loader&#39; ] }, { test: /\.xml$/, use: [ &#39;xml-loader&#39; ] } 在src目录下添加一个 json 文件data.json 然后在index.js中引入： import data from &#39;./data.json&#39;</div>
          <div class="index-post-meta">
            <a href="/blog/30.html/"> # 2020-11-26</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      

      



















<div class="page">
  
  <a href="/page/26/" class="prev">上一页</a>
  

  
  <a href="/page/28/" class="next">下一页</a>
  


</div>



    </div>

    <footer id="foot">
  <p>© 2020 - 2024 Powered by
    <a href="https://github.com/dlzmoe/blog" target="_blank">Github</a>
    / <a href="/index.xml" target="_blank">RSS</a>
  </p>
</footer>

<script src="/js/main.js"></script>
<script defer src="https://cn.vercount.one/js"></script>
  </section>

  <script>
    const time = "2020-06-14";
    var now = new Date();
    var end = new Date(time);
    var diff = Math.abs(now - end);
    var days = Math.ceil(diff / (1000 * 60 * 60 * 24));
    $('#days').html(days);
  </script>
</body>

</html>