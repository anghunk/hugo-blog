<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.123.6">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/" />
<link rel="canonical" href="https://zishu.me/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "",
"name" : "子舒的博客",
"headline" : "子舒的博客",
"description" : "",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2024",
"datePublished": "2024-08-29 00:00:00 \u002b0000 UTC",
"dateModified" : "2024-08-29 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/",
"keywords" : [  ]
}
</script><title>子舒的博客</title>
<meta property="og:title" content="子舒的博客" />
<meta property="og:type" content="website" />
<meta property="og:description" content="" />
<meta name="description" content="" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />


<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>























































































































































































































































































































































































































































































































































































































































































































































































<body id="container">
  <meter id="isread" max="100" value="0"></meter>
<script>
  window.addEventListener('scroll', function () {
    var scrolled = window.scrollY;
    var totalHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percentage = (scrolled / totalHeight) * 100;
    $('#isread').attr('value', percentage)
  });
</script>


<div id="head" class="site-index">
  <a id="logo" href="/">
    <img src="https://imgurl.zishu.me/author.webp">
  </a>
  <div id="site-title">
    <a href="/">子舒的博客</a>
  </div>
  <ul id="menu">
    
    <li><a href="/categories/%e6%8a%80%e6%9c%af/">技术</a></li>
    
    <li><a href="/categories/%e9%9a%8f%e7%ac%94/">随笔</a></li>
    
    <li><a href="/categories/weekly/">周刊</a></li>
    
    <li><a href="/message/">留言</a></li>
    
    <li><a href="/about/">关于</a></li>
    
    <li><a href="/index.xml" target="_blank">订阅</a></li>
  </ul>
</div>

  <section id="body">
    <h2 id="body-title">📓 Articles</h2>

    <div id="body-in">

      <div class="index-post index-post-content-long">
        <p class="text">欢迎来到我的博客，已经运行了 <span id="days"></span> 天，有 <span id="busuanzi_value_site_pv">...</span>
          位小伙伴逛过，写了 270 篇文章，共 180887 字。</p>
      </div>

      
      
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/28.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/28.html/">
            <h2>vue 学习笔记 (2)－－vue 实例和模板语法</h2>
          </a>
          <div class="text">一、vue 实例 1.创建 vue 实例 一个 vue 实例应该通过new Vue来创建根实例，所有的 vue 组件其实都是 vue 实例 var vm = new Vue({ ... }) 当一个实例被创建时，data对象中的 property 都被加入到 vue 的响应式系统中，当值发生改变时，试图也会改变 var data = {a: 1} var vm = new Vue({ data: data }) 此时在控制台输入vm.a == data.a会返回 true，变量data已经被赋给vue实例中的data对象了 同时，对两个对象的数据进行操作改变也会影响到另一个 vm.a = 2 // data.a = 2 data.a = 3 // vm.a = 3 当数据改变时，视图也会重新渲染，如果在 vue 实例被创建后，又添加了一个新的 property，则不会被加入到响应式系统中 如果一开始就知道后面会添加一个 property，但是一开始不存在或为空，需要设置一些初始值 data: { newTodoText: &#39;&#39;, visitCount: 0, hideCompletedTods: fasle, todos: [], error: null } 使用 Object.freeze() 方法的时候，无法修改数据引起视图变化 Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。 &lt;div id=&#34;app&#34;&gt;{{message}}&lt;/div&gt; &lt;script&gt; var data = {message: &#39;hello,wolrd&#39;} Object.freeze(data) var vm = new Vue({ el: &#39;#app&#39;, data: data }) &lt;/script&gt; 在控制台改变vm.message的值会直接报错，因为 data 对象已经被冻结了，不可改变 vm.$data 代表 vue 实例观察的数据对象 console.log(vm.$data) // 返回数据对象的数组形式 var data = { a: 1 } var vm = new Vue({ el: &#39;#app&#39;, data: data }) vm.$data === data // true vm.$el === document.getElementById(&#39;app&#39;) // true 2.生命周期函数 每个实例在被创建的时候，都要经历一些初始化过程，比如：设置数据监听，编译模板，将实例挂载到 dom，更新 dom 等 在这个过程中会运行一些叫做生命周期的钩子函数，可以在不同阶段添加自己需要的代码 比如created钩子可以用来表示一个实例被创建之后执行的代码 new Vue({ data: { a: 1 }, created: function () { console.log(&#39;a is: &#39; + this.a) } }) // &#34;a is: 1&#34; this用来指向 vm 实例 但是不要在 property 或者回调上使用箭头函数，created: () =&gt; console.log(this.a)，因为箭头函数没有this的概念，他会把this当作变量一直向上级作用域查找，经常产生Uncaught TypeError: Cannot read property of undefined或Uncaught TypeError: this.myMethod is not a function之类的报错 二、模板语法 1.插值 最简单的就是 &lt;div id=&#34;app&#34;&gt;{{message}}&lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,world&#39; } }) &lt;/script&gt; &lt;/script&gt; 。。。 下面这段代码给input绑定了一个disabled属性，但是通过ok的真伪来控制属性是否渲染 当ok为fasle,null,undefined值时，属性都不会被渲染，有点类似于v-if，但是这种写法只是针对属性 &lt;div id=&#34;app&#34;&gt; &lt;input type=&#34;text&#34; v-bind:disabled=&#34;ok&#34;&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39;, ok: false } }) &lt;/script&gt; 在模板语法中还可以使用 javascript 表达式 &lt;div id=&#34;app&#34;&gt; &lt;div&gt;{{number + 1}}&lt;/div&gt; &lt;div v-bind:id=&#34;&#39;list-&#39; + id&#34;&gt;&lt;/div&gt; &lt;div&gt;{{message.split(&#39;&#39;).reverse().join(&#39;&#39;)}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { number: 2, id: &#39;li&#39;, message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; 每个模板只能包含一个 javascript 表达式，如果有多个，则不会生效 &lt;!-- 这是语句，不是表达式 --&gt; {{ var a = 1 }} &lt;!-- 流控制也不会生效，请使用三元表达式 --&gt; {{ if (ok) { return message } }} 2.指令 参数 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind指令可以用于响应式地更新 HTML attribute： &lt;div id=&#34;app&#34;&gt; &lt;a v-bind:href=&#34;url&#34;&gt;百度&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { url: &#39;https://www.baidu.com&#39; } }) &lt;/script&gt; 在这里href是参数，告知v-bind指令将该元素的hrefattribute 与表达式url的值绑定 另一个例子是v-on指令，它用于监听 dom 事件 &lt;a v-on:click=&#34;doSomething&#34;&gt;...&lt;/a&gt; 动态参数 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数 &lt;!--注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。--&gt; &lt;a v-bind:[attributeName]=&#34;url&#34;&gt;...&lt;/a&gt; 这里的attributeName会被作为一个 javascript 表达式进行动态求值，最终结果被作为参数来使用 比如：vue 实例中有一个attributeName属性其值为href，则这个绑定将等价于v-bind:href &lt;a v-bind:href=&#34;url&gt;...&lt;/a&gt; 也可以使用动态的事件名绑定监听函数 &lt;a v-on:[eventName]=&#34;doSomething&#34;&gt; ... &lt;/a&gt; 如果eventName值为click，则该绑定等价于v-on:click=&quot;doSomething&quot;，一个鼠标点击事件 对动态参数的值的约束 动态参数预期会求出一个字符串，异常情况下值为null，这个特殊的null值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 对动态参数表达式的约束 动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的，例如： &lt;!-- 这会触发一个编译警告 --&gt; &lt;a v-bind:[&#39;foo&#39; + bar]=&#34;value&#34;&gt; ... &lt;/a&gt; 因此，尽量不要使用空格和引号的表达式，或者采用计算属性来替代这种复杂表达式 在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写 修饰符 修饰符是以.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，例如，.prevent修饰符告诉v-on指令对于触发的事件调用event.preentDefault() &lt;form v-on:submit.prevent=&#34;onSubmit&#34;&gt;...&lt;/form&gt; 3.缩写 v-前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v-前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v-前缀也变得没那么重要了。因此，Vue 为v-bind和v-on这两个最常用的指令，提供了特定简写 v-bind &lt;!-- 完整语法 --&gt; &lt;a v-bind:href=&#34;url&#34;&gt;...&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a :href=&#34;url&#34;&gt;...&lt;/a&gt; &lt;!-- 动态参数的缩写 (2.6.0+) --&gt; &lt;a :[key]=&#34;url&#34;&gt; ... &lt;/a&gt; v-on &lt;!-- 完整语法 --&gt; &lt;a v-on:click=&#34;doSomething&#34;&gt;...&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a @click=&#34;doSomething&#34;&gt;...&lt;/a&gt; &lt;!-- 动态参数的缩写 (2.6.0+) --&gt; &lt;a @[event]=&#34;doSomething&#34;&gt; ... &lt;/a&gt; 它们看起来可能与普通的 HTML 略有不同，但:与@对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</div>
          <div class="index-post-meta">
            <a href="/blog/28.html/"> # 2020-11-24</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/27.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/27.html/">
            <h2>vue 学习笔记 (1)－－什么是 vue?</h2>
          </a>
          <div class="text">一、什么是 vue? 练习时使用，最新版本 &lt;script src=&#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&#34;&gt;&lt;/script&gt; 生产时使用，明确版本号的版本，避免造成不可预见的问题 &lt;script src=&#34;https://cdn.jsdelivr.net/npm/vue@2.6.12&#34;&gt;&lt;/script&gt; hello world &lt;div id=&#34;app&#34;&gt; {{message}} &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,world&#39; } }) &lt;/script&gt; 1.v-指令 v-bind－－绑定属性 &lt;div id=&#34;app-2&#34;&gt; &lt;span v-bind:title=&#34;message&#34;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#39;#app&#39;, data: { message: &#39;页面加载于 &#39; + new Date().toLocaleString() } }) &lt;/script&gt; v-bind是 vue 特有的提供的属性，他会在 dom 上应用一个响应式的操作 打开 console，输入app.message = &quot;hello&quot;，页面会改变内容只显示hello 又或者输入app.message = false，内容会直接不显示 vue 官网例子： &lt;!-- 绑定一个 attribute --&gt; &lt;img v-bind:src=&#34;imageSrc&#34;&gt; &lt;!-- 动态 attribute 名 (2.6.0+) --&gt; &lt;button v-bind:[key]=&#34;value&#34;&gt;&lt;/button&gt; &lt;!-- 缩写 --&gt; &lt;img :src=&#34;imageSrc&#34;&gt; &lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt; &lt;button :[key]=&#34;value&#34;&gt;&lt;/button&gt; &lt;!-- 内联字符串拼接 --&gt; &lt;img :src=&#34;&#39;/path/to/images/&#39; + fileName&#34;&gt; &lt;!-- class 绑定 --&gt; &lt;div :class=&#34;{ red: isRed }&#34;&gt;&lt;/div&gt; &lt;div :class=&#34;[classA, classB]&#34;&gt;&lt;/div&gt; &lt;div :class=&#34;[classA, { classB: isB, classC: isC }]&#34;&gt; &lt;!-- style 绑定 --&gt; &lt;div :style=&#34;{ fontSize: size + &#39;px&#39; }&#34;&gt;&lt;/div&gt; &lt;div :style=&#34;[styleObjectA, styleObjectB]&#34;&gt;&lt;/div&gt; &lt;!-- 绑定一个全是 attribute 的对象 --&gt; &lt;div v-bind=&#34;{ id: someProp, &#39;other-attr&#39;: otherProp }&#34;&gt;&lt;/div&gt; &lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt; &lt;div v-bind:text-content.prop=&#34;text&#34;&gt;&lt;/div&gt; &lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt; &lt;my-component :prop=&#34;someThing&#34;&gt;&lt;/my-component&gt; &lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt; &lt;child-component v-bind=&#34;$props&#34;&gt;&lt;/child-component&gt; &lt;!-- XLink --&gt; &lt;svg&gt;&lt;a :xlink:special=&#34;foo&#34;&gt;&lt;/a&gt;&lt;/svg&gt; v-if－－控制元素的显示隐藏 刚才写了，通过app.message = false，可以让message代表的内容处于隐藏状态，但是控制的只能是通过v-for引入的内容，无法直接让元素隐藏 其实，vue 中还有一个专门控制元素显示隐藏的指令－－v-if &lt;div id=&#34;app&#34;&gt; &lt;span v-if=&#34;show&#34;&gt; {{message}} &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,world&#39;, show: true } }) &lt;/script&gt; 给元素绑定一个指令v-if = &quot;show&quot;，然后在 data 中控制show的布尔值，true 显示，false 隐藏 同时还有这个功能的指令v-show，根据表达式之真假值，切换元素的display CSS property，也是通过绑定的布尔值来显示隐藏 但是v-if和v-show有些区别 (1) v-if 是控制元素是否渲染最终控制元素的显示隐藏，适用于切换频率低的情况 (2) v-show 不管显示隐藏都渲染，然后通过布尔值绑定display: none属性，适用于切换频率高的情况 注意：v-show不支持&lt;tempalte&gt;元素，也不支持v-else 搭配用法 v-else和v-else-if 可以通过使用v-else达到v-if的效果，必须和v-if搭配使用，比如： &lt;div v-if=&#34;1&gt;2&#34;&gt; hello &lt;/div&gt; &lt;div v-else&gt; hi &lt;/div&gt; 如果v-if不成立，执行v-else，也就是显示 v-else 里面的内容 是不是有点 javascript 里面if函数的感觉了 v-else-if用法大致一样，必须和v-if和v-else搭配使用 v-for－－遍历数组并显示到页面上 v-for算是 vue 的核心指令之一了把，主要是渲染一个项目列表的 &lt;div id=&#34;app&#34;&gt; &lt;div v-for=&#34;item in list&#34;&gt;{{item.message}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { list: [ {message: &#39;html&#39;}, {message: &#39;css&#39;} ] } }) &lt;/script&gt; 可以直接把列表数据循环输出 并且在控制台中通过push()还能添加新的列表项 app.list.push({message: &#34;js&#34;}) vue 对数据操作，就是这么神奇 不推荐v-for和v-if同时使用，因为v-for拥有更高的优先级 v-on－－绑定事件监听器 即绑定事件，通过v-on给 div 绑定了一个点击事件，注意，在reverseMessage方法中，我们更新了应用的状态，但是吗诶呀触碰到 dom，直接通过 vue 来进行处理，编写代码时只需要关注逻辑层即可 v-on:click=&quot;messagenone&quot;，然后在methods里面写上事件方法 &lt;div id=&#34;app&#34;&gt; &lt;div v-on:click=&#34;messagenone&#34; id=&#34;demo&#34;&gt;{{message}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,wolrd&#39; }, methods: { messagenone: function() { var demo = document.getElementById(&#39;demo&#39;); demo.innerHTML = &#39;&#39; } } }) &lt;/script&gt; v-model－－数据的双向绑定 vue 还提供了v-model指令，它能轻松实现表单输入和应用状态之间的双向绑定 可使用场景：标签 input, select, textarea 和 components &lt;div id=&#34;app&#34;&gt; &lt;div&gt;{{message}}&lt;/div&gt; &lt;input type=&#34;text&#34; v-model=&#34;message&#34;&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el: &#34;#app&#34;, data: { message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; v-text 更新元素的内容 &lt;div id=&#34;app&#34;&gt; &lt;div v-text=&#34;message&#34;&gt;&lt;/div&gt; &lt;div&gt;{{message}}&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; 上面的 div 和下面的 div 内容跟随一致变化 v-html－－更新元素的 innerHTML 不建议使用，在网站上动态渲染 html 是非常危险的，容易导致XXS 攻击，不能用在用户提交的内容上，如果必须使用 v-html，可以考虑通过使用组件来代替 v-pre 跳过绑定的元素和他的子元素的编译，直接显示原始内容 跳过没有指令的节点不进行编译，直接显示内容，会加快页面的响应 v-cloak 在编译没有编译完成之前，模板处于的状态 &lt;style&gt;v-cloak] { display: none; }&lt;/style&gt; &lt;div v-cloak&gt; {{message}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39; } }) &lt;/script&gt; 上述代码表示的含义是，如果网络不好，{{message}}模板代表的hello,world还没有编译成功，此时{{message}}处于隐藏状态，当编译完成，页面直接显示hello,world v-once－－一次性渲染 绑定该指令的元素及其子元素只会进行一次渲染，之后页面的第二次渲染会将其视为静态资源并跳过，可以用来优化性能 &lt;div id=&#34;app&#34;&gt; &lt;span v-once&gt;{{message}}&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { message: &#39;hello,wolrd&#39;, } }) &lt;/script&gt; 使用场景：表单提交。可防止用户在请求未及时响应时，多次提交~ 2.组件化构建应用 组件化也是 vue 的核心机制之一，它允许我们使用小型，可复用的组件来构建大型应用 在 vue 里，一个组件本质上是一个拥有预定义选项的一个 vue 实例。在 vue 中注册组件很简单 // 定义名为 todo-item 的新组件 Vue.component(&#39;todo-item&#39;, { template: &#39;&lt;li&gt;这是个待办项&lt;/li&gt;&#39; }) var app = new Vue(...) 现在可以用它构建另一个组件模板 &lt;ol&gt; &lt;!-- 创建一个 todo-item 组件的实例 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt; &lt;/ol&gt; 但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个props Vue.component(&#39;todo-item&#39;, { // todo-item 组件现在接受一个 // &#34;props&#34;，类似于一个自定义 attribute。 // 这个 props 名为 todo。 props: [&#39;todo&#39;], template: &#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39; }) 现在，我们可以使用v-bind指令将待办项传到循环输出的每个组件中 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的，我们也需要为每个组件提供一个key &lt;div id=&#34;app-7&#34;&gt; &lt;ol&gt; &lt;todo-item v-for=&#34;item in groceryList&#34; v-bind:todo=&#34;item&#34; v-bind:key=&#34;item.id&#34; &gt;&lt;/todo-item&gt; &lt;/ol&gt; &lt;/div&gt; Vue.component(&#39;todo-item&#39;, { props: [&#39;todo&#39;], template: &#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39; }) var app7 = new Vue({ el: &#39;#app-7&#39;, data: { groceryList: [ { id: 0, text: &#39;蔬菜&#39; }, { id: 1, text: &#39;奶酪&#39; }, { id: 2, text: &#39;随便其它什么人吃的东西&#39; } ] } }) 尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过prop接口与父单元进行了良好的解耦。我们现在可以进一步改进 组件，提供更为复杂的模板和逻辑，而不会影响到父单元 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理 &lt;div id=&#34;app&#34;&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt; &lt;/div&gt;</div>
          <div class="index-post-meta">
            <a href="/blog/27.html/"> # 2020-11-23</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/25.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/25.html/">
            <h2>对象，类和接口之间的关系</h2>
          </a>
          <div class="text">类是对的类型，类是具有相同属性和方法的一组集合，一个类可以对应多个对象，对象通过他们公开的方法来定义他们与外界的交互行为，而方法就形成了与外界交互的接口 类，对象和接口 1.类和对象 区别： 对象是类的一个实例。就比如一个人，他有具体的属性，身高，体重，姓名等状态，跑步，跳舞等行为 类是抽象的概念，代表一类事物的模版。对一类对象的行为和状态进行描述，抽离出其共性，形成类 关系： 类就是对事物的一种描述，对象是具体存在的一个实例 类是对的类型，类是具有相同属性和方法的一组集合，一个类可以对应多个对象 2.什么是接口？ 对象通过他们公开的方法来定义他们与外界的交互行为，而方法就形成了与外界交互的接口 更深层次的含义是：使定义和实现分离开，他是交互的具体实现的抽象化 接口是面向对象编程的基础，它是一组包含了函数方法的数据结构，他是一个比类更抽象化的东西 可以这么说，类是对象的抽象化，接口是类的抽象化 比如生活中的接口，机顶盒，人们利用它来实现收看不同频道和信号的节目，它犹如对不同类型的信息进行集合和封装的设备，最后把各种不同类型的信息转换为电视能够识别的信息。 在编程语言中的接口，实际上是不同类的封装并提供统一的外部联系通道，这样其他对象就可以利用接口来调用不同类的成员了 接口和类，实际上都是相同的数据结构 在接口中，可以声明属性，方法，事件，类型，但是不能声明变量，也就是说，接口只能定义成员，不能给成员赋值 使用接口的好处，提高代码灵活性，降低对象之间的耦合度，在实际项目中非常有用</div>
          <div class="index-post-meta">
            <a href="/blog/25.html/"> # 2020-11-21</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/24.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/24.html/">
            <h2>vue 使用 cli 脚手架构建项目工程</h2>
          </a>
          <div class="text">vue 使用 cli 脚手架构建项目工程，执行的命令以及遇到的相关的问题 1.下载安装 node 测试一下是否成功安装， $ node -v // 返回下载的版本号 2.安装 webpack 环境 $ npm install webpack -g // 如果失败，可能是因为用户没有权限 // 使用下面这种，管理员权限 $ sudo npm install webpack -g 如果返回版本号代表成功，如果没有，则需要输入下面的命令 $ npm install webpack webpack-cli -g webpack 4.X 开始，需要安装 webpack-cli 依赖 3.全局安装 vue-cli $ npm install --global vue-cli // 如果失败，使用sudo $ sudo npm install --global vue-cli 安装完成之后，输入 $ vue -V 如果返会版本号，说明安装成功 4.构建项目 前面那些命令执行完之后，就可以构建 ci 项目了，找到我们想要放置项目的文件夹，进入终端，cd 到这个文件夹 输入命令： $ vue init webpack vuedemo // 名字自己根据要求起,vuedemo Project name (vuedomo)： &mdash;&ndash;项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错 Sorry, name can no longer contain capital letters） Project description (A Vue.js project)： &mdash;-项目描述，也可直接点击回车，使用默认名字 Author ()： &mdash;-作者，输入你的大名 Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了 Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n) 是否安装 vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n) 是否使用 ESLint 管理代码，ESLint 是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。 接下来也是选择题 Pick an ESLint preset (Use arrow keys) 选择一个 ESLint 预设，编写 vue 项目时的代码风格，直接 y 回车 Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试，我选择安装 y 回车 Setup e2e tests with Nightwatch(Y/n)? 是否安装 e2e 测试，我选择安装 y 回车 然后就是缓慢的构建过程，等到构建完成，cd 进入构建的项目 $ cd vuedemo 然后安装需要的依赖 $ npm install 5.运行项目 运行命令，看看是否能够成功运行项目 $ npm run dev 根据提示，浏览器输入http://localhost:8080 如果端口打不开，肯能是因为被占用了，需要修改配置文件，config &gt; index.js 查看项目工程目录 6.其他 一些其他相关的指令 $ npm run build // 项目完成之后打包 打包完成之后，会在根目录下生成一个 dist 文件夹，需要修改配置文件的路径，可以在本地查看 项目上线发布，直接上传 dist 到服务器即可</div>
          <div class="index-post-meta">
            <a href="/blog/24.html/"> # 2020-11-20</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/23.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/23.html/">
            <h2>react 学习路径－－怎么学习 react？</h2>
          </a>
          <div class="text">转载于：https://github.com/petehunt/react-howto，react 开源作者对于 react 框架的一个学习路径的建议，个人感觉还是相当不错的学习路线 如何学习 React? 如果你是一个 React (或者前端) 新手，出于以下的原因，你可能会对这个生态圈感到困惑： React 的目标群体历来是喜欢尝试新事物的开发者和前端专家。 Facebook 开源的内容是应用在他们的实际应用中，因此他们没有关注那些比 Facebook 小的工程需求。 现有的 React 指引水平参差不齐。 在本文中，我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础。 为什么要听我的？ 关于 React, 现在已经有大量的相互冲突的建议了，为什么要听我的？ 因为我是在 Facebook 构建并开源 React 的最初成员之一。现在我离开了 Facebook 并加入了一家初创公司，所以我也不会站在 Facebook 的立场上来表态。 如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的，你需要对整个技术栈有足够深入的理解，才能建造你的应用。为什么 React 生态圈的工具似乎总让人感觉压力山大呢，因为它总是以错误的顺序被解释： 你应该按照以下的顺序进行学习，而不是跳着学或者同时学习: React npm JavaScript“打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候，才进入下一步的学习。 另外，在 React 社区中，有一些前沿主题是经常被提及到的，以下的这些主题很有意思，但也很难弄懂，所以它们远没有上面的主题流行，大多数应用也不需要用到这些。 内联样式 服务器端渲染 Immutable.js Relay, Falcor 等 学习 React 本身 有一种常见的误解是：你需要花费大量时间在配置工具上，然后才开始学习 React. 在官方文档里，你可以找到 copy-paste HTML template. 只需要保存为 .html 文件，你就可以马上开始学习了。这个步骤不需要任何工具，你也无需额外学习工具使用，直到你能熟练掌握 React 基础。 我依然觉得，学习 React 最简单的方法是通过官方教程 the official tutorial. 学习 npm npm 是 Node.js 包管理工具，也是前端工程师和设计师分享 JavaScript 代码最流行的方式。它包含了名为 CommonJS 的模块系统，让你可以安装 JavaScript 写的命令行工具。作为背景知识，可以阅读 这篇文章 了解 CommonJS 对于浏览器的重要性，阅读 CommonJS Spec Wiki 了解关于 CommonJS API 的更多内容 在 React 生态圈中，大部分可重用的组件、库和工具遵循 CommonJS 模块规范，可通过 npm 来安装。 学习 JavaScript 打包工具 出于若干技术原因，CommonJS 模块 (也就是 npm 里的所有内容) 不能直接用到浏览器。你需要一个 JavaScript“打包工具 (bundler)”来把这些模块打包成 .js 文件，使你可以在网页中通过 &lt;script&gt; 标签引入它们。 JavaScript 打包工具包括 webpack 和 browserify. 它们都是好的选择，但我个人更喜欢 webpack , 因为它有许多功能简化大型应用开发。鉴于 webpack 文档可能令人感到困惑，我也写了两篇文章：plug-and-play template for getting started 和针对更复杂用例的 how-to guide for webpack. 要记住的一点：CommonJS 使用了 require() 函数来引入模块，因此许多人对此感到疑惑，并认为需要导入 require.js 到工程里。出于若干技术原因，我建议你避免使用 require.js. 它在 React 生态圈并不流行。 学习 ES6 在 JSX (你会在 React tutorial 中学习到) 以外，你可能会注意到 React 例子中一些有趣的语法。这被称为 ECMAScript6, 是 JavaScript 的最新版本。由于 ES6 很新，你可能还没学习到，浏览器也可能尚未兼容，但别担心，通过合适的配置，你的打包工具会为你自动转换成兼容代码。 如果你只想要使用 React 来把事情做完，你可以跳过 ES6 的学习， 或者留到以后再学习。 你可能会看到一些讨论说更适合用 ES6 的 class 来创建 React 组件。这并不是真的，大多数人 (包括 Facebook) 用的还是 React.createClass(). 学习路由 (routing) “单页面应用”是时下的技术热点。当网页加载完成，用户点击链接或者按钮的时候，JavaScript 会更新页面和改变地址栏，但网页不会刷新。地址栏的管理就是通过 路由 (router) 来完成的。 目前 React 生态圈最受欢迎的路由解决方案是 react-router. 如果你正在创建一个单页面应用，有什么理由不去使用它呢？ 如果你创建的并非单页面应用，请不要使用路由。 无论如何，大部分项目都是从大型应用中的小组件开始的。 学习内联样式 在 React 出现之前，很多人通过像 SASS 这样的预处理器来重用复杂的 CSS 样式表。鉴于 React 使开发可重用组件变得容易，你的样式表可以变得没那么复杂了。社区中许多人 (包括我) 正尝试完全抛弃样式表。 由于一些原因，其实这是个相当疯狂的主意。这让媒体查询 (media quries) 更加困难了，而且这种技术可能有性能上的局限性。当你开始用 React 的时候，只要用你平常使用的方法去写就好了。 一旦你找到了用 React 开发的感觉，你就可以关注那些可作为替代的技术了。其中一种流行技术是 BEM. 我建议你逐渐停用 CSS 预处理器，因为 React 给了你一种更强大的方式去重用样式 (通过重用组件), 并且 JavaScript 打包工具可以为你生成更高效的样式表 (我曾经在 OSCON 上发表过关于这个的演讲). 说了这么多，总之 React 就像其他 JavaScript 库一样，可以和 CSS 预处理器很好地配合工作。 另一种可选项是 CSS 模块, 更具体地说，是 react-css-modules. 虽然有了这些 CSS 模块，你还是写 CSS (或者是 SASS/LESS/Stylus), 但你可以像处理 React 中的内联样式那样管理和组织 CSS 文件。你也不需要担心用到 BEM 那样的方法学去管理类名，因为模块系统在底层已经帮你处理好了。 学习服务器端渲染 服务器端渲染经常被称为 &ldquo;通用应用&rdquo; 或 &ldquo;同构应用&rdquo;. 这意味着你可以用 React 组件在服务器端渲染出静态 HTML. 这样做可以提高初始化加载的性能，因为用户不用等到 JS 下载完才看到初始界面，并且 React 可以重用服务器端渲染出的 HTML, 无需客户端重新生成。 如果你发现首屏渲染速度过慢，或者想提高网站在搜索引擎的排行，你就需要服务器端渲染了。尽管 Google 现在也会索引客户端渲染的内容，但截至 2016 年 1 月，这样做仍被证实会对排行有负面影响，这可能是由于客户端渲染的性能问题所造成的。 服务器端渲染还需要许多工具的辅助，因为显然 React 组件不是在考虑服务器端渲染的情况下写出来的，你应该先构建你的应用，之后再关心服务器端渲染的问题。不用担心，你不需要重写所有组件去支持它。 学习 Flux 你可能听过 Flux, 不过关于 Flux 有大量的错误资讯。 许多人一坐下来刚开始构建应用，就认为需要用 Flux 来定义他们的数据模型。这样采用 Flux 是不对的，Flux 应该在大量组件被建立完成以后才被引入。 React 组件之间存在层级关系。在很多时候，你的数据模型也跟随这种层级。这种情况下，Flux 不会给你很大帮助。但有些时候，你的数据模型没有层次，当你的 React 组件开始接受没有关联的 props 的时候，或者当小部分组件开始变得复杂的时候，你才可能需要看看 Flux. 你会知道什么时候需要用 Flux. 如果你不确定是否需要用它，你就不需要它。 如果你决定使用 Flux, 现在最流行的、文档最全的 Flux 库是 Redux. 当然也有许多其他选择，你或者会有兴趣尝试使用它们，但我的建议是只需要用最流行的 Redux 就足够了。 学习 Immutable.js Immutable.js 提供了一系列的数据结构，以帮助解决构造 React 应用时的某些性能问题。这是一个很棒的库，你可能会在应用发展的过程里大量用到它，但直到你在意识到性能问题以前，它是完全不必要的。 学习 Relay, Falcor 等 这些技术可以帮你减少 AJAX 请求数，它们仍然是非常前沿的，所以如果你没有遇到过多 AJAX 请求的问题，就不需要用到 Relay 或者 Falcor.</div>
          <div class="index-post-meta">
            <a href="/blog/23.html/"> # 2020-11-19</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/22.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/22.html/">
            <h2>在 js 中运算不能随便把 value 属性定义成变量</h2>
          </a>
          <div class="text">在写一个小 demo 的时候，无意中发现定义变量的时候直接写入 value，会导致获取不到数据，或者获取的不是我们想要的内容，在 js 中运算不能随便把 value 属性定义成变量 先看一段代码 &lt;input type=&#34;text&#34;&#34; id=&#34;a&#34;&gt; &lt;span&gt;*&lt;/span&gt; &lt;input type=&#34;text&#34; id=&#34;b&#34;&gt; &lt;input type=&#34;button&#34; value=&#34;=&#34; onclick=&#34;beto()&#34;&gt; &lt;input type=&#34;text&#34; id=&#34;sub&#34; disabled&gt; &lt;script&gt; function beto() { var a = document.getElementById(&#39;a&#39;).value var b = document.getElementById(&#39;b&#39;).value var sub = document.getElementById(&#39;sub&#39;).value sub = a + b } &lt;/script&gt; 就这么一看，逻辑貌似没有问题，获取 a 和 b 的 value，乘法运算，然后输出 sub 但是放在浏览器运行的时候，发现完全没有反应 为什么呢？ （假装思考五分钟&hellip;） 因为 sub.value 不能直接定义在变量中 // 先定义 id 为 sub 的 input 框 var sub = document.getElementById(&#39;sub&#39;) // 然后在运算的时候在直接使用 sub.value sub.value = a * b 顺手放一个写 demo 时候用的简易计算器 &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;简易计算器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&#34;text&#34;&#34; id=&#34;a&#34;&gt; &lt;select id=&#34;c&#34;&gt; &lt;option value=&#34;+&#34;&gt;+&lt;/option&gt; &lt;option value=&#34;-&#34;&gt;-&lt;/option&gt; &lt;option value=&#34;*&#34;&gt;*&lt;/option&gt; &lt;option value=&#34;/&#34;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&#34;text&#34; id=&#34;b&#34;&gt; &lt;input type=&#34;button&#34; value=&#34;=&#34; onclick=&#34;beto()&#34;&gt; &lt;input type=&#34;text&#34; id=&#34;sub&#34; disabled&gt; &lt;script&gt; function beto() { var a = document.getElementById(&#39;a&#39;).value var b = document.getElementById(&#39;b&#39;).value var c = document.getElementById(&#39;c&#39;).value var sub = document.getElementById(&#39;sub&#39;) switch(c) { case &#34;+&#34;: sub.value = parseInt(a) + parseInt(b); break; case &#34;-&#34;: sub.value = parseInt(a) - parseInt(b); break; case &#34;*&#34;: sub.value = parseInt(a) * parseInt(b); break; case &#34;/&#34;: sub.value = parseInt(a) / parseInt(b); break; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</div>
          <div class="index-post-meta">
            <a href="/blog/22.html/"> # 2020-11-18</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/21.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/21.html/">
            <h2>事件监听函数，以及事件的捕获和冒泡机制</h2>
          </a>
          <div class="text">事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件，事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流 函数事件 事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件 事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为 DOM 事件流 true 是捕获，false 是冒泡，默认为冒泡事件 1.addEventListener()－－添加事件监听函数 给元素添加一个事件，假如有多个事件，不会覆盖，会依次执行 &lt;div id=&#34;demo&#34;&gt;dom&lt;/div&gt; &lt;script&gt; document.getElementById(&#39;demo&#39;).addEventListener(&#34;click&#34;, myfun) document.getElementById(&#39;demo&#39;).addEventListener(&#34;click&#34;, myfun1) function myfun() { console.log(&#39;事件监听函数&#39;) } function myfun1() { console.log(&#39;addEventListener&#39;) } &lt;/script&gt; 注意： 1.这里有一个细节，addEventListener() 里面有两个参数，第一个表示触发的条件，第二个表示触发的事件 正常情况下，第二个参数直接写函数名并且不加参数()，如果加了参数()则表示立即执行，不需要触发第一个参数要求的条件 2.在这里绑定事件的时候，事件名不能和定义的变量名一样，否则无效 2.removeEventListener()－－移除事件监听函数 下面这个 demo，当鼠标在 div 中移动的时候，出现随机数，点击按钮后，移除事件监听函数 &lt;!-- css --&gt; &lt;style&gt; #demo { width: 100px; height: 100px; border: 1px solid #000; } &lt;/style&gt; &lt;!-- html --&gt; &lt;div id=&#34;demo&#34;&gt;&lt;/div&gt; &lt;input type=&#34;button&#34; value=&#34;点击移除&#34; onclick=&#34;remove()&#34;&gt; &lt;div id=&#34;show&#34;&gt;&lt;/div&gt; &lt;!-- js --&gt; &lt;script&gt; document.getElementById(&#39;demo&#39;).addEventListener(&#34;mousemove&#34;, myfun) function myfun() { document.getElementById(&#39;show&#39;).innerHTML = Math.random() } function remove() { document.getElementById(&#39;demo&#39;).removeEventListener(&#34;mousemove&#34;, myfun) } &lt;/script&gt; 3.利用事件的捕获和冒泡做点事情 addEventListener() 和 removeEventListener() 其实拥有三个参数，刚才说过了，第一个表示触发条件，第二个表示触发事件，第三个参数正常情况下可以省略，但是要知道它代表的意思 用布尔值来表示，true 或者 false，默认是 false true 表示在捕获阶段调用事件处理程序 false 表示在冒泡阶段调用事件处理程序 根据图片可以看出，捕获阶段要先于冒泡阶段，因此，true 事件要先于 flase 事件触发，多个 true 事件按顺序触发，多个 false 事件，写在后面的先触发 结论：写在前面的 true 事件 &gt; 写在后面的 true 事件 &gt; 写在后面的 false 事件 &gt; 写在前面的 false 事件 因此，利用这个参数，可以控制同一个元素的不同事件触发的顺序 &lt;div id=&#34;out&#34;&gt; &lt;p&gt;最外面&lt;/p&gt; &lt;div id=&#34;middle&#34;&gt; &lt;div id=&#34;inner&#34;&gt;最里面&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 第一种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：inner-------middle------out out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},false); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第二种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out------middle-------inner out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},true); &lt;/script&gt; &lt;!-- 第三种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out------inner-------middle out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第四种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out-------middle------inner out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第五种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：middle-------inner------out out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},false); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},true); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},false); &lt;/script&gt; &lt;!-- 第六种情况 --&gt; &lt;script&gt; var out = document.getElementById(&#39;out&#39;); var middle = document.getElementById(&#39;middle&#39;); var inner = document.getElementById(&#39;inner&#39;); //点击 inner 时，触发顺序为：out-------inner------middle out.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最外面的&#34;);},true); middle.addEventListener(&#39;click&#39;,function(){alert(&#34;我是中间的&#34;);},false); inner.addEventListener(&#39;click&#39;,function(){alert(&#34;我是最里面的&#34;);},true); &lt;/script&gt; 4.事件处理程序 HTML 事件处理程序 &lt;button onclick=&#34;test()&#34;&gt;测试&lt;/button&gt; &lt;script&gt; function test() { alert(&#34;HTML 事件处理程序&#34;); } &lt;/script&gt; 1.优点：事件处理程序中的代码，能够访问全局作用域中的任何变量 2.缺点：时差问题、扩展的作用域链在不同浏览器中会导致不同结果、html 代码与 js 代码高度耦合 DOM0 级事件处理程序 &lt;button id=&#34;btn&#34;&gt;测试&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#34;btn&#34;); btn.onclick = function test() { alert(&#34;DOM0 级事件处理程序&#34;); } &lt;/script&gt; 1.优点：代码简单，浏览器兼容性好，解决了 html 代码和 js 代码的高度耦合问题 2.缺点：一个元素只能绑定一个事件处理函数，只会在事件冒泡中运行 DOM2 级事件处理程序 该级别的事件处理程序，运用的就是事件捕获和冒泡机制 &lt;button id=&#34;btn&#34;&gt;测试&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(&#34;btn&#34;); // 事件监听 btn.addEventListener(&#34;click&#34;, function() { alert(&#34;DOM2 级事件处理程序，我在捕获阶段执行&#34;); }, true); btn.addEventListener(&#34;click&#34;, function() { alert(&#34;DOM2 级事件处理程序，我在冒泡阶段执行&#34;); }, false); // 移除事件监听 var fun = function() { alert(&#34;我要被移除了&#34;); } btn.addEventListener(&#34;click&#34;, fun, false); btn.removeEventListener(&#34;click&#34;, fun, false); &lt;/script&gt; 1.优点：同时支持事件处理的捕获和冒泡阶段，并且一个元素可以绑定多个处理函数 2.缺点：IE 不支持</div>
          <div class="index-post-meta">
            <a href="/blog/21.html/"> # 2020-11-17</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/19.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/19.html/">
            <h2>getElementBy 系列和 querySelector 系列的区别</h2>
          </a>
          <div class="text">querySelector和querySelectorAll的用法和getElementBy大致一样，获取的时候带上符号，getElementBy 获取的是元素的动态集合，querySelector 获取的是元素的静态集合。 但是需要注意：getElementBy 系列和 querySelector 系列的区别 比如，我们写一个 for 循环，每次获取 li 标签的时候，ul 生成一个 li 子元素 &lt;ul id=&#34;ul&#34;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.getElementById(&#39;ul&#39;); var li = document.getElementsByTagName(&#39;li&#39;); for(var i = 0;i &lt; li.length; i++) { ul.appendChild(document.createElement(&#39;li&#39;)) }; console.log(li.length); // 陷入死循环 &lt;/script&gt; 用i &lt; li.length来进行判断时，会导致浏览器死循环，因为循环一次的时候，浏览器又重新获取 li 标签数组，每调用一次就会重新对文档进行查询，就会进入死循环 进行修改：把i &lt; li.length改成i &lt; 3，把 li 标签数组静态化，然后打印 conosle.log(li.length) // 6 重新用 querySelector 获取一遍元素 &lt;ul id=&#34;ul&#34;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector(&#39;ul&#39;); var li = document.querySelectorAll(&#39;li&#39;); for(var i = 0;i&lt;li.length;i++) { ul.appendChild(document.createElement(&#39;li&#39;)) }; console.log(li.length); // 输出对结果是原来的 li.length = 3，而不是增加后的 6 &lt;/script&gt; 静态集合体现在querySelectorAll('li')获取到 ul 里所有 li 后，不管后续再动态添加了多少 li，都是不会对其参数影响</div>
          <div class="index-post-meta">
            <a href="/blog/19.html/"> # 2020-11-16</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/18.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/18.html/">
            <h2>DOM－－文档对象模型</h2>
          </a>
          <div class="text">DOM 中文名文档对象模型，英文名 Document Object Model，我们简称为 DOM，是针对 html 和 xml 文档的一种 API，将 html 以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM 树，或者节点树，一样的概念 一、什么是 DOM？ DOM 中文名文档对象模型，英文名 Document Object Model，我们简称为 DOM，是针对 html 和 xml 文档的一种 API，将 html 以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM 树，或者节点树，一样的概念 js 通过 dom 节点，可以对文档的 html 标签，属性，css 样式，以及具体的内容做出修改，并对页面中的所有事件进行响应 二、节点树 1.节点类型 文档节点－－Document 标签节点－－Element 文本节点－－Text 注释节点－－Comment 属性节点－－Attr 2. 属性 节点类型－－nodeType 节点名称－－nodeName 节点值－－nodeValue 子节点－－childNodes 父节点－－parentNodes 上一个节点－－previousSibling 下一个节点－－nextSibling 第一个子节点－－firstChild 最后一个子节点－－lastChild 3.文档节点－－document (1) 获取 getElementById()－－通过 id 获取元素 &lt;div id=&#34;demo&#34;&gt;通过 id 获取元素&lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;); demo.onclick = function() { console.log(&#39;通过 id 获取元素&#39;) } &lt;/script&gt; &lt;!-- 点击 id 为 demo 的元素，控制台输出&#39;通过 id 获取元素&#39; --&gt; getElementsByName()－－通过 name 获取元素 &lt;input type=&#34;text&#34; name=&#34;int&#34; value=&#34;通过name获取元素1&#34;&gt; &lt;input type=&#34;text&#34; name=&#34;int&#34; value=&#34;通过name获取元素2&#34;&gt; &lt;script&gt; var int = document.getElementsByName(&#39;int&#39;); for(var i = 0;i &lt; int.length; i++) { console.log(int[i].value); } &lt;/script&gt; &lt;!-- 控制台输出 name 为 int 的元素的 value 值 --&gt; getElementsByTagName()－－通过标签名获取元素 &lt;div&gt;通过标签名获取元素 1&lt;/div&gt; &lt;div&gt;通过标签名获取元素 2&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName(&#39;div&#39;); for(var i = 0;i &lt; div.length; i++) { console.log(div[i].innerHTML) } &lt;/script&gt; &lt;!-- 控制台输出标签名为 div 的元素的文本内容 --&gt; getElementsByClassName()－－通过 class 获取元素 &lt;div class=&#34;demo&#34;&gt;通过 class 获取元素 1&lt;/div&gt; &lt;div class=&#34;demo&#34;&gt;通过 class 获取元素 2&lt;/div&gt; &lt;script&gt; var demo = document.getElementsByClassName(&#39;demo&#39;); for(var i = 0;i &lt; demo.length; i++) { console.log(demo[i].innerHTML) } &lt;/script&gt; &lt;!-- 控制台输出 class 为 demo 的元素的文本内容 --&gt; querySelector()－－通过选择器获取元素 querySelector() 括号里面要跟上符号，class就写.，id就写#，标签直接写标签名TagName &lt;div&gt;通过选择器获取标签名&lt;/div&gt; &lt;div class=&#34;div&#34;&gt;通过选择器获取 class&lt;/div&gt; &lt;div id=&#34;div&#34;&gt;通过选择器获取 id&lt;/div&gt; &lt;script&gt; var divtag = document.querySelector(&#39;div&#39;); var divclass = document.querySelector(&#39;.div&#39;); var divid = document.querySelector(&#39;#div&#39;); divtag.onclick = function() { console.log(&#39;通过选择器获取标签名&#39;) }; // 点击标签 div，控制台输出&#34;通过选择器获取标签名&#34; divclass.onclick = function() { console.log(&#39;通过选择器获取 class&#39;) }; // 点击 class 为 div，控制台输出&#34;通过选择器获取 class&#34; divid.onclick = function() { console.log(&#39;通过选择器获取 id&#39;) }; // 点击 id 为 div，控制台输出&#34;通过选择器获取 id&#34; &lt;/script&gt; querySelectorAll()－－通过选择器获取元素集合 获取的是一个数组集合 &lt;input type=&#34;text&#34; value=&#34;int1&#34;&gt; &lt;input type=&#34;text&#34; value=&#34;int2&#34;&gt; &lt;input type=&#34;text&#34; value=&#34;int3&#34;&gt; &lt;script&gt; var int = document.querySelectorAll(&#39;input&#39;) for(i = 0; i &lt; int.length; i++) { console.log(int[i].value) } &lt;/script&gt; &lt;!-- 浏览器依次打印出`int1`,`int2`,`int3` --&gt; (2) 创建 createElement()－－创建元素（标签）节点 &lt;ul id=&#34;ul&#34;&gt;&lt;/ul&gt; &lt;script&gt; var ul = document.getElementById(&#39;ul&#39;); ul.appendChild(document.createElement(&#39;li&#39;)) &lt;/script&gt; 可以看到，ul 下面已经生成了一个 li 标签 createTextNode()－－创建文本节点 &lt;ul id=&#34;ul&#34;&gt;&lt;/ul&gt; &lt;script&gt; var ul = document.getElementById(&#39;ul&#39;); var li = ul.appendChild(document.createElement(&#39;li&#39;)); var node = document.createTextNode(&#39;我是 li&#39;); li.appendChild(node); &lt;/script&gt; li 标签中生成了一段文本 createAttribute()－－创建属性节点 &lt;input type=&#34;text&#34;&gt; &lt;script&gt; var int = document.getElementsByTagName(&#39;input&#39;)[0]; var value = document.createAttribute(&#39;value&#39;); value.nodeValue = &#39;通过创建属性节点生成&#39;; int.setAttributeNode(value); &lt;/script&gt; 可以看到 value 属性值被成功创建 createComment()－－创建注释节点 &lt;div id=&#34;div&#34;&gt;创建一个注释节点&lt;/div&gt; &lt;script&gt; var div = document.getElementById(&#39;div&#39;); var comment = document.createComment(&#39;添加一个注释节点&#39;); div.appendChild(comment); &lt;/script&gt; f12 查看源码，可以看到 div 生成一行注释 createDocumentFragment()－－创建文档片段 文档片段的作用，就相当于是添加的所有的节点的父元素 1.假如没有 createDocumentFragment，添加了很多节点，也可以在 dom 上呈现，但是每次添加的时候都会调用一次 appendChild() 方法，产生很多次页面渲染，显得比较臃肿 2.把多次添加的节点放在一个 createDocumentFragment 节点里面，页面只会调用一次就可以把所有的节点都渲染了 createEvent()－－创建事件对象 addEventListener()－－添加事件监听函数 removeEventListener()－－移除事件监听函数 事件监听函数详解 dispatchEvent()－－触发事件 操作 css &lt;div id=&#34;demo&#34;&gt;dom&lt;/div&gt; &lt;script&gt; // 直接通过&#39;.&#39;来操作 style var demo= document.getElementById(&#39;demo&#39;); demo.style.color = &#39;red&#39;; // 通过 setAttribute() 来创建属性节点 demo.setAttribute(&#39;style&#39;,&#39;background-color: green&#39;); // 通过 style 的 cssText 属性 demo.style.cssText = &#34;border: 10px solid black&#34;; &lt;/script&gt; 4.元素节点 (element 对象) 有关 innerHTML, innerText, outerHTML, outerText 的区别 一个是元素内容，一个是文本内容 &lt;div id=&#34;div1&#34;&gt;第一个 div&lt;/div&gt; &lt;div id=&#34;div2&#34;&gt;第二个 div&lt;/div&gt; &lt;div id=&#34;div3&#34;&gt;第三个 div&lt;/div&gt; &lt;div id=&#34;div4&#34;&gt;第四个 div&lt;/div&gt; &lt;div id=&#34;div5&#34;&gt;&lt;/div&gt; &lt;div id=&#34;div6&#34;&gt;&lt;/div&gt; &lt;div id=&#34;div7&#34;&gt;&lt;/div&gt; &lt;div id=&#34;div8&#34;&gt;&lt;/div&gt; &lt;script&gt; var div1 = document.getElementById(&#39;div1&#39;).innerHTML console.log(div1) // 第一个 div var div1 = document.getElementById(&#39;div1&#39;).outerHTML console.log(div1) // &lt;div id=&#34;div1&#34;&gt;第一个 div&lt;/div&gt; var div2 = document.getElementById(&#39;div2&#39;).innerText console.log(div2) // 第二个 div var div2 = document.getElementById(&#39;div2&#39;).outerText console.log(div2) // 第二个 div document.getElementById(&#39;div5&#39;).innerHTML = &#39;&lt;a&gt;《第 5 个 div》&lt;/a&gt;&#39; // 在原有的标签内增加内容，如果有标签会被识别 document.getElementById(&#39;div6&#39;).outerHTML = &#39;&lt;a&gt;《第 6 个 div》&lt;/a&gt;&#39; // 原来的标签会被覆盖，新的文本中如果含有标签会自动生成，如果没有标签则直接以文本形式展示 document.getElementById(&#39;div7&#39;).innerText = &#39;&lt;a&gt;《第 7 个 div》&lt;/a&gt;&#39; // 在原有的标签内增加内容，新标签不会被识别为标签元素，而是被当作文本内容直接写入原标签内 document.getElementById(&#39;div8&#39;).outerText = &#39;&lt;a&gt;《第 8 个 div》&lt;/a&gt;&#39; // 原来的标签会被覆盖，新标签不会被识别为标签元素，而是直接被当作文本形式展示 &lt;/script&gt; (1) 节点属性 childElementCount－－返回当前元素的子节点的个数 &lt;div id=&#34;demo&#34;&gt; &lt;a&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) console.log(demo.childElementCount) // 4 &lt;/script&gt; firstElementChild－－返回当前元素的第一个子元素节点 lastElementChild－－返回当前元素的最后一个子元素节点 &lt;div id=&#34;demo&#34;&gt; &lt;a&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) console.log(demo.firstElementChild) // &lt;a&gt;&lt;/a&gt; console.log(demo.lastElementChild) // &lt;div&gt;&lt;/div&gt; &lt;/script&gt; nextElementSibling－－返回当前元素的下一个兄弟元素节点 previousElementSibling－－返回当前元素的上一个兄弟元素节点 &lt;span&gt;&lt;/span&gt; &lt;div id=&#34;demo&#34;&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) console.log(demo.nextElementSibling) // &lt;p&gt;&lt;/p&gt; console.log(demo.previousElementSibling) // &lt;span&gt;&lt;/span&gt; &lt;/script&gt; 返回当前元素所有的子节点 &lt;div id=&#34;demo&#34;&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt; &lt;a&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;).children for(var i in demo) { console.log(demo[i]) } &lt;/script&gt; 控制台查看返回结果 返回所有子节点集合 &lt;div id=&#34;demo&#34;&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt; &lt;a id=&#34;demo1&#34;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;).children for(var i in demo1.childNodes) { console.log(demo[i]) } &lt;/script&gt; (2) 节点方法 appendChild－－插入子节点 &lt;div id=&#34;demo&#34;&gt;&lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) var node = document.createTextNode(&#39;插入一个子节点&#39;) demo.appendChild(node) &lt;/script&gt; f12 可以看到，div 被插入了一个节点 insertBefore(a, b)－－在指定位置插入节点 参数 a 表示要插入的内容，b 表示定位，在 b 节点之前插入 a 节点 &lt;div id=&#34;demo&#34;&gt;&lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) var node = document.createTextNode(&#39;插入一个子节点&#39;) demo.appendChild(node) var hr = document.createElement(&#39;hr&#39;) demo.insertBefore(hr, node) &lt;/script&gt; 可以看到，原来的文本节点之前，被添加了一个新的元素节点 replaceChild(a, b)－－替换节点 用参数 a 替换参数 b，a 表示新节点，b 表示旧节点 &lt;div id=&#34;demo&#34;&gt;&lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) var node = document.createTextNode(&#39;插入一个子节点&#39;) demo.appendChild(node) var h3 = document.createElement(&#39;h3&#39;) var h3node = document.createTextNode(&#39;title 标题&#39;) h3.appendChild(h3node) demo.replaceChild(h3, node) &lt;/script&gt; h3是新节点，node是旧节点，根据图片可以看到，b 替换掉了 a，成功上位 removeChild－－父节点删除子节点 &lt;div id=&#34;demo&#34;&gt; &lt;div id=&#34;son&#34;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) var son = document.getElementById(&#39;son&#39;) demo.removeChild(son) &lt;/script&gt; f12 可以看到，id 为 son 的元素节点，通过demo.removeChild()已经被删除了 removeAttribute－－删除属性节点 &lt;div id=&#34;demo&#34; class=&#34;div&#34;&gt;&lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) demo.removeAttribute(&#39;class&#39;) &lt;/script&gt; class 属性已经被删除了 删除文本节点 &lt;div id=&#34;demo&#34;&gt;文本&lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) demo.removeChild(demo.childNodes[0]) &lt;/script&gt; 通过demo.childNodesp[0]获取 demo 的第一个节点，即文本节点，然后removeChild它，就删除了 isEqualNode－－判断两个元素是否相等 isSameNode－－判断两个元素是否相同 两者分别代表相等和相同 (1) isEqualNode相等，指的是两个节点是否是同一类型，具有相等的属性（包括：nodeName, nodeValue&hellip;等等），还有相等的 attributes,childNodes（相等的位置包含相同的值） (2) isSameNode相同，指的是两个节点引用的是同一个对象 &lt;form action=&#34;#&#34;&gt; &lt;input type=&#34;button&#34; /&gt; &lt;/form&gt; &lt;form action=&#34;#&#34;&gt; &lt;input type=&#34;button&#34; /&gt; &lt;/form&gt; &lt;form action=&#34;#&#34; id=&#34;o&#34;&gt; &lt;input type=&#34;button&#34; /&gt; &lt;/form&gt; &lt;form action=&#34;#&#34; id=&#34;o&#34;&gt; &lt;input type=&#34;text&#34; /&gt; &lt;/form&gt; &lt;script&gt; var forms = document.forms; var form1 = forms[0]; var form2 = forms[1]; var form3 = forms[2]; var form4 = forms[3]; var _form1 = document.querySelectorAll(&#39;form&#39;)[0]; console.log(form1.isSameNode(form1)) //true 两个节点引用的对象都是第一个 form console.log(form1.isSameNode(_form1)) //true 两个节点引用的对象都是第一个 form console.log(form1.isSameNode(form2)) //false 两个节点引用的不是一个对象 console.log(form1.isEqualNode(form2)) //true 两个节点具有完全等同属性 console.log(form1.isEqualNode(form3)) //false form1 中无等同的 id 属性 console.log(form3.isEqualNode(form4)) //fasle form4 的 childNodes 中的 input 为 text 类别，与 form3 不同 &lt;/script&gt; 根据例子代码可以看出区别： (1) isSameNode只有引用同一个对象时才相同，比如用两中方法调用同一个对象，再比较这两种方法，比来比去还是那个对象，所以相同 (2) 而isEqualNode比较两个对象的元素节点是否相等，只要两者一致就可以相等 true hasChildNodes()－－判断一个元素是否拥有子节点 判断demo是否拥有子节点，然后输出他的子节点 &lt;div id=&#34;demo&#34;&gt; &lt;!-- &lt;a&gt;&lt;/a&gt; --&gt; &lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) console.log(demo.hasChildNodes()) console.log(demo.childNodes) &lt;/script&gt; contains(a)－－判断一个节点是否包含指定子节点（参数 a 表示要判断的子节点） 存在id=&quot;a&quot;的元素，因此 contains 判断成功输出true， 不存在id=&quot;b&quot;的元素，因此输出false &lt;div id=&#34;demo&#34;&gt; &lt;a id=&#34;a&#34;&gt;&lt;/a&gt; &lt;a&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var demo = document.getElementById(&#39;demo&#39;) var a = document.getElementById(&#39;a&#39;) console.log(demo.contains(a)) // true var b = document.getElementById(&#39;b&#39;) console.log(demo.contains(b)) // false &lt;/script&gt; 5.属性节点 (Attr 对象) &lt;input type=&#34;text&#34; id=&#34;int&#34;&gt; &lt;script&gt; var int = document.getElementById(&#39;int&#39;) // 1.获取属性值 console.log(int.getAttribute(&#34;type&#34;)) // text // 2.获取属性节点 console.log(int.getAttributeNode(&#34;type&#34;)) // type=&#34;text&#34; // 3.设置属性值 int.setAttribute(&#34;value&#34;, &#34;input 框&#34;) // &lt;input type=&#34;text&#34; id=&#34;int&#34; value=&#34;input 框&#34;&gt; // 4.设置属性节点 let name = document.createAttribute(&#34;name&#34;); name.nodeValue = &#34;uname&#34;; int.setAttributeNode(name); console.log(int.getAttributeNode(&#39;name&#39;).value) // &lt;input type=&#34;text&#34; id=&#34;int&#34; value=&#34;input 框&#34; name=&#34;uname&#34;&gt; // 5.删除属性节点 console.log(int.removeAttribute(&#39;name&#39;)) // &lt;input type=&#34;text&#34; id=&#34;int&#34; value=&#34;input 框&#34;&gt; // 6.判断是否存在属性 console.log(int.hasAttributes()) // true // 7.判断是否存在指定属性 console.log(int.hasAttribute(&#39;value&#39;)) // true &lt;/script&gt; 注意：hasAttribute和hasAttributes的区别 hasAttributes判断是否存在属性， hasAttribute判断是否存在指定属性</div>
          <div class="index-post-meta">
            <a href="/blog/18.html/"> # 2020-11-15</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      

      



















<div class="page">
  
  <a href="/page/27/" class="prev">上一页</a>
  

  
  <a href="/page/29/" class="next">下一页</a>
  


</div>



    </div>

    <footer id="foot">
  <p>© 2020 - 2024 Powered by
    <a href="https://github.com/dlzmoe/blog" target="_blank">Github</a>
    / <a href="/index.xml" target="_blank">RSS</a>
  </p>
</footer>

<script src="/js/main.js"></script>
<script defer src="https://cn.vercount.one/js"></script>
  </section>

  <script>
    const time = "2020-06-14";
    var now = new Date();
    var end = new Date(time);
    var diff = Math.abs(now - end);
    var days = Math.ceil(diff / (1000 * 60 * 60 * 24));
    $('#days').html(days);
  </script>
</body>

</html>