<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.123.6">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/" />
<link rel="canonical" href="https://zishu.me/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "",
"name" : "子舒的博客",
"headline" : "子舒的博客",
"description" : "",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2024",
"datePublished": "2024-09-05 00:00:00 \u002b0000 UTC",
"dateModified" : "2024-09-05 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/",
"keywords" : [  ]
}
</script><title>子舒的博客</title>
<meta property="og:title" content="子舒的博客" />
<meta property="og:type" content="website" />
<meta property="og:description" content="" />
<meta name="description" content="" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />


<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>































































































































































































































































































































































































































































































































































































































































































































































































<body id="container">
  <meter id="isread" max="100" value="0"></meter>
<script>
  window.addEventListener('scroll', function () {
    var scrolled = window.scrollY;
    var totalHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percentage = (scrolled / totalHeight) * 100;
    $('#isread').attr('value', percentage)
  });
</script>


<div id="head" class="site-index">
  <a id="logo" href="/">
    <img src="https://imgurl.zishu.me/author.webp">
  </a>
  <div id="site-title">
    <a href="/">子舒的博客</a>
  </div>
  <ul id="menu">
    
    <li><a href="/categories/%e6%8a%80%e6%9c%af/">技术</a></li>
    
    <li><a href="/categories/%e9%9a%8f%e7%ac%94/">随笔</a></li>
    
    <li><a href="/categories/weekly/">周刊</a></li>
    
    <li><a href="/projects/">项目</a></li>
    
    <li><a href="/message/">留言</a></li>
    
    <li><a href="/about/">关于</a></li>
    
    <li><a href="/index.xml" target="_blank">订阅</a></li>
  </ul>
</div>

  <section id="body">
    <h2 id="body-title">📓 Articles</h2>

    <div id="body-in">

      <div class="index-post index-post-content-long">
        <p class="text">欢迎来到我的博客，已经运行了 <span id="days"></span> 天，有 <span id="busuanzi_value_site_pv">...</span>
          位小伙伴逛过，写了 273 篇文章，共 180113 字。</p>
      </div>

      
      
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/10.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/10.html/">
            <h2>对全栈的一些思考</h2>
          </a>
          <div class="text">这里我要推荐一本书，叫做《Web 全栈工程师的自我修养》，在看的过程中，自己也代入进去进行分析，然后写了这篇笔记。 “全栈工程师正在成为 IT 行业的新秀，无论是在上市互联网公司还是在创业公司，都对全栈工程师青睐有加。本书作者是腾讯公 司高级工程师，在前端、后端和 APP 开发方面都有丰富的经验，在本书中分享了全栈工程师的技能与要求、核心竞争力、未来发 展方向、对移动端的思考。除此之外，本书还详细记录了作者从零开始、学习心得。本书内容全面、客观务实适合互联网行业新人、程序员。以及期待技术转型的从业者阅读参考。” 作者余果毕业于西安点击科技大学软件工程学院，曾任腾讯社交用户体验设计部高级 UI 工程师、前端开发负责人，负责多个项目的产品设计，以自身的经历为模板撰写了这本书。 从自身说起，因为对技术和机器的热爱让他走向了计算机这门行业，而在书中，他也经常提及自己理性和感性思维相结合，对全栈工程师进行了深入分析。 全栈工程师是指一个能够处理数据库、服务器、系统工程和客户端所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web 栈，或者原生应用程序栈。这是官方的定义。而以我目前出入前端的思维通俗点来说，大概也就是一个人包揽前端，后端，一个人处理数据进行项目维护，甚至于设计图都是自己做的。 很多人都说全栈有很多好处，不同担心很多人编写不同步，思维不一致，导致做出来的项目每个人的想法不同，全栈一个人包揽所有的过程，都在自己脑子里。 可能因为我进入这个行业不久，我认为全栈是不太合理的存在，打个比方说，在流水线还没出现之间，手工作坊基本都是一个人负责所有的产品制作，从原料，制作，打磨，成品，或许很经过很多步骤，但是一个人都可以完美的做出来，就这样类似全栈工程师这样的存在。 而生产线就更像一个团队，产品，UI，前端，后端测试等，每个人相互配合。 全栈和团队比起来，我个人觉得团队的优势更大，但架不住老板喜欢一个人干三个人活，更喜欢全栈一点。 培养一个全栈的花费的时间和精力难以想象，甚至不确定培养一定成功，但是如果专精某一技术领域，成为高级工程师的概率绝对远大于一个全栈。当然这也只是我个人的臆测，并没有具体的数据支撑。 书中也提及，流水线带来的另一个好处，不会对某个工程师产生依赖性，即使失去这个员工，也可以让被人接手工作 说了很多团队化的好处，这不代表就没有弊端，肯定是有的，书中总结出来几点： 工程师职责不清导致效率低 工程师缺乏主人感导致产品质量差 工程师缺乏全局的视野影响个人成长 更多角色导致项目效率低下 “因为各司其职的工作流程有效率低下、成本高的缺点，所以很多创业公司都不会配备齐全的流水线，而是希望采用更灵活的方式来组建团队，全栈工程师也因此成为了理想的选择。但是全栈工程师的兴起还离不开这两个重要因素：技术的发展，以及提供 PaaS 服务的平台越来越多。” 虽然做成为一个全栈工程师需要耗费大量的时间精力来打磨，但是这个思维我还是比较喜欢的。比如说，有 a,b,c 三个人，分别擅长各自的领域，有一天他们共同负责的项目出了一个小问题，但是问题出在哪里领域还不知道，虽然是个小问题，但需要每个人去查验一遍，因为是三个领域，这就导致应该有两个人的查验是无效的，这从另一个方向来说也降低了项目效率。 然后这时候，有一个工程师 s，注意他不是全栈工程师，只是喜欢学习多领域的技术，掌握了一些不算太高深的技术知识，查验了一遍，很快就找出了问题所在。 那他一个人效率就相当于三个的效率了，其实这样说并不严谨，我也只是打个比方。 我突然想到一句话，不知道说的准确与否， “全栈的职位存在是不合理的，但全栈的思维是一个有上进心的工程师所必备的。”</div>
          <div class="index-post-meta">
            <a href="/blog/10.html/"> # 2020-09-18</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/8.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/8.html/">
            <h2>chrome 浏览器中对 autoplay 的一些处理技巧</h2>
          </a>
          <div class="text">我在写博客的时候，想给博客网页添加自己喜欢的音乐，这样我在写作和阅读的时候，心情也会比较愉悦，这个时候，我们就需要用到audio这个标签。 &lt;audio src=&#34;&#34;&gt;&lt;/audio&gt; 同时 audio 标签还带有很多实用的属性，常用的有以下几个： src &ndash; 这个就不说了，懂的都懂 autoplay &ndash; 如果出现该属性，音频在就绪后马上播放 controls &ndash; 网页中显示音频控件 loop &ndash; 循环播放 muted &ndash; 默认静音 但是我在设置 autoplay 的时候发现，chrome 对自动播放深恶痛绝，直接从根源上限制了这个属性的开启，意思是说，这个属性直接禁用，在打开网页没有交互的情况下，不允许自动播放。 但仔细想一想，这个做法其实是对用户比较有利的。假设用户使用的时候宽带流量，直接自动播放视频、音频，就会对用户造成损失。甚至一些广告会自动播放，这就直接影响到了用户的体验。所以，对于 chrome 的做法我还是比较赞同的。 回过头一想，不对啊，我的目的是解决这个问题，不是夸赞谷歌的。我想给自己的个人博客添加喜欢的音乐，所以我找了一个不算办法的办法。我直接在模拟一个事件，当鼠标点击网页任意处的时候，自动触发 autoplay 的音频效果，直接上代码。 &lt;script&gt; function toggleSound() { var music = document.getElementById(&#34;vd&#34;); //获取ID console.log(music); console.log(music.paused); if (music.paused) { //判读是否播放 music.paused=false; music.play(); //没有就播放 } } setInterval(&#34;toggleSound()&#34;,1); &lt;/script&gt; 这样处理过之后，插入音频，任意点击网页某个地方，都会触发播放效果，但凡事有利有弊，这样做的话，一旦开启播放，将无法启用暂停功能，也就是说会一直播放下去 如果是像我这样写个人博客，这个弊端倒是影响不大，我在这里记录一下这个方法。</div>
          <div class="index-post-meta">
            <a href="/blog/8.html/"> # 2020-09-11</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/7.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/7.html/">
            <h2>推荐书籍《CSS 世界》</h2>
          </a>
          <div class="text">本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰灯方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的 CSS 知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析 CSS 的相关知识与常见问题。 作者还为本书开发了专门的配套网站，进行实例展示。问题答疑。作为一本 CSS 深度学习的书，书中介绍大量许多前端开发人员都不知道的 CSS 知识点。通过阅读本书，读者会对 CSS 世界的深度和广度有一个全新的认识。 这本书作者采用口语化的方式，讲述在 css 中遇到的一些有意思的问题，循序渐进，引人入胜，对有前端基础的人来说，读这本书还是很有意思的。我经常在闲余时间看看这本书，会给我一些启发。</div>
          <div class="index-post-meta">
            <a href="/blog/7.html/"> # 2020-08-11</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/6.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/6.html/">
            <h2>文字溢出隐藏以及和 flex 冲突的问题</h2>
          </a>
          <div class="text">在某些段落中，页面要求文字只显示一行，但是width固定，而文字过长，就会出现一个需求，超过长度限制的文字被隐藏且显示省略号，css 支持这样的属性。 单行文本溢出隐藏 div{ overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } 多行文本溢出隐藏 div { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } 简单的几行代码就可以达到我们的要求。 但是有一个我们需要注意的地方！！ flex 布局是前端写代码经常使用的一种布局方式，简单便捷且有效，但是在使用 flex 布局的元素中不能同时使用文字溢出隐藏，也就是两者不能同时出现在同一标签中。 这里，我们也有对应的解决办法。 只要保证 flex 布局和隐藏的样式不在同级元素中就可以，所以在文字外部多包裹一层标签。 可以采用下面这段代码的写法； &lt;p&gt; &lt;!-- 我们在这一层的标签进行flex布局 --&gt; &lt;span&gt; &lt;!-- 这一层的标签我们引入文字过长隐藏的样式 --&gt; &lt;!-- 文本 --&gt; &lt;/span&gt; &lt;/p&gt;</div>
          <div class="index-post-meta">
            <a href="/blog/6.html/"> # 2020-08-03</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/5.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/5.html/">
            <h2>vue 生命周期</h2>
          </a>
          <div class="text">学习 vue 中一个非常重要的领域，就是生命周期，它包含了很多的内容。每个 vue 实例在被创建的时候都要经历一系列的初始化过程，这个过程就是 vue 的生命周期。 每个 vue 实例在被创建的时候都要经过一系列的初始化过程——例如，需要把设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等，我们要把这一系列的过程称为组件的生命周期（组件从注册到销毁的整个过程）。我们有时候需要在组件生命周期的某个过程中，执行某些代码，基于此，vue 提供了生命周期钩子函数，给了用户在不同阶段添加自己的代码的机会。 但是在此之前，我们要详细的介绍下组件的生命周期，以及生命后期中每个阶段组件完成和未完成的部分。 一、组件的生命周期 放一张大家都很熟悉的官网文章中对生命周期的注释图。 从图中可以看出，vue 为生命周期提供了 8 个钩子函数，分别是： beforeCreate: 创建前 created: 创建后 beforeMount: 挂载前 mounted: 挂载后 beforeUpate: 更新前 upated: 更新后 beforeDestoy: 销毁前 destoyed: 销毁后 1.beforeCreate beforeCreate 在 vue 实例发生之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 我们在上面的例子中在的 beforeCreate 钩子中调用 Vue 的 data 和 method，来看一下结果： 可以看到 Vue 中的 data 和方法都是去不到的，并且是在 wath 之前执行 2.created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 主要应用：调用数据，调用方法，调用异步函数 console 输出的结果我们看一下 可以看到：created 钩子可以获取 Vue 的 data，调用 Vue 方法，获取原本 HTML 上的直接加载出来的 DOM，但是无法获取到通过挂载模板生成的 DOM（例如：v-for 循环遍历 Vue.list 生成 li） 3.beforeMount 在挂载开始之前被调用：相关的 render 函数（模板）首次被调用。 例如通过 v-for 生成的 html 还没有被挂载到页面上 beforeMount: function () { console.log(&#39;beforeMount:&#39;,document.getElementsByTagName(&#39;li&#39;).length); }, console 打印出来的 beforeMount 为 1 4.mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 有初始值的 DOM 渲染，例如我们的初始数据 list，渲染出来的 li，只有这里才能获取 mounted: function () { console.log(&#39;mounted:&#39;,document.getElementsByTagName(&#39;li&#39;).length); }, 结果 mounted: 3 , 可以看到到这里为止，挂载到实例上了，我们可以获取到 li 的个数了 5.beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 当我们更改 Vue 的任何数据，都会触发该函数 beforeUpdate: &#34;function () { console.log(&#39;beforeUpdate 钩子执行.&#39;); console.log(&#39;beforeUpdate:&#39;+this.message) }, 6.updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 数据更新就会触发（vue 所有的数据只有有更新就会触发）,如果想数据一遍就做统一的处理，可以用这个，如果想对不同数据的更新做不同的处理可以用 nextTick，或者是 watch 进行监听 updated: function () { console.log(&#39;updated 钩子执行...&#39;); console.log(&#39;updated:&#39;,this.message) }, 7.beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 8.destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 结果 可以看打到销毁 Vue 实例时会调用这两个函数</div>
          <div class="index-post-meta">
            <a href="/blog/5.html/"> # 2020-06-19</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/1.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/1.html/">
            <h2>hello, world</h2>
          </a>
          <div class="text">2020 年 6 月 14 日 我的博客正式建立。 愿一切安好。</div>
          <div class="index-post-meta">
            <a href="/blog/1.html/"> # 2020-06-14</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/serve\/'">
        <div class="index-post-content-long">
          <a href="/serve/">
            <h2>免费服务</h2>
          </a>
          <div class="text">提供一些免费服务。 工具 基于 Cloudflare Workers AI 的绘画工具 https://ai.zishu.me/ 基于 telegraph + Cloudflare 的免费图床 https://zsh.im/ 临时邮件服务 https://b3260cb9.temp-email-de0.pages.dev/ 免费文本 logo 生成器 https://logo.zishu.me/ 镜像源 Rsshub 镜像源 https://rsshub.zishu.me/ Docker 镜像源 https://workers-docker.zishu.me/ gravatar 头像国内镜像 https://gravatar.zishu.me/</div>
          <div class="index-post-meta">
            <a href="/serve/"> # 0001-01-01</a>
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/about\/'">
        <div class="index-post-content-long">
          <a href="/about/">
            <h2>关于</h2>
          </a>
          <div class="text">1.个人介绍 const author = { name: &#39;子舒&#39;, create_date: 1998, tags: [&#39;前端程序员&#39;, &#39;独立博客作者&#39;, &#39;骑行爱好者&#39;, &#39;摄影爱好者&#39;, &#39;INFJ 人格&#39;], adress: &#39;杭州&#39;, email: &#39;anghunk@gmail.com&#39;, github: &#39;https://github.com/dlzmoe&#39;, blog: &#39;https://zishu.me&#39;, description: &#39;喜欢折腾技术，研究各种奇怪的程序和网站，喜欢户外运动，热爱生活。&#39; } 如果想要添加友链，可以使用以下信息 (click me) title: 子舒的博客 author: 子舒 url: https://zishu.me avatar: https://imgurl.zishu.me/author.webp description: 喜欢折腾技术，研究各种奇怪的程序和网站，喜欢户外运动，热爱生活。 我的 计划单。 同时将周刊一起发布到了本网站，督促自己多扩展眼界，获取更新的知识，不管是技术类型还是娱乐，让自己的容量不断 +1. 提供一些免费服务。 2.友情链接 有时候就会遇到一些文章写的不错的博主，于是就记录在这里了。 余果的博客 // 涛叔 // 江卮可乐 // 东东博客 // Leon Fong // 卢涛南博客 // Airing 的博客 // Jiang&rsquo;s Blog // ImQi1 的博客 5.版权声明 本站文章所有版权均归本人所有，未经允许，不允许转载。</div>
          <div class="index-post-meta">
            <a href="/about/"> # 0001-01-01</a>
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/message\/'">
        <div class="index-post-content-long">
          <a href="/message/">
            <h2>留言</h2>
          </a>
          <div class="text">哎呀，终于有人来啦！欢迎欢迎！这里是留言板，也是一个充满奇思妙想的地方。 有什么想说的都可以在这里留下你的足迹，就像小动物在树上留下酷炫的手印一样！</div>
          <div class="index-post-meta">
            <a href="/message/"> # 0001-01-01</a>
            
          </div>
        </div>
      </div>
      

      

      



















<div class="page">
  
  <a href="/page/29/" class="prev">上一页</a>
  

  
  <a href="/page/31/" class="next">下一页</a>
  


</div>



    </div>

    <footer id="foot">
  <p>© 2020 - 2024 Powered by
    <a href="https://github.com/dlzmoe/blog" target="_blank">Github</a>
    / <a href="/index.xml" target="_blank">RSS</a>
  </p>
</footer>

<script src="/js/main.js"></script>
<script defer src="https://cn.vercount.one/js"></script>
  </section>

  <script>
    const time = "2020-06-14";
    var now = new Date();
    var end = new Date(time);
    var diff = Math.abs(now - end);
    var days = Math.ceil(diff / (1000 * 60 * 60 * 24));
    $('#days').html(days);
  </script>
</body>

</html>