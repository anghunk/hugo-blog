<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.123.6">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/" />
<link rel="canonical" href="https://zishu.me/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "",
"name" : "子舒的博客",
"headline" : "子舒的博客",
"description" : "",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2024",
"datePublished": "2024-09-05 00:00:00 \u002b0000 UTC",
"dateModified" : "2024-09-05 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/",
"keywords" : [  ]
}
</script><title>子舒的博客</title>
<meta property="og:title" content="子舒的博客" />
<meta property="og:type" content="website" />
<meta property="og:description" content="" />
<meta name="description" content="" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />


<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>

































































































































































































































































































































































































































































































































































































































































































































































































<body id="container">
  <meter id="isread" max="100" value="0"></meter>
<script>
  window.addEventListener('scroll', function () {
    var scrolled = window.scrollY;
    var totalHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percentage = (scrolled / totalHeight) * 100;
    $('#isread').attr('value', percentage)
  });
</script>


<div id="head" class="site-index">
  <a id="logo" href="/">
    <img src="https://imgurl.zishu.me/author.webp">
  </a>
  <div id="site-title">
    <a href="/">子舒的博客</a>
  </div>
  <ul id="menu">
    
    <li><a href="/categories/%e6%8a%80%e6%9c%af/">技术</a></li>
    
    <li><a href="/categories/%e9%9a%8f%e7%ac%94/">随笔</a></li>
    
    <li><a href="/categories/weekly/">周刊</a></li>
    
    <li><a href="/projects/">项目</a></li>
    
    <li><a href="/message/">留言</a></li>
    
    <li><a href="/about/">关于</a></li>
    
    <li><a href="/index.xml" target="_blank">订阅</a></li>
  </ul>
</div>

  <section id="body">
    <h2 id="body-title">📓 Articles</h2>

    <div id="body-in">

      <div class="index-post index-post-content-long">
        <p class="text">欢迎来到我的博客，已经运行了 <span id="days"></span> 天，有 <span id="busuanzi_value_site_pv">...</span>
          位小伙伴逛过，写了 274 篇文章，共 180337 字。</p>
      </div>

      
      
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/11.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/11.html/">
            <h2>js 基本语法</h2>
          </a>
          <div class="text">在学习 js 基本语法的过程中，把遇见的知识点和问题记录喜下来，以便未来复习和参考。 数据类型有：数据，字符串，数组，数字，布尔值等。 一、数据类型 1.number 2.布尔值 只有 true 和 false 两种，可以直接用 true 和 false 来表达，比如： true; //true false; //false 2&gt;1; //true 2&gt;3; //fasle 与 &amp;&amp; 两者同时为true，运算结果为true 或 || 只要有一个为true，运算结果就是true 非 ！ 当程序为true时，运算结果取反为false var age = 15; if(age &gt;= 18) { alert(&#39;adult&#39;) }else{ alert(&#39;teenager&#39;) } age 值是 15，当 age 大于且等于 18 的时候浏览器弹出 adult，反之弹出 teenager 3.字符串 4.比较运算符 ==和=== 当使用==进行比较的时候，一般会自动转换类型然后再进行比较 当使用===进行比较的时候，如果数据类型不一样，直接返回false，等到类型一致了，然后再进行比较 有一个特殊的number就是NaN，它不与任何值相等，包括它自己NaN NaN === NaN //false 5.null和undefined null表示一个空值，0表示一个数值，''表示长度为 0 的字符串，但是null表示空 undefined表示未定义 但是区分两者意义不大，大多数还是在用null，undefined仅仅在判断函数参数是否传递的情况下有用 6.数组 Array [ ] ，表示一组按顺序排列的集合，其中的每个值称为元素 new Array(1,2,3) //[1,2,3] 数组的索引 二、对象和变量 var person = { name: &#39;jack&#39;, age: 20, city: &#39;hangzhou&#39; } person是对象变量，name: 'jack'这就是一个键值对，name是属性名，'jack'是属性 要获取一个对象的属性，用对象变量.属性，也就是person.name，结果是jack person.name //jack person.age //20 var是一个动态语言，就算 var 定义了 x = 100，后面又有 x = x+ 100，所以就变成了 200, var x = 100; x = x+ 100; console.log(x) //200 假如用 int 来定义 x，后面的 x = x + 100 就会报错 并且使用 var 定义的变量只会存在与该函数作用域，并不是默认的全局变量 而如果没有使用var，直接定义i = 100，变量 i 会被默认为全局变量 三、字符串 需要用到转义字符\ 1.模板字符串 var name = &#39;小明&#39;; var age = 20; var message = name + &#39;今年&#39; + age + &#39;了&#39;; //小明今年20了 var message = `${naem}，你今年${20}了` //ES6新增的语法，一样的结果 字符串不可改变 如果对字符串的某个索引赋值，不会报错，不会发生任何改变 var a = &#39;hello,world!&#39; a[0]; //h a[0] = k; console.log(a); //结果为&#39;hello,world!&#39;，不会发生改变 2.toUpperCase 大写 他会返回一个新的字符串，把一个字符串全部变成大写 var a = &#39;hello&#39;; a.toUpperCase(); //返回HELLO 3.toLowerCase 小写 他会返回一个新的字符串，他会把一个字符串全部变成小写 var a = &#39;hello&#39; a.toLowerCase(); //HELLO 4.indexOf 他会返回指定字符串的索引，如果没有找到指定的字符串，则会返回-1 var a = &#39;hello,world!&#39; a.indexOf(&#39;world&#39;); //6 5.substring 他会返回指定区间索引的字符串，包括前一个数，不包括后一个数 var a = &#39;hello,world!&#39; a.substrng(0, 5); //hello 如果()里面只有一个数值，则从这个数值的索引开始直到结束，比如： var a = &#39;hello,world!&#39;; a.substring(6); //返回world! 四、数组 数组Array可以包含任何类型的数据，并通过索引来访问每个数据 1.length 属性 Array的长度可以用length属性来获取，它和索引不一样，从 1 开始计算 var arr = [1,2,3,&#39;hello&#39;,null,true] arr.length; //返回6 并且通过改变length的值，可以改变数组的内容大小变化 var arr = [1,2,3,&#39;hello&#39;,null,true] arr.length; //6 arr.length = 8; //[1,2,3,&#39;hello&#39;,null,true,undefined,undefined] arr.length = 2; //[1,2] 2.通过索引改变数组 Array可以直接通过索引修改对应的元素 var arr = [1,2,3] arr[1] = &#39;hello&#39; console.log(arr); //[1,&#39;hello&#39;,3] js 允许直接通过索引改变数组的长度，不会报错，但是不建议这么做 3.indexOf Array可以通过indexOf来搜索一个指定的元素的索引 var arr = [1,2,3,&#39;hello&#39;] arr.indexOf(1); //0 arr.indexOf(3); //2 4.slice slice属性与substring类似，后者是截取字符串的内容，slice是截取数组的内容，然后返回一个新的数组 如果有两个数值，包括前面的数值，不包括后面的数值；如果只有一个数值，则从它开始算起一直到结束 var arr = [1,2,3,4,5]; arr.slice[0,2]; //返回[1,2] arr.slice[2]; //返回[3,4,5] 如果slice不指定数值，则返回数组的全部内容，可以利用这个特性复制一个相同的数组出来 var arr = [1,2,3]; var arr1 = arr.slice(); console.log(arr1); //[1,2,3] arr1 === arr; //true 注意：两个数组相比都是 false，就算数组内容一样也会 false var arr = [1,2,3] var arr1 = [1,2,3] arr === arr1 //false 5.push 和 pop push()向数组的末尾添加元素 pop()把数组的最后一个元素删掉 6.unshifth 和 shift unshift()向数组的头部添加元素 shift()把数组的第一个元素删掉 7.sort sort()可以对数组进行排序，会直接修改当前数组的元素位置，直接调用时，会按照默认的方式排序 var arr = [B,A,C] arr.sort(); arr //[A,B,C] 8.reverse reverse()会把整个数组调个个，不是反向排序 var arr = [2,1,3] arr.reverse(); arr; //[3,1,2] 9.splice 这个属性是万能的方法，通过调用splice()，可以从指定的索引删除元素或者添加元素 五、条件判断 在 js 中，使用 if() {...} else {...}进行条件判断 var age = 22; if(age&gt;20) { // 如果age&gt;20成立，执行该语句 console.log(&#39;22&gt;20&#39;) }else { // 如果age&gt;20不成立，则执行该语句 conosle.log(&#39;22&lt;20&#39;) } 最终，控制台会打印出22&gt;20，因为条件成立 执行的语句要用{}包裹起来，防止其他情况会报错 多条件判断语句 三个或者三个以上多判断语句，被称为多条件判断语句 var a = 10 if(a&lt;10) { console.log(&#39;a&lt;10&#39;) }else if(a&gt;20){ console.log(&#39;a&gt;10&#39;) }else{ console.log(&#39;10&lt;=a&lt;=20&#39;) } 如果多个条件中都满足，则取第一个满足的结果，执行其代码，之后满足的自动忽略掉，所以在 进行条件判断的时候，不要重复判断情况 一个复杂的多条件判断语句 var height = parseFloat(prompt(&#39;请输入身高(m):&#39;)); var weight = parseFloat(prompt(&#39;请输入体重(kg):&#39;)); var bmi = weight/(height*height); if(bmi &lt; 18.5) { console.log(&#39;过轻&#39;) }else if(bmi&gt;18.5,bmi&lt;25) { console.log(&#39;正常&#39;) }else if(bmi&gt;25,bmi&lt;28){ console.log(&#39;过重&#39;) }else if(bmi&gt;28,bmi&lt;32){ console.log(&#39;肥胖&#39;) }else{ console.log(&#39;严重肥胖&#39;) } parseFloat可以解析一个字符串，并返回一个数字 六、循环 简单的运算可以手打出来 1 + 2 + 3 // 控制台输出 6 但是几百次，几千次，几万次的运算无法手打，可以依靠循环语句来进行计算，为了让计算机能够进行成千上万次的运算 循环语句有两种 for 和 while，他们有不同的用法，适应不同的情况 1. for 循环 通过初始条件，结束条件和递增条件来循环执行语句块 var x = 0 var i for(i = 1; i &lt;= 1000; i++) { x = x + i } i = 1 是初始条件，i 从 1 开始算起 i&lt;=是判断条件，满足就执行循环，不满足就退出循环 i++ 是递增条件，每次循环过后都是＋1，当无数次后不满足了 i&lt;=1000，会跳出循环 2. 通过 for 语句遍历数组 var arr = [&#39;apple&#39;, &#39;banana&#39;, &#39;oringen&#39;] var x,i for(i = 0; i &lt;= arr.length; i++) { x = arr[i] console.log(x) } 3. 用 break 终止 for 循环 var x = 0; for ( ; ; ) { // 将无限循环下去 if (x &gt; 100) { console.log(x) break; // 通过if判断来退出循环 } x ++; } 4. for&hellip;in 可以把一个对象对属性循环遍历出来 var person = { name: &#39;jack&#39;, age: 20, city: &#39;beijing&#39; }; for(var i in person) { console.log(i) console.log(person[i]) } var i in person会把 person 里面所有对属性遍历，然后通过console.log(i)可以把属性名打印出来，console.log(person[i])可以把属性值打印出来 如果对一个数组进行这样的操作，就可以把数组元素对索引打印出来，打印结果是字符串形式 5. while 循环 while循环适用于忽视判断条件的情况，for适用于明确了初始条件和结束条件的情况 比如要计算 1-100 之间的寄数和，可以用while循环 var x = 0 var n = 99 while (n &gt; 0) { x = x + n n = n - 2 } x 在变量内部，n 不断自减，直接 n=-1，不满足判断条件，此时退出循环 6. do&hellip;while do...while循环是先循环，然后再判断条件，所以不论条件是否满足，do...while至少循环一次，这是它与for和while的区别 比如： var n = 0 do{ n = n + 1 }while(n &gt; 1) n; //1 先定义n=0，然后执行n=n+1，所以n=1，再判断条件，当 n&gt;1 的时候执行，不符合，退出循环，控制台输出n，结果为 1 七、Map 和 Set 1. Map Map是一组键值对的结构，具有极快的查找速度 只要我们定义一个属性名和属性值对应的数组，就可以从这个数组里面通过 name 直接查找数据 var m = new Map([[&#39;jack&#39;, 95], [&#39;Bob&#39;, 94], [&#39;linda&#39;, 93]]) m.get(&#39;jack&#39;) 首先，要初始化一个Map数组 var m = new Map(); //空map m.set(&#39;jack&#39;, 95) //添加一个新的键值对 key-value m.has(&#39;jack&#39;) //检查是否存在 &#39; jack&#39;key m.get(&#39;jack&#39;) //获取&#39;jack&#39;对应的数据 value m.delete(&#39;jack&#39;) //删除&#39;jack&#39;键值对 key-value m.get(&#39;jack&#39;) //undefined 一个 key 只能对应一个 value，所以如果重复赋值的话，后面的数据会把前面的数据覆盖掉 var m = new Map(); m.set(&#39;Adam&#39;, 67); m.set(&#39;Adam&#39;, 88); m.get(&#39;Adam&#39;); // 88 2. Set set中值储存key，不储存value，而且在set中，key不能重复，如果重复了，会自动忽略掉重复 首先，创建一个空的set var m = new Set() //空set m.add(1) //添加一个key m.delete(1) //删除一个key m //控制台输入［ ］空数组，没有数据</div>
          <div class="index-post-meta">
            <a href="/blog/11.html/"> # 2020-10-21</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/10.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/10.html/">
            <h2>对全栈的一些思考</h2>
          </a>
          <div class="text">这里我要推荐一本书，叫做《Web 全栈工程师的自我修养》，在看的过程中，自己也代入进去进行分析，然后写了这篇笔记。 “全栈工程师正在成为 IT 行业的新秀，无论是在上市互联网公司还是在创业公司，都对全栈工程师青睐有加。本书作者是腾讯公 司高级工程师，在前端、后端和 APP 开发方面都有丰富的经验，在本书中分享了全栈工程师的技能与要求、核心竞争力、未来发 展方向、对移动端的思考。除此之外，本书还详细记录了作者从零开始、学习心得。本书内容全面、客观务实适合互联网行业新人、程序员。以及期待技术转型的从业者阅读参考。” 作者余果毕业于西安点击科技大学软件工程学院，曾任腾讯社交用户体验设计部高级 UI 工程师、前端开发负责人，负责多个项目的产品设计，以自身的经历为模板撰写了这本书。 从自身说起，因为对技术和机器的热爱让他走向了计算机这门行业，而在书中，他也经常提及自己理性和感性思维相结合，对全栈工程师进行了深入分析。 全栈工程师是指一个能够处理数据库、服务器、系统工程和客户端所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web 栈，或者原生应用程序栈。这是官方的定义。而以我目前出入前端的思维通俗点来说，大概也就是一个人包揽前端，后端，一个人处理数据进行项目维护，甚至于设计图都是自己做的。 很多人都说全栈有很多好处，不同担心很多人编写不同步，思维不一致，导致做出来的项目每个人的想法不同，全栈一个人包揽所有的过程，都在自己脑子里。 可能因为我进入这个行业不久，我认为全栈是不太合理的存在，打个比方说，在流水线还没出现之间，手工作坊基本都是一个人负责所有的产品制作，从原料，制作，打磨，成品，或许很经过很多步骤，但是一个人都可以完美的做出来，就这样类似全栈工程师这样的存在。 而生产线就更像一个团队，产品，UI，前端，后端测试等，每个人相互配合。 全栈和团队比起来，我个人觉得团队的优势更大，但架不住老板喜欢一个人干三个人活，更喜欢全栈一点。 培养一个全栈的花费的时间和精力难以想象，甚至不确定培养一定成功，但是如果专精某一技术领域，成为高级工程师的概率绝对远大于一个全栈。当然这也只是我个人的臆测，并没有具体的数据支撑。 书中也提及，流水线带来的另一个好处，不会对某个工程师产生依赖性，即使失去这个员工，也可以让被人接手工作 说了很多团队化的好处，这不代表就没有弊端，肯定是有的，书中总结出来几点： 工程师职责不清导致效率低 工程师缺乏主人感导致产品质量差 工程师缺乏全局的视野影响个人成长 更多角色导致项目效率低下 “因为各司其职的工作流程有效率低下、成本高的缺点，所以很多创业公司都不会配备齐全的流水线，而是希望采用更灵活的方式来组建团队，全栈工程师也因此成为了理想的选择。但是全栈工程师的兴起还离不开这两个重要因素：技术的发展，以及提供 PaaS 服务的平台越来越多。” 虽然做成为一个全栈工程师需要耗费大量的时间精力来打磨，但是这个思维我还是比较喜欢的。比如说，有 a,b,c 三个人，分别擅长各自的领域，有一天他们共同负责的项目出了一个小问题，但是问题出在哪里领域还不知道，虽然是个小问题，但需要每个人去查验一遍，因为是三个领域，这就导致应该有两个人的查验是无效的，这从另一个方向来说也降低了项目效率。 然后这时候，有一个工程师 s，注意他不是全栈工程师，只是喜欢学习多领域的技术，掌握了一些不算太高深的技术知识，查验了一遍，很快就找出了问题所在。 那他一个人效率就相当于三个的效率了，其实这样说并不严谨，我也只是打个比方。 我突然想到一句话，不知道说的准确与否， “全栈的职位存在是不合理的，但全栈的思维是一个有上进心的工程师所必备的。”</div>
          <div class="index-post-meta">
            <a href="/blog/10.html/"> # 2020-09-18</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/8.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/8.html/">
            <h2>chrome 浏览器中对 autoplay 的一些处理技巧</h2>
          </a>
          <div class="text">我在写博客的时候，想给博客网页添加自己喜欢的音乐，这样我在写作和阅读的时候，心情也会比较愉悦，这个时候，我们就需要用到audio这个标签。 &lt;audio src=&#34;&#34;&gt;&lt;/audio&gt; 同时 audio 标签还带有很多实用的属性，常用的有以下几个： src &ndash; 这个就不说了，懂的都懂 autoplay &ndash; 如果出现该属性，音频在就绪后马上播放 controls &ndash; 网页中显示音频控件 loop &ndash; 循环播放 muted &ndash; 默认静音 但是我在设置 autoplay 的时候发现，chrome 对自动播放深恶痛绝，直接从根源上限制了这个属性的开启，意思是说，这个属性直接禁用，在打开网页没有交互的情况下，不允许自动播放。 但仔细想一想，这个做法其实是对用户比较有利的。假设用户使用的时候宽带流量，直接自动播放视频、音频，就会对用户造成损失。甚至一些广告会自动播放，这就直接影响到了用户的体验。所以，对于 chrome 的做法我还是比较赞同的。 回过头一想，不对啊，我的目的是解决这个问题，不是夸赞谷歌的。我想给自己的个人博客添加喜欢的音乐，所以我找了一个不算办法的办法。我直接在模拟一个事件，当鼠标点击网页任意处的时候，自动触发 autoplay 的音频效果，直接上代码。 &lt;script&gt; function toggleSound() { var music = document.getElementById(&#34;vd&#34;); //获取ID console.log(music); console.log(music.paused); if (music.paused) { //判读是否播放 music.paused=false; music.play(); //没有就播放 } } setInterval(&#34;toggleSound()&#34;,1); &lt;/script&gt; 这样处理过之后，插入音频，任意点击网页某个地方，都会触发播放效果，但凡事有利有弊，这样做的话，一旦开启播放，将无法启用暂停功能，也就是说会一直播放下去 如果是像我这样写个人博客，这个弊端倒是影响不大，我在这里记录一下这个方法。</div>
          <div class="index-post-meta">
            <a href="/blog/8.html/"> # 2020-09-11</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/7.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/7.html/">
            <h2>推荐书籍《CSS 世界》</h2>
          </a>
          <div class="text">本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰灯方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的 CSS 知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析 CSS 的相关知识与常见问题。 作者还为本书开发了专门的配套网站，进行实例展示。问题答疑。作为一本 CSS 深度学习的书，书中介绍大量许多前端开发人员都不知道的 CSS 知识点。通过阅读本书，读者会对 CSS 世界的深度和广度有一个全新的认识。 这本书作者采用口语化的方式，讲述在 css 中遇到的一些有意思的问题，循序渐进，引人入胜，对有前端基础的人来说，读这本书还是很有意思的。我经常在闲余时间看看这本书，会给我一些启发。</div>
          <div class="index-post-meta">
            <a href="/blog/7.html/"> # 2020-08-11</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/6.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/6.html/">
            <h2>文字溢出隐藏以及和 flex 冲突的问题</h2>
          </a>
          <div class="text">在某些段落中，页面要求文字只显示一行，但是width固定，而文字过长，就会出现一个需求，超过长度限制的文字被隐藏且显示省略号，css 支持这样的属性。 单行文本溢出隐藏 div{ overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } 多行文本溢出隐藏 div { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } 简单的几行代码就可以达到我们的要求。 但是有一个我们需要注意的地方！！ flex 布局是前端写代码经常使用的一种布局方式，简单便捷且有效，但是在使用 flex 布局的元素中不能同时使用文字溢出隐藏，也就是两者不能同时出现在同一标签中。 这里，我们也有对应的解决办法。 只要保证 flex 布局和隐藏的样式不在同级元素中就可以，所以在文字外部多包裹一层标签。 可以采用下面这段代码的写法； &lt;p&gt; &lt;!-- 我们在这一层的标签进行flex布局 --&gt; &lt;span&gt; &lt;!-- 这一层的标签我们引入文字过长隐藏的样式 --&gt; &lt;!-- 文本 --&gt; &lt;/span&gt; &lt;/p&gt;</div>
          <div class="index-post-meta">
            <a href="/blog/6.html/"> # 2020-08-03</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/5.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/5.html/">
            <h2>vue 生命周期</h2>
          </a>
          <div class="text">学习 vue 中一个非常重要的领域，就是生命周期，它包含了很多的内容。每个 vue 实例在被创建的时候都要经历一系列的初始化过程，这个过程就是 vue 的生命周期。 每个 vue 实例在被创建的时候都要经过一系列的初始化过程——例如，需要把设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等，我们要把这一系列的过程称为组件的生命周期（组件从注册到销毁的整个过程）。我们有时候需要在组件生命周期的某个过程中，执行某些代码，基于此，vue 提供了生命周期钩子函数，给了用户在不同阶段添加自己的代码的机会。 但是在此之前，我们要详细的介绍下组件的生命周期，以及生命后期中每个阶段组件完成和未完成的部分。 一、组件的生命周期 放一张大家都很熟悉的官网文章中对生命周期的注释图。 从图中可以看出，vue 为生命周期提供了 8 个钩子函数，分别是： beforeCreate: 创建前 created: 创建后 beforeMount: 挂载前 mounted: 挂载后 beforeUpate: 更新前 upated: 更新后 beforeDestoy: 销毁前 destoyed: 销毁后 1.beforeCreate beforeCreate 在 vue 实例发生之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 我们在上面的例子中在的 beforeCreate 钩子中调用 Vue 的 data 和 method，来看一下结果： 可以看到 Vue 中的 data 和方法都是去不到的，并且是在 wath 之前执行 2.created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 主要应用：调用数据，调用方法，调用异步函数 console 输出的结果我们看一下 可以看到：created 钩子可以获取 Vue 的 data，调用 Vue 方法，获取原本 HTML 上的直接加载出来的 DOM，但是无法获取到通过挂载模板生成的 DOM（例如：v-for 循环遍历 Vue.list 生成 li） 3.beforeMount 在挂载开始之前被调用：相关的 render 函数（模板）首次被调用。 例如通过 v-for 生成的 html 还没有被挂载到页面上 beforeMount: function () { console.log(&#39;beforeMount:&#39;,document.getElementsByTagName(&#39;li&#39;).length); }, console 打印出来的 beforeMount 为 1 4.mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 有初始值的 DOM 渲染，例如我们的初始数据 list，渲染出来的 li，只有这里才能获取 mounted: function () { console.log(&#39;mounted:&#39;,document.getElementsByTagName(&#39;li&#39;).length); }, 结果 mounted: 3 , 可以看到到这里为止，挂载到实例上了，我们可以获取到 li 的个数了 5.beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 当我们更改 Vue 的任何数据，都会触发该函数 beforeUpdate: &#34;function () { console.log(&#39;beforeUpdate 钩子执行.&#39;); console.log(&#39;beforeUpdate:&#39;+this.message) }, 6.updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 数据更新就会触发（vue 所有的数据只有有更新就会触发）,如果想数据一遍就做统一的处理，可以用这个，如果想对不同数据的更新做不同的处理可以用 nextTick，或者是 watch 进行监听 updated: function () { console.log(&#39;updated 钩子执行...&#39;); console.log(&#39;updated:&#39;,this.message) }, 7.beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 8.destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 结果 可以看打到销毁 Vue 实例时会调用这两个函数</div>
          <div class="index-post-meta">
            <a href="/blog/5.html/"> # 2020-06-19</a>
            
            
            <span class="namenode">技术</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/blog\/1.html\/'">
        <div class="index-post-content-long">
          <a href="/blog/1.html/">
            <h2>hello, world</h2>
          </a>
          <div class="text">2020 年 6 月 14 日 我的博客正式建立。 愿一切安好。</div>
          <div class="index-post-meta">
            <a href="/blog/1.html/"> # 2020-06-14</a>
            
            
            <span class="namenode">随笔</span>
            
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/serve\/'">
        <div class="index-post-content-long">
          <a href="/serve/">
            <h2>免费服务</h2>
          </a>
          <div class="text">提供一些免费服务。 工具 基于 Cloudflare Workers AI 的绘画工具 https://ai.zishu.me/ 基于 telegraph + Cloudflare 的免费图床 https://zsh.im/ 临时邮件服务 https://b3260cb9.temp-email-de0.pages.dev/ 免费文本 logo 生成器 https://logo.zishu.me/ 镜像源 Rsshub 镜像源 https://rsshub.zishu.me/ Docker 镜像源 https://workers-docker.zishu.me/ gravatar 头像国内镜像 https://gravatar.zishu.me/</div>
          <div class="index-post-meta">
            <a href="/serve/"> # 0001-01-01</a>
            
          </div>
        </div>
      </div>
      

      
      
      


      
      <div class="index-post" onclick="javascript:window.location.href='\/about\/'">
        <div class="index-post-content-long">
          <a href="/about/">
            <h2>关于</h2>
          </a>
          <div class="text">1.个人介绍 const author = { name: &#39;子舒&#39;, create_date: 1998, tags: [&#39;前端程序员&#39;, &#39;独立博客作者&#39;, &#39;骑行爱好者&#39;, &#39;摄影爱好者&#39;, &#39;INFJ 人格&#39;], adress: &#39;杭州&#39;, email: &#39;anghunk@gmail.com&#39;, github: &#39;https://github.com/dlzmoe&#39;, blog: &#39;https://zishu.me&#39;, description: &#39;喜欢折腾技术，研究各种奇怪的程序和网站，喜欢户外运动，热爱生活。&#39; } 如果想要添加友链，可以使用以下信息 (click me) title: 子舒的博客 author: 子舒 url: https://zishu.me avatar: https://imgurl.zishu.me/author.webp description: 喜欢折腾技术，研究各种奇怪的程序和网站，喜欢户外运动，热爱生活。 我的 计划单。 同时将周刊一起发布到了本网站，督促自己多扩展眼界，获取更新的知识，不管是技术类型还是娱乐，让自己的容量不断 +1. 提供一些免费服务。 2.友情链接 有时候就会遇到一些文章写的不错的博主，于是就记录在这里了。 余果的博客 // 涛叔 // 江卮可乐 // 东东博客 // Leon Fong // 卢涛南博客 // Airing 的博客 // Jiang&rsquo;s Blog // ImQi1 的博客 5.版权声明 本站文章所有版权均归本人所有，未经允许，不允许转载。</div>
          <div class="index-post-meta">
            <a href="/about/"> # 0001-01-01</a>
            
          </div>
        </div>
      </div>
      

      

      



















<div class="page">
  
  <a href="/page/29/" class="prev">上一页</a>
  

  
  <a href="/page/31/" class="next">下一页</a>
  


</div>



    </div>

    <footer id="foot">
  <p>© 2020 - 2024 Powered by
    <a href="https://github.com/dlzmoe/blog" target="_blank">Github</a>
    / <a href="/index.xml" target="_blank">RSS</a>
  </p>
</footer>

<script src="/js/main.js"></script>
<script defer src="https://cn.vercount.one/js"></script>
  </section>

  <script>
    const time = "2020-06-14";
    var now = new Date();
    var end = new Date(time);
    var diff = Math.abs(now - end);
    var days = Math.ceil(diff / (1000 * 60 * 60 * 24));
    $('#days').html(days);
  </script>
</body>

</html>